<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Top-Down Doom-like</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        #gameContainer {
            border: 4px solid #4a4a4a;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            position: relative; /* Important for absolute positioning of uiContainer */
            background-color: #2a2a2a;
            width: 800px; 
            height: 600px; 
        }
        canvas {
            display: block;
            background-color: #333;
            cursor: crosshair;
        }
        #topUiContainer {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 800px; /* Match gameContainer width */
            padding: 5px 10px;
            font-size: 16px; 
            color: #cccccc;
            box-sizing: border-box;
            margin-bottom: 5px; 
        }
        #uiContainer { /* Bottom UI bar */
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center; 
            padding: 8px 15px; 
            font-size: 14px; 
            color: #cccccc; 
            background-color: rgba(0, 0, 0, 0.75); 
            box-sizing: border-box;
            z-index: 5; 
        }
        #healthDisplayContainer, #scoreDisplayContainer, #levelDisplayContainer {
             color: #ff4136; 
        }
        #keysDisplayContainer {
            display: flex;
            align-items: center;
            gap: 8px;
             color: #ff4136;
        }
        #keysDisplay { 
            display: flex;
            gap: 5px; 
        }
        .key-icon {
            width: 18px; 
            height: 18px;
            border: 1px solid #888;
            border-radius: 3px;
            display: inline-block;
            opacity: 0.3; 
        }
        .key-icon.red { background-color: red; }
        .key-icon.yellow { background-color: yellow; }
        .key-icon.blue { background-color: blue; }
        .key-icon.collected { opacity: 1; }
        
        #weaponInfoContainer { 
            display: flex;
            align-items: center;
            gap: 10px; 
        }
        
        #weaponInventoryIcons {
            display: flex;
            gap: 6px; 
            align-items: center;
            font-size: 14px; 
        }
        #weaponInventoryIcons > span:first-child { /* "Weapons:" label */
             color: #00ff00;
        }
        .weapon-icon-display {
            border: 1px solid #555;
            padding: 3px 5px;
            border-radius: 4px;
            font-size: 12px;
            opacity: 0.4;
            color: #888; 
            display: flex; 
            align-items: center;
            gap: 4px;
            min-width: 50px; 
            justify-content: center;
        }
        .weapon-icon-display .weapon-char {
            font-weight: bold;
        }
        .weapon-icon-display .ammo-text-display {
            font-size: 10px;
        }
        .weapon-icon-display.collected {
            opacity: 0.7; 
            border-color: #00aa00;
            color: #00aa00;
        }
        .weapon-icon-display.selected-weapon-icon {
            opacity: 1;
            border-color: #00ff00; 
            color: #00ff00;
            box-shadow: 0 0 8px #00ff00;
            transform: scale(1.05);
        }

        #messageOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: white;
            font-size: 24px;
            z-index: 10;
        }
        #messageOverlay h2 {
            font-size: 36px;
            color: #ff4136;
            margin-bottom: 20px;
        }
        #messageOverlay p {
            margin-bottom: 20px; 
        }
        #difficultySelection {
            margin-bottom: 30px;
            display: flex;
            gap: 15px;
        }
        .game-button, .difficulty-button { 
            font-family: 'Press Start 2P', cursive;
            color: white;
            border-width: 2px;
            border-style: solid;
            padding: 10px 20px; 
            font-size: 16px; 
            cursor: pointer;
            text-transform: uppercase;
            transition: background-color 0.3s, transform 0.1s;
        }
        .game-button { 
            background-color: #c00;
            border-color: #800;
            box-shadow: 0 4px #500;
            padding: 15px 30px; 
            font-size: 18px;   
        }
        .game-button:hover { background-color: #e00; }
        .game-button:active { background-color: #a00; transform: translateY(2px); box-shadow: 0 2px #500; }

        .difficulty-button {
            background-color: #555;
            border-color: #333;
            box-shadow: 0 3px #222;
        }
        .difficulty-button:hover { background-color: #777; }
        .difficulty-button:active { background-color: #444; transform: translateY(1px); box-shadow: 0 2px #222; }
        .difficulty-button.selected {
            background-color: #ff4136; 
            border-color: #c00;
            box-shadow: 0 3px #800;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">
    <div id="topUiContainer">
        <div id="scoreDisplayContainer">Score: <span id="scoreDisplay">0</span></div>
        <div id="levelDisplayContainer">Level: <span id="waveDisplay">1</span></div>
    </div>

    <div id="gameContainer" class="rounded-lg overflow-hidden shadow-2xl">
        <canvas id="gameCanvas"></canvas>
        <div id="uiContainer">
            <div id="healthDisplayContainer">Health: <span id="healthDisplay">100</span></div>
            
            <div id="weaponInfoContainer">
                <div id="weaponInventoryIcons">
                    <span class="text-gray-400 mr-1">Weapons:</span>
                    <span class="weapon-icon-display" data-weapon-name="Pistol" id="pistolIconDisplay">
                        <span class="weapon-char">P</span> <span class="ammo-text-display">Inf</span>
                    </span>
                    <span class="weapon-icon-display" data-weapon-name="Shotgun" id="shotgunIconDisplay">
                        <span class="weapon-char">S</span> <span class="ammo-text-display">--</span>
                    </span>
                    <span class="weapon-icon-display" data-weapon-name="Machine Gun" id="machineGunIconDisplay">
                        <span class="weapon-char">M</span> <span class="ammo-text-display">--</span>
                    </span>
                </div>
            </div>

            <div id="keysDisplayContainer">
                <span class="text-gray-400">Keys:</span>
                <div id="keysDisplay">
                    <span class="key-icon red" id="redKeyIcon"></span>
                    <span class="key-icon yellow" id="yellowKeyIcon"></span>
                    <span class="key-icon blue" id="blueKeyIcon"></span>
                </div>
            </div>
        </div>
        <div id="messageOverlay" style="display: none;"> 
            <h2 id="messageTitle">Game Over</h2>
            <p id="messageText">Your score: 0</p>
            <div id="difficultySelection">
                <button class="difficulty-button" data-difficulty="easy">Easy</button>
                <button class="difficulty-button selected" data-difficulty="medium">Medium</button>
                <button class="difficulty-button" data-difficulty="hard">Hard</button>
            </div>
            <button id="restartButton" class="game-button">Restart Game</button>
        </div>
    </div>
    
    <img id="playerSprite" src="https://jeffhockema.com/sprites/military1.png" style="display: none;" alt="Player Sprite" crossorigin="anonymous">


    <div id="controlsInfo" class="mt-4 text-sm text-gray-400">
        Controls: Arrow Keys or WASD to Move, 1/2/3 to Switch Weapon, Mouse to Aim, Click to Shoot. (Cheats: I, K, G)
    </div>

    <script>
        // Audio initialization
        async function initializeAudio() {
            try {
                if (Tone.context.state === 'suspended') {
                    await Tone.start();
                }
            } catch (e) {
                console.warn("Warning during initial Tone.start():", e);
            }
        }
        initializeAudio(); 

        // DOM Elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const healthDisplay = document.getElementById('healthDisplay');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const waveDisplay = document.getElementById('waveDisplay'); 
        const weaponInventoryIcons = document.getElementById('weaponInventoryIcons');
        const messageOverlay = document.getElementById('messageOverlay');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');
        const controlsInfo = document.getElementById('controlsInfo');
        const redKeyIcon = document.getElementById('redKeyIcon');
        const yellowKeyIcon = document.getElementById('yellowKeyIcon');
        const blueKeyIcon = document.getElementById('blueKeyIcon');
        const difficultySelectionDiv = document.getElementById('difficultySelection');
        const difficultyButtons = document.querySelectorAll('.difficulty-button');
        const playerSpriteImage = document.getElementById('playerSprite'); 

        // Game Constants
        const TILE_SIZE = 40;
        const MAP_COLS = 50; 
        const MAP_ROWS = 40; 

        const VIEWPORT_WIDTH = 800; 
        const VIEWPORT_HEIGHT = 600; 
        canvas.width = VIEWPORT_WIDTH;
        canvas.height = VIEWPORT_HEIGHT;

        // Player Sprite Constants
        const PLAYER_SPRITE_FRAME_WIDTH = 26;
        const PLAYER_SPRITE_FRAME_HEIGHT = 36;
        const PLAYER_SPRITE_SCALE = 1.2; 

        const playerFrames = { 
            down:  { x: 3, y: 0 }, 
            left:  { x: 3, y: 1 },  
            right: { x: 3, y: 2 }, 
            up:    { x: 3, y: 3 },    
        };
        
        const camera = {
            x: 0, y: 0,
            width: VIEWPORT_WIDTH, height: VIEWPORT_HEIGHT,
            update: function(player) {
                if (!player) return; 
                this.x = Math.max(0, Math.min(player.x - this.width / 2, (MAP_COLS * TILE_SIZE) - this.width));
                this.y = Math.max(0, Math.min(player.y - this.height / 2, (MAP_ROWS * TILE_SIZE) - this.height));
            }
        };

        // Tile Types
        const TILE_EMPTY = 0;
        const TILE_WALL = 1;
        const TILE_DOOR_RED = 2;
        const TILE_DOOR_YELLOW = 3;
        const TILE_DOOR_BLUE = 4;
        const TILE_KEY_RED = 5;
        const TILE_KEY_YELLOW = 6;
        const TILE_KEY_BLUE = 7;
        const TILE_EXIT = 8;
        const TILE_WEAPON_SHOTGUN = 9;
        const TILE_WEAPON_MACHINEGUN = 10;


        // Wall Styles
        const wallStyles = [
            { name: "Classic Grey", fillColor: '#5a5a5a', borderColor: '#444444' },
            { name: "Industrial Metal", fillColor: '#787A7C', borderColor: '#555759', pattern: drawMetalPattern }, 
            { name: "Ancient Stone", fillColor: '#6F6659', borderColor: '#504A40', pattern: drawStonePattern },  
            { name: "Mossy Dungeon", fillColor: '#4A5D43', borderColor: '#384831' }, 
            { name: "Crimson Hell", fillColor: '#7D2828', borderColor: '#5A1D1D' }   
        ];
        let currentWallStyle = wallStyles[0]; 

        // Game State Variables
        let player, bullets, enemies, gameMap, healthPacks, visibilityMap;
        let score = 0;
        let currentLevel = 1; 
        let gameOver = false;
        let gameRunning = false; 
        let enemiesToSpawnPerLevel = 10; 
        let enemiesSpawnedThisLevel = 0; 
        let enemiesRemaining = 0;
        let gameLoopId;
        let selectedDifficulty = 'medium'; 
        let isLevelCompleting = false;

        const keys = { 
            ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
            w: false, s: false, a: false, d: false,
            '1': false, '2': false, '3': false,
            i_cheat_processed: false, 
            k_cheat_processed: false,
            g_cheat_processed: false,
            weapon_1_processed: false, 
            weapon_2_processed: false,
            weapon_3_processed: false
        };
        const mouse = { x: VIEWPORT_WIDTH / 2, y: VIEWPORT_HEIGHT / 2, down: false }; 

        // Audio Synths
        let synth, metalSynth, hitSynth, explosionSynth, healthPickupSynth, keyPickupSynth, doorOpenSynth, weaponPickupSynth, teleportSynth, splitSynth, emptyGunSynth; 
        let lastHitSoundTime = 0; 
        const HIT_SOUND_COOLDOWN = 50; 
        let lastEnemyDestroySoundTime = 0; 
        const ENEMY_DESTROY_SOUND_COOLDOWN = 100; 

        function setupSynths() {
            synth = new Tone.Synth().toDestination();
            metalSynth = new Tone.MetalSynth({frequency: 50, envelope: { attack: 0.001, decay: 0.1, release: 0.1 }, harmonicity: 3.1, modulationIndex: 16, resonance: 2000, octaves: 0.5}).toDestination();
            metalSynth.volume.value = -15;
            hitSynth = new Tone.NoiseSynth({noise: { type: "pink" }, envelope: { attack: 0.001, decay: 0.05, sustain: 0 }}).toDestination();
            hitSynth.volume.value = -10;
            explosionSynth = new Tone.NoiseSynth({noise: { type: "white" }, envelope: { attack: 0.005, decay: 0.2, sustain: 0 }}).toDestination();
            explosionSynth.volume.value = -5;
            healthPickupSynth = new Tone.Synth({oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.2 }, volume: -10}).toDestination();
            keyPickupSynth = new Tone.Synth({oscillator: {type: "triangle"}, envelope: {attack: 0.01, decay: 0.2, release: 0.2}, volume: -8}).toDestination();
            doorOpenSynth = new Tone.MetalSynth({frequency: 100, envelope: {attack:0.01, decay:0.3, release: 0.1}, harmonicity: 1.1, modulationIndex:5, resonance: 500, octaves: 1.5, volume: -12}).toDestination();
            weaponPickupSynth = new Tone.Synth({ oscillator: {type: "sawtooth"}, envelope: {attack: 0.02, decay: 0.15, release: 0.2}, volume: -9}).toDestination();
            teleportSynth = new Tone.Synth({ oscillator: { type: 'triangle8' }, envelope: { attack: 0.01, decay: 0.2, release: 0.2 }, volume: -10 }).toDestination();
            splitSynth = new Tone.PluckSynth({ attackNoise: 0.5, dampening: 2000, resonance: 0.8, volume: -8 }).toDestination();
            emptyGunSynth = new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 2, envelope: { attack: 0.001, decay: 0.1, sustain: 0 } }).toDestination();
            emptyGunSynth.volume.value = -10;
            console.log("Synths initialized.");
        }
         async function ensureAudioAndSynths() {
            if (Tone.context.state === 'suspended') {
                try { await Tone.start(); } catch (err) { console.error("Error starting Tone.js:", err); throw err; }
            }
            if (!synth) { setupSynths(); }
        }

        // Sound Playback Functions
        function playShootSound(weaponName) { 
            if (Tone.context.state !== 'running') return;
            const now = Tone.now() + 0.001; 

            if (weaponName === 'Pistol' && metalSynth) {
                metalSynth.frequency.setValueAtTime(50, now);
                metalSynth.triggerAttackRelease("C2", "8n", now);
            } else if (weaponName === 'Shotgun' && metalSynth) {
                metalSynth.frequency.setValueAtTime(30, now); 
                metalSynth.triggerAttackRelease("A1", "4n", now);
            } else if (weaponName === 'Machine Gun') {
                const mgSynth = new Tone.MetalSynth({
                    frequency: 70,
                    envelope: { attack: 0.001, decay: 0.05, release: 0.05 }, 
                    harmonicity: 3.1,
                    modulationIndex: 16,
                    resonance: 1500,
                    octaves: 0.5,
                    volume: -18
                }).toDestination();
                mgSynth.triggerAttackRelease("D2", "32n", now); 
                const duration = 0.001 + 0.05 + 0.05 + 0.02;
                setTimeout(() => {
                    if (mgSynth && !mgSynth.disposed) {
                        mgSynth.dispose();
                    }
                }, duration * 1000);
            }
        }
        function playHitSound() { 
            const now = Tone.now() * 1000; 
            if (now - lastHitSoundTime < HIT_SOUND_COOLDOWN) {
                return; 
            }
            lastHitSoundTime = now;
            if (hitSynth && Tone.context.state === 'running') hitSynth.triggerAttackRelease("8n"); 
        }
        function playPlayerHitSound() { if (synth && Tone.context.state === 'running') synth.triggerAttackRelease("A1", "8n"); }
        function playEnemyDestroySound() { 
            const now = Tone.now() * 1000;
            if (now - lastEnemyDestroySoundTime < ENEMY_DESTROY_SOUND_COOLDOWN) {
                return;
            }
            lastEnemyDestroySoundTime = now;
            if (explosionSynth && Tone.context.state === 'running') explosionSynth.triggerAttackRelease("0.2"); 
        }
        function playEnemyShootSound() { 
            if (Tone.context.state === 'running') {
                const tempEnemySynth = new Tone.Synth({
                    oscillator: { type: "square" },
                    envelope: { attack: 0.005, decay: 0.05, sustain: 0.01, release: 0.1 },
                    volume: -20
                }).toDestination();
                tempEnemySynth.triggerAttackRelease("G3", "16n", Tone.now() + 0.001);
                const duration = 0.005 + 0.05 + 0.01 + 0.1 + 0.05; 
                setTimeout(() => {
                    if (tempEnemySynth && !tempEnemySynth.disposed) {
                        tempEnemySynth.dispose();
                    }
                }, duration * 1000);
            }
        }
        function playHealthPickupSound() { 
            if (Tone.context.state === 'running') {
                const tempHealthSynth = new Tone.Synth({oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.2 }, volume: -10}).toDestination();
                tempHealthSynth.triggerAttackRelease("C5", "8n", Tone.now() + 0.001);
                const duration = 0.01 + 0.1 + 0.05 + 0.2 + 0.05;
                 setTimeout(() => {
                    if (tempHealthSynth && !tempHealthSynth.disposed) {
                        tempHealthSynth.dispose();
                    }
                }, duration * 1000);
            }
        }
        function playKeyPickupSound() { if (keyPickupSynth && Tone.context.state === 'running') keyPickupSynth.triggerAttackRelease("E5", "8n");}
        function playDoorOpenSound() { if (doorOpenSynth && Tone.context.state === 'running') doorOpenSynth.triggerAttackRelease("F#2", "4n");}
        function playWeaponPickupSound() { if (weaponPickupSynth && Tone.context.state === 'running') weaponPickupSynth.triggerAttackRelease("A4", "8n");}
        function playTeleportSound() { if (teleportSynth && Tone.context.state === 'running') teleportSynth.triggerAttackRelease("C6", "16n", Tone.now() + 0.01); }
        function playSplitSound() { if (splitSynth && Tone.context.state === 'running') splitSynth.triggerAttackRelease("G2", "8n", Tone.now() + 0.01); }
        function playEmptyGunSound() { if (emptyGunSynth && Tone.context.state === 'running') emptyGunSynth.triggerAttackRelease("C2", "16n"); }


        // BFS Pathfinding (for level validation)
        function findPath(startX, startY, endX, endY, currentMap, keysAvailable) {
            const queue = [[startX, startY, []]]; 
            const visited = new Set();
            visited.add(`${startX},${startY}`);

            while (queue.length > 0) {
                const [x, y, path] = queue.shift();

                if (x === endX && y === endY) return true; 

                const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                for (const [dx, dy] of directions) {
                    const nextX = x + dx;
                    const nextY = y + dy;

                    if (nextX >= 0 && nextX < MAP_COLS && nextY >= 0 && nextY < MAP_ROWS && !visited.has(`${nextX},${nextY}`)) {
                        const tileType = currentMap[nextY][nextX];
                        let canPass = false;
                        if (tileType === TILE_EMPTY || 
                            (tileType >= TILE_KEY_RED && tileType <= TILE_WEAPON_MACHINEGUN) || 
                            tileType === TILE_EXIT) {
                            canPass = true;
                        } else if (tileType === TILE_DOOR_RED && keysAvailable.red) {
                            canPass = true;
                        } else if (tileType === TILE_DOOR_YELLOW && keysAvailable.yellow) {
                            canPass = true;
                        } else if (tileType === TILE_DOOR_BLUE && keysAvailable.blue) {
                            canPass = true;
                        }
                        
                        if (canPass) {
                            visited.add(`${nextX},${nextY}`);
                            queue.push([nextX, nextY, [...path, [nextX, nextY]]]);
                        }
                    }
                }
            }
            return false; 
        }
        
        // BFS Pathfinding for Visibility (treats all closed doors as walls)
        function findPathForVisibility(startX, startY, endX, endY, currentMap) {
            const queue = [[startX, startY, []]];
            const visited = new Set();
            visited.add(`${startX},${startY}`);

            while (queue.length > 0) {
                const [x, y, path] = queue.shift();

                if (x === endX && y === endY) return true;

                const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                for (const [dx, dy] of directions) {
                    const nextX = x + dx;
                    const nextY = y + dy;

                    if (nextX >= 0 && nextX < MAP_COLS && nextY >= 0 && nextY < MAP_ROWS && !visited.has(`${nextX},${nextY}`)) {
                        const tileType = currentMap[nextY][nextX];
                        if (tileType === TILE_EMPTY || 
                            (tileType >= TILE_KEY_RED && tileType <= TILE_WEAPON_MACHINEGUN) || 
                            tileType === TILE_EXIT) {
                            visited.add(`${nextX},${nextY}`);
                            queue.push([nextX, nextY, [...path, [nextX, nextY]]]);
                        }
                    }
                }
            }
            return false;
        }
        
        function updateVisibility(playerTileX, playerTileY, currentMap) {
            visibilityMap = Array(MAP_ROWS).fill(null).map(() => Array(MAP_COLS).fill(false));
            const queue = [];
            const visitedForBFS = new Set(); 

            if (playerTileX >= 0 && playerTileX < MAP_COLS && playerTileY >= 0 && playerTileY < MAP_ROWS) {
                queue.push([playerTileX, playerTileY]);
                visitedForBFS.add(`${playerTileX},${playerTileY}`);
                visibilityMap[playerTileY][playerTileX] = true; 
            }

            let head = 0;
            while(head < queue.length){
                const [x,y] = queue[head++];
                
                const directions = [[0, 1], [0, -1], [1, 0], [-1, 0],[ -1, -1 ], [ -1, 1 ], [ 1, -1 ], [ 1, 1 ]]; 
                for (const [dx, dy] of directions) {
                    const nextX = x + dx;
                    const nextY = y + dy;

                    if (nextX >= 0 && nextX < MAP_COLS && nextY >= 0 && nextY < MAP_ROWS) {
                        const neighborTileType = currentMap[nextY][nextX];
                        
                        if (!visitedForBFS.has(`${nextX},${nextY}`)) {
                             if (neighborTileType === TILE_EMPTY || 
                                (neighborTileType >= TILE_KEY_RED && neighborTileType <= TILE_WEAPON_MACHINEGUN) || 
                                neighborTileType === TILE_EXIT) {
                                
                                visibilityMap[nextY][nextX] = true;
                                visitedForBFS.add(`${nextX},${nextY}`);
                                queue.push([nextX, nextY]);
                            } else if (neighborTileType === TILE_WALL || 
                                       (neighborTileType >= TILE_DOOR_RED && neighborTileType <= TILE_DOOR_BLUE)) {
                                visibilityMap[nextY][nextX] = true; 
                                visitedForBFS.add(`${nextX},${nextY}`); 
                            }
                        }
                    }
                }
            }
        }


        // Level Generation: Rooms and Hallways with more robust sequential logic
        function generateMaze(cols, rows) {
            let map;
            let playerStartCell;
            let generationAttempts = 0;
            const MAX_GENERATION_ATTEMPTS = 25; 
            let levelIsValid = false;

            while (!levelIsValid && generationAttempts < MAX_GENERATION_ATTEMPTS) {
                map = Array(rows).fill(null).map(() => Array(cols).fill(TILE_WALL));
                const rooms = [];
                const MIN_ROOM_SIZE = 5; 
                const MAX_ROOM_SIZE = 11; 
                const NUM_ROOMS_ATTEMPT = 30; 
                const MIN_ROOMS_FOR_LOGIC = 5; 
                playerStartCell = { r: Math.floor(rows/2), c: Math.floor(cols/2) }; 

                // 1. Place Rooms
                for (let i = 0; i < NUM_ROOMS_ATTEMPT && rooms.length < NUM_ROOMS_ATTEMPT * 0.8; i++) { 
                    const roomWidth = MIN_ROOM_SIZE + Math.floor(Math.random() * (MAX_ROOM_SIZE - MIN_ROOM_SIZE + 1));
                    const roomHeight = MIN_ROOM_SIZE + Math.floor(Math.random() * (MAX_ROOM_SIZE - MIN_ROOM_SIZE + 1));
                    const roomX = Math.floor(Math.random() * (cols - roomWidth - 2)) + 1;
                    const roomY = Math.floor(Math.random() * (rows - roomHeight - 2)) + 1;
                    const newRoom = { x: roomX, y: roomY, width: roomWidth, height: roomHeight, connected: false, id: rooms.length, center: {x: roomX + Math.floor(roomWidth/2), y: roomY + Math.floor(roomHeight/2)} };
                    
                    let overlaps = false;
                    for (const existingRoom of rooms) {
                        if (newRoom.x < existingRoom.x + existingRoom.width + 1 && 
                            newRoom.x + newRoom.width + 1 > existingRoom.x &&
                            newRoom.y < existingRoom.y + existingRoom.height + 1 &&
                            newRoom.y + newRoom.height + 1 > existingRoom.y) {
                            overlaps = true; break;
                        }
                    }
                    if (!overlaps) {
                        rooms.push(newRoom);
                        for (let r = newRoom.y; r < newRoom.y + newRoom.height; r++) {
                            for (let c = newRoom.x; c < newRoom.x + newRoom.width; c++) {
                                map[r][c] = TILE_EMPTY;
                            }
                        }
                    }
                }

                if (rooms.length < MIN_ROOMS_FOR_LOGIC) {
                    console.warn(`Attempt ${generationAttempts + 1}: Insufficient rooms (${rooms.length}). Regenerating.`);
                    generationAttempts++;
                    levelIsValid = false; 
                    continue; 
                }

                // 2. Connect Rooms
                if (rooms.length > 0) {
                    playerStartCell = { r: rooms[0].center.y, c: rooms[0].center.x }; 
                    let connectedSet = new Set();
                    connectedSet.add(rooms[0].id);
                    rooms[0].connected = true;

                    while (connectedSet.size < rooms.length) {
                        let closestDist = Infinity;
                        let roomA = null, roomB = null; 

                        for (const rA of rooms) {
                            if (!rA.connected) continue;
                            for (const rB of rooms) {
                                if (rB.connected) continue;
                                const dist = Math.hypot(rA.center.x - rB.center.x, rA.center.y - rB.center.y);
                                if (dist < closestDist) {
                                    closestDist = dist;
                                    roomA = rA;
                                    roomB = rB;
                                }
                            }
                        }

                        if (roomA && roomB) {
                            let curX = roomA.center.x;
                            let curY = roomA.center.y;
                            // Carve horizontal tunnel first
                            while (curX !== roomB.center.x) {
                                if (map[curY][curX] === TILE_WALL) map[curY][curX] = TILE_EMPTY;
                                curX += Math.sign(roomB.center.x - curX);
                            }
                            if (map[curY][curX] === TILE_WALL) map[curY][curX] = TILE_EMPTY; 
                            // Then carve vertical tunnel
                            while (curY !== roomB.center.y) {
                                if (map[curY][curX] === TILE_WALL) map[curY][curX] = TILE_EMPTY;
                                curY += Math.sign(roomB.center.y - curY);
                            }
                            if (map[curY][curX] === TILE_WALL) map[curY][curX] = TILE_EMPTY; 

                            roomB.connected = true;
                            connectedSet.add(roomB.id);
                        } else {
                            console.warn("Could not connect all rooms in MST phase.");
                            break; 
                        }
                    }
                }


                // 3. Place Keys, Exit, Weapons and Doors Sequentially
                let itemPlacementOrder = []; 
                let availableRoomsForItems = [...rooms]; 

                function pickRoomForItem(mustBeDifferentFrom = []) {
                    if (availableRoomsForItems.length === 0) return null;
                    let pickedRoom = null;
                    let attempts = 0;
                    const playerStartRoomId = (actualPlayerStartRoom && actualPlayerStartRoom.id !== undefined) ? actualPlayerStartRoom.id : -1;

                    while(attempts < availableRoomsForItems.length * 3 && !pickedRoom) { 
                        let idx = Math.floor(Math.random() * availableRoomsForItems.length);
                        let candidate = availableRoomsForItems[idx];
                        let isDifferent = true;
                        if (candidate.id === playerStartRoomId) { 
                            isDifferent = false;
                        }
                        for(const diffRoom of mustBeDifferentFrom) {
                            if (diffRoom && candidate.id === diffRoom.id) { 
                                isDifferent = false;
                                break;
                            }
                        }
                        if (isDifferent) pickedRoom = candidate;
                        attempts++;
                    }
                    if (pickedRoom) { 
                        availableRoomsForItems = availableRoomsForItems.filter(r => r.id !== pickedRoom.id);
                    } else if (availableRoomsForItems.length > 0) { 
                        let fallbackIdx = availableRoomsForItems.findIndex(r => r.id !== playerStartRoomId);
                        if (fallbackIdx !== -1) {
                            pickedRoom = availableRoomsForItems.splice(fallbackIdx, 1)[0];
                        } else if (availableRoomsForItems.length > 0) { 
                            pickedRoom = availableRoomsForItems.pop();
                        }
                    }
                    return pickedRoom;
                }
                
                const actualPlayerStartRoom = rooms.length > 0 ? rooms[0] : null;

                const redKeyRoom = pickRoomForItem(actualPlayerStartRoom ? [actualPlayerStartRoom] : []);
                if (redKeyRoom) { itemPlacementOrder.push({item: TILE_KEY_RED, room: redKeyRoom}); }

                const yellowKeyRoom = pickRoomForItem(redKeyRoom ? [actualPlayerStartRoom, redKeyRoom] : (actualPlayerStartRoom ? [actualPlayerStartRoom] : []));
                if (yellowKeyRoom) { itemPlacementOrder.push({item: TILE_KEY_YELLOW, room: yellowKeyRoom}); }
                
                const blueKeyRoom = pickRoomForItem(yellowKeyRoom ? [actualPlayerStartRoom, redKeyRoom, yellowKeyRoom] : (redKeyRoom ? [actualPlayerStartRoom, redKeyRoom] : (actualPlayerStartRoom ? [actualPlayerStartRoom] : [])));
                if (blueKeyRoom) { itemPlacementOrder.push({item: TILE_KEY_BLUE, room: blueKeyRoom});}

                const exitRoom = pickRoomForItem(blueKeyRoom ? [actualPlayerStartRoom, redKeyRoom, yellowKeyRoom, blueKeyRoom] : (yellowKeyRoom ? [actualPlayerStartRoom, redKeyRoom, yellowKeyRoom] : (redKeyRoom ? [actualPlayerStartRoom, redKeyRoom] : (actualPlayerStartRoom ? [actualPlayerStartRoom] : []))));
                if (exitRoom) { itemPlacementOrder.push({item: TILE_EXIT, room: exitRoom}); }

                const shotgunRoom = pickRoomForItem(itemPlacementOrder.map(p => p.room).filter(r => r)); 
                if (shotgunRoom) itemPlacementOrder.push({item: TILE_WEAPON_SHOTGUN, room: shotgunRoom});
                
                const machineGunRoom = pickRoomForItem(itemPlacementOrder.map(p => p.room).filter(r => r));
                if (machineGunRoom) itemPlacementOrder.push({item: TILE_WEAPON_MACHINEGUN, room: machineGunRoom});


                itemPlacementOrder.forEach(p => {
                    if (p.room && p.room.center) map[p.room.center.y][p.room.center.x] = p.item;
                    else console.warn("Could not place item, room undefined:", p.item);
                });

                // REFINED Door Placement Logic - v8
                function placeDoorGuardingRoom(targetRoom, doorType) {
                    if (!targetRoom || !targetRoom.center) {
                        console.warn(`Cannot place ${doorType}, targetRoom is invalid.`);
                        return false;
                    }
                    const { x: roomX, y: roomY, width: roomW, height: roomH } = targetRoom;
                    const potentialDoorLocations = [];

                    // Scan tiles that are EMPTY and are direct entrances/exits of the target room
                    for (let r = roomY - 1; r <= roomY + roomH; r++) {
                        for (let c = roomX - 1; c <= roomX + roomW; c++) {
                            if (r < 0 || r >= rows || c < 0 || c >= cols) continue; 
                            if (r >= roomY && r < roomY + roomH && c >= roomX && c < roomX + roomW) continue; 

                            if (map[r][c] === TILE_EMPTY) { 
                                let connectsToTargetInterior = false;
                                let wallNeighborCount = 0; 
                                const directions = [[0,1], [0,-1], [1,0], [-1,0]]; 

                                for(const [dr, dc] of directions) {
                                    const nr = r + dr; 
                                    const nc = c + dc;

                                    if(nr >=0 && nr < rows && nc >=0 && nc < cols) {
                                        if (nr >= roomY && nr < roomY + roomH && nc >= roomX && nc < roomX + roomW && map[nr][nc] === TILE_EMPTY) {
                                            connectsToTargetInterior = true; 
                                        } else if (map[nr][nc] === TILE_WALL) {
                                            wallNeighborCount++;
                                        }
                                    } else { 
                                        wallNeighborCount++; 
                                    }
                                }
                                
                                if (connectsToTargetInterior && wallNeighborCount >= 2) { 
                                    potentialDoorLocations.push({ r, c });
                                }
                            }
                        }
                    }
                    
                    if (potentialDoorLocations.length > 0) {
                        const doorLoc = potentialDoorLocations[Math.floor(Math.random() * potentialDoorLocations.length)];
                        map[doorLoc.r][doorLoc.c] = doorType; 
                        console.log(`Placed ${doorType} at corridor tile (${doorLoc.c}, ${doorLoc.r}) to guard room ${targetRoom.id}`);
                        return true;
                    }
                    
                    console.warn(`Could not find suitable corridor entry to place ${doorType} for room ${targetRoom.id}`);
                    return false; 
                }


                if (yellowKeyRoom) placeDoorGuardingRoom(yellowKeyRoom, TILE_DOOR_RED);
                if (blueKeyRoom) placeDoorGuardingRoom(blueKeyRoom, TILE_DOOR_YELLOW);
                if (exitRoom) placeDoorGuardingRoom(exitRoom, TILE_DOOR_BLUE);
                
                // Validation using BFS
                levelIsValid = true;
                const pStartR = playerStartCell.r;
                const pStartC = playerStartCell.c;

                if (redKeyRoom && !findPath(pStartC, pStartR, redKeyRoom.center.x, redKeyRoom.center.y, map, {red:false, yellow:false, blue:false})) {
                    levelIsValid = false; console.warn(`Regen (Attempt ${generationAttempts+1}): Path to Red Key failed.`);
                }
                if (levelIsValid && yellowKeyRoom && redKeyRoom && !findPath(redKeyRoom.center.x, redKeyRoom.center.y, yellowKeyRoom.center.x, yellowKeyRoom.center.y, map, {red:true, yellow:false, blue:false})) {
                    levelIsValid = false; console.warn(`Regen (Attempt ${generationAttempts+1}): Path from Red Key to Yellow Key failed.`);
                }
                if (levelIsValid && blueKeyRoom && yellowKeyRoom && !findPath(yellowKeyRoom.center.x, yellowKeyRoom.center.y, blueKeyRoom.center.x, blueKeyRoom.center.y, map, {red:true, yellow:true, blue:false})) {
                    levelIsValid = false; console.warn(`Regen (Attempt ${generationAttempts+1}): Path from Yellow Key to Blue Key failed.`);
                }
                if (levelIsValid && exitRoom && blueKeyRoom && !findPath(blueKeyRoom.center.x, blueKeyRoom.center.y, exitRoom.center.x, exitRoom.center.y, map, {red:true, yellow:true, blue:true})) {
                    levelIsValid = false; console.warn(`Regen (Attempt ${generationAttempts+1}): Path from Blue Key to Exit failed.`);
                }
                
                if (!redKeyRoom || !yellowKeyRoom || !blueKeyRoom || !exitRoom) { 
                    levelIsValid = false;
                    console.warn(`Regen (Attempt ${generationAttempts+1}): Not all critical items (keys/exit) were placed.`);
                }


                generationAttempts++;
            } 

            if (!levelIsValid) {
                 console.error(`Failed to generate a valid level after ${MAX_GENERATION_ATTEMPTS} attempts. Using last generated map (might be flawed).`);
            } else {
                console.log(`Level generated successfully after ${generationAttempts} attempt(s).`);
            }
            
            const finalPStartR = playerStartCell.r;
            const finalPStartC = playerStartCell.c;
            for(let r_offset = -1; r_offset <= 1; r_offset++) {
                for (let c_offset = -1; c_offset <= 1; c_offset++) {
                    const r = finalPStartR + r_offset;
                    const c = finalPStartC + c_offset;
                    if (r >=0 && r < MAP_ROWS && c >=0 && c < MAP_COLS && map[r][c] !== undefined) map[r][c] = TILE_EMPTY;
                }
            }
            return { gameMap: map, playerStart: playerStartCell };
        }
        
        // HealthPack Class
        class HealthPack {
            constructor(x, y) {
                this.x = x; this.y = y; this.radius = TILE_SIZE / 3; this.healthValue = 25; this.color = 'lime'; 
            }
            draw() {
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = 'white'; const cW = this.radius/2.5, cL = this.radius*1.2;
                ctx.fillRect(this.x - cW/2, this.y - cL/2, cW, cL); ctx.fillRect(this.x - cL/2, this.y - cW/2, cL, cW);
            }
        }

        // Player Class
        class Player {
            constructor(x, y) { 
                this.x = x; this.y = y; 
                this.radius = TILE_SIZE / 3; 
                this.speed = 3.5; 
                this.health = 100; 
                this.maxHealth = 100; 
                this.angle = Math.PI / 2; // Default facing down (for sprite)
                this.keysCollected = { red: false, yellow: false, blue: false }; 
                this.canPhase = false; 
                this.weapons = [ 
                    { name: "Pistol", damage: 25 + currentLevel * 2, fireRate: 10, bulletSpeed: 10, spread: 0, numPellets: 1, color: '#ffeb3b', singleShot: true, ammo: Infinity, maxAmmo: Infinity },
                ];
                this.currentWeaponIndex = 0;
                this.shootCooldown = 0; 
                this.justFiredPistolOnThisClick = false; 
                this.currentAnimFrame = 0; 
                this.animTimer = 0;
                this.animSpeed = 8; 
                this.isMoving = false;
            }
            getCurrentWeapon() {
                return this.weapons[this.currentWeaponIndex];
            }
            addWeapon(newWeapon) {
                const existingWeapon = this.weapons.find(w => w.name === newWeapon.name);
                if (!existingWeapon) {
                    this.weapons.push(newWeapon); 
                    playWeaponPickupSound();
                } else {
                    if (existingWeapon.ammo !== Infinity && newWeapon.pickupAmmo) { 
                        existingWeapon.ammo = Math.min(existingWeapon.ammo + newWeapon.pickupAmmo, existingWeapon.maxAmmo);
                        console.log(`Added ammo to ${newWeapon.name}. New ammo: ${existingWeapon.ammo}`);
                    } else {
                        console.log(`Already have ${newWeapon.name} or it has infinite ammo.`);
                    }
                }
                 updateWeaponUI(); 
            }
            switchWeapon(index) {
                if (index >= 0 && index < this.weapons.length) {
                    this.currentWeaponIndex = index;
                    updateWeaponUI();
                    console.log("Switched to", this.getCurrentWeapon().name);
                }
            }
            draw() { 
                if (playerSpriteImage && playerSpriteImage.complete && playerSpriteImage.naturalHeight !== 0) {
                    ctx.save(); 
                    ctx.translate(this.x, this.y); 
                    
                    let frameDirection = playerFrames.down; 
                    const normalizedAngle = (this.angle + 2 * Math.PI) % (2 * Math.PI); 

                    if (normalizedAngle >= Math.PI * 0.25 && normalizedAngle < Math.PI * 0.75) { 
                        frameDirection = playerFrames.down;
                    } else if (normalizedAngle >= Math.PI * 0.75 && normalizedAngle < Math.PI * 1.25) { 
                        frameDirection = playerFrames.left;
                    } else if (normalizedAngle >= Math.PI * 1.25 && normalizedAngle < Math.PI * 1.75) { 
                        frameDirection = playerFrames.up;
                    } else { 
                        frameDirection = playerFrames.right;
                    }
                    
                    const frameToDraw = this.isMoving ? this.currentAnimFrame : 0;
                    const sX = (frameDirection.x + frameToDraw) * PLAYER_SPRITE_FRAME_WIDTH;
                    const sY = frameDirection.y * PLAYER_SPRITE_FRAME_HEIGHT;
                    const dWidth = PLAYER_SPRITE_FRAME_WIDTH * PLAYER_SPRITE_SCALE;
                    const dHeight = PLAYER_SPRITE_FRAME_HEIGHT * PLAYER_SPRITE_SCALE;

                    ctx.drawImage(
                        playerSpriteImage, 
                        sX, 
                        sY, 
                        PLAYER_SPRITE_FRAME_WIDTH, 
                        PLAYER_SPRITE_FRAME_HEIGHT, 
                        -dWidth / 2, 
                        this.radius - dHeight, // Adjusted Y offset
                        dWidth, 
                        dHeight
                    );
                    ctx.restore();
                } else { 
                    ctx.save(); ctx.translate(this.x, this.y); 
                    ctx.fillStyle = this.canPhase ? 'rgba(0, 123, 255, 0.5)' : '#007bff'; 
                    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill(); 
                    ctx.fillStyle = '#555'; ctx.fillRect(this.radius * 0.8, -this.radius / 5, this.radius, this.radius / 2.5); 
                    ctx.restore(); 
                }
            }
            update() { 
                let moveX = 0; 
                let moveY = 0;

                if (keys.w || keys.ArrowUp) moveY -= this.speed;
                if (keys.s || keys.ArrowDown) moveY += this.speed;
                if (keys.a || keys.ArrowLeft) moveX -= this.speed;
                if (keys.d || keys.ArrowRight) moveX += this.speed;

                this.isMoving = (moveX !== 0 || moveY !== 0);

                if (this.isMoving) { 
                    this.animTimer++;
                    if (this.animTimer >= this.animSpeed) {
                        this.currentAnimFrame = (this.currentAnimFrame + 1) % 3; 
                        this.animTimer = 0;
                    }
                } else {
                    this.currentAnimFrame = 0; 
                    this.animTimer = 0;
                }

                // Player angle always points to mouse
                const worldMouseX = mouse.x + camera.x;
                const worldMouseY = mouse.y + camera.y;
                this.angle = Math.atan2(worldMouseY - this.y, worldMouseX - this.x); 


                if (moveX !== 0 && moveY !== 0) {
                    const factor = Math.sqrt(0.5); 
                    moveX *= factor; moveY *= factor;
                }
                
                const newX = this.x + moveX;
                const newY = this.y + moveY; 

                const currentTileX = Math.floor(this.x / TILE_SIZE);
                const currentTileY = Math.floor(this.y / TILE_SIZE);
                
                let collisionX = false;
                let collisionY = false;

                const checkRadius = this.radius * 0.9; 

                if (moveX !== 0) {
                    const nextTileCenterX = Math.floor((this.x + moveX + Math.sign(moveX) * checkRadius) / TILE_SIZE);
                    if (this.checkTileInteraction(nextTileCenterX, Math.floor((this.y - checkRadius) / TILE_SIZE)) ||
                        this.checkTileInteraction(nextTileCenterX, Math.floor((this.y + checkRadius) / TILE_SIZE)) ||
                        this.checkTileInteraction(nextTileCenterX, currentTileY) 
                       ) {
                        collisionX = true;
                    }
                }
                if (moveY !== 0) {
                    const nextTileCenterY = Math.floor((this.y + moveY + Math.sign(moveY) * checkRadius) / TILE_SIZE);
                     if (this.checkTileInteraction(Math.floor((this.x - checkRadius) / TILE_SIZE), nextTileCenterY) ||
                         this.checkTileInteraction(Math.floor((this.x + checkRadius) / TILE_SIZE), nextTileCenterY) ||
                         this.checkTileInteraction(currentTileX, nextTileCenterY) 
                        ) {
                        collisionY = true;
                    }
                }
                
                if (!collisionX) this.x += moveX;
                if (!collisionY) this.y += moveY;
                                
                const weapon = this.getCurrentWeapon();
                if (this.shootCooldown > 0) this.shootCooldown--; 
                
                if (mouse.down && this.shootCooldown === 0) { 
                    if (weapon.singleShot) {
                        if (!this.justFiredPistolOnThisClick) {
                            this.shoot();
                            this.justFiredPistolOnThisClick = true;
                        }
                    } else {
                        this.shoot();
                    }
                } 
                if (!mouse.down) { 
                    this.justFiredPistolOnThisClick = false;
                }

                if (this.health <= 0) { gameOver = true; showGameOverScreen(); } 
            }

            checkTileInteraction(tileX, tileY) {
                if (this.canPhase) return false; 

                if (tileX < 0 || tileX >= MAP_COLS || tileY < 0 || tileY >= MAP_ROWS) return true; 
                const tileType = gameMap[tileY][tileX];

                switch (tileType) {
                    case TILE_WALL: return true; 
                    case TILE_DOOR_RED:
                        if (this.keysCollected.red) { 
                            gameMap[tileY][tileX] = TILE_EMPTY; 
                            playDoorOpenSound(); 
                            updateKeyUI(); 
                            updateVisibility(Math.floor(this.x / TILE_SIZE), Math.floor(this.y / TILE_SIZE), gameMap); 
                            return false; 
                        } 
                        return true; 
                    case TILE_DOOR_YELLOW:
                        if (this.keysCollected.yellow) { 
                            gameMap[tileY][tileX] = TILE_EMPTY; 
                            playDoorOpenSound(); 
                            updateKeyUI(); 
                            updateVisibility(Math.floor(this.x / TILE_SIZE), Math.floor(this.y / TILE_SIZE), gameMap);
                            return false; 
                        }
                        return true;
                    case TILE_DOOR_BLUE:
                        if (this.keysCollected.blue) { 
                            gameMap[tileY][tileX] = TILE_EMPTY; 
                            playDoorOpenSound(); 
                            updateKeyUI(); 
                            updateVisibility(Math.floor(this.x / TILE_SIZE), Math.floor(this.y / TILE_SIZE), gameMap);
                            return false; 
                        }
                        return true;
                    case TILE_KEY_RED:
                        this.keysCollected.red = true; gameMap[tileY][tileX] = TILE_EMPTY; playKeyPickupSound(); updateKeyUI(); score += 50; scoreDisplay.textContent = score; return false; 
                    case TILE_KEY_YELLOW:
                        this.keysCollected.yellow = true; gameMap[tileY][tileX] = TILE_EMPTY; playKeyPickupSound(); updateKeyUI(); score += 50; scoreDisplay.textContent = score; return false;
                    case TILE_KEY_BLUE:
                        this.keysCollected.blue = true; gameMap[tileY][tileX] = TILE_EMPTY; playKeyPickupSound(); updateKeyUI(); score += 50; scoreDisplay.textContent = score; return false;
                    case TILE_EXIT: levelComplete(); return false; 
                    case TILE_WEAPON_SHOTGUN:
                        this.addWeapon({ name: "Shotgun", damage: 15 + currentLevel, fireRate: 25, bulletSpeed: 8, spread: 0.3, numPellets: 6, color: '#FFA500', singleShot: false, ammo: 10, maxAmmo: 30, pickupAmmo: 10 });
                        gameMap[tileY][tileX] = TILE_EMPTY; return false;
                    case TILE_WEAPON_MACHINEGUN:
                        this.addWeapon({ name: "Machine Gun", damage: 8 + currentLevel * 0.5, fireRate: 4, bulletSpeed: 12, spread: 0.1, numPellets: 1, color: '#ADD8E6', singleShot: false, ammo: 50, maxAmmo: 150, pickupAmmo: 50 });
                        gameMap[tileY][tileX] = TILE_EMPTY; return false;
                    case TILE_EMPTY: default: return false; 
                }
            }
            shoot() { 
                const weapon = this.getCurrentWeapon();
                if (weapon.ammo !== Infinity && weapon.ammo <= 0) {
                    playEmptyGunSound();
                    this.shootCooldown = weapon.fireRate; 
                    if (this.currentWeaponIndex !== 0) { 
                        this.switchWeapon(0); 
                        if (mouse.down && this.getCurrentWeapon().singleShot && !this.justFiredPistolOnThisClick) {
                             this.shoot(); 
                             this.justFiredPistolOnThisClick = true;
                        } else if (mouse.down && !this.getCurrentWeapon().singleShot) {
                            this.shoot(); 
                        }
                    }
                    return;
                }

                playShootSound(weapon.name); 
                this.shootCooldown = weapon.fireRate;
                if (weapon.ammo !== Infinity) {
                    weapon.ammo--;
                }
                updateWeaponUI();
                
                const worldMouseX = mouse.x + camera.x;
                const worldMouseY = mouse.y + camera.y;
                const bulletAngle = Math.atan2(worldMouseY - this.y, worldMouseX - this.x);


                for (let i = 0; i < weapon.numPellets; i++) {
                    let currentBulletAngle = bulletAngle; 
                    if (weapon.spread > 0) {
                        currentBulletAngle += (Math.random() - 0.5) * weapon.spread;
                    }
                    const bX = this.x + Math.cos(currentBulletAngle)*(this.radius+5); 
                    const bY = this.y + Math.sin(currentBulletAngle)*(this.radius+5); 
                    bullets.push(new Bullet(bX, bY, currentBulletAngle, weapon.bulletSpeed, 'player', weapon.damage, weapon.color)); 
                }
            }
            takeDamage(amount) { 
                if (this.canPhase) return; 
                this.health -= amount; playPlayerHitSound(); if (this.health < 0) this.health = 0; healthDisplay.textContent = this.health; 
            }
            gainHealth(amount) { 
                this.health += amount; if (this.health > this.maxHealth) this.health = this.maxHealth; healthDisplay.textContent = this.health; playHealthPickupSound();
            }
            collectAllKeys() {
                this.keysCollected.red = true;
                this.keysCollected.yellow = true;
                this.keysCollected.blue = true;
                updateKeyUI();
                console.log("CHEAT: All keys collected!");
                if (player) {
                    updateVisibility(Math.floor(player.x / TILE_SIZE), Math.floor(player.y / TILE_SIZE), gameMap);
                }
            }
            collectAllGuns() {
                this.addWeapon({ name: "Shotgun", damage: 15 + currentLevel, fireRate: 25, bulletSpeed: 8, spread: 0.3, numPellets: 6, color: '#FFA500', singleShot: false, ammo: 30, maxAmmo: 30, pickupAmmo: 10 });
                this.addWeapon({ name: "Machine Gun", damage: 8 + currentLevel * 0.5, fireRate: 4, bulletSpeed: 12, spread: 0.1, numPellets: 1, color: '#ADD8E6', singleShot: false, ammo: 150, maxAmmo: 150, pickupAmmo: 50 });
                updateWeaponUI();
                console.log("CHEAT: All guns collected!");
            }
        }

        // Bullet Class
        class Bullet {
            constructor(x,y,angle,speed,owner, damage, color = '#ffeb3b') { 
                this.x=x; this.y=y; 
                this.radius= (owner === 'player') ? 4 : 5; 
                this.dx=Math.cos(angle)*speed; 
                this.dy=Math.sin(angle)*speed; 
                this.owner=owner; 
                this.life=120; 
                this.damage = damage;
                this.color = (owner === 'enemy') ? '#ff6600' : color; 
            }
            draw() { 
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); 
            }
            update() { 
                this.x+=this.dx; this.y+=this.dy; 
                this.life--; 
                const tileX=Math.floor(this.x/TILE_SIZE);
                const tileY=Math.floor(this.y/TILE_SIZE); 
                if(tileX<0||tileX>=MAP_COLS||tileY<0||tileY>=MAP_ROWS || 
                   (gameMap[tileY] && (gameMap[tileY][tileX]===TILE_WALL || 
                                   gameMap[tileY][tileX]===TILE_DOOR_RED || 
                                   gameMap[tileY][tileX]===TILE_DOOR_YELLOW || 
                                   gameMap[tileY][tileX]===TILE_DOOR_BLUE ))
                  ) {
                    this.life=0; 
                }
            }
        }
        
        // Enemy Class
        class Enemy {
            constructor(x, y, type = 'grunt') { 
                this.x = x; this.y = y;
                this.enemyType = type;
                this.hitTimer = 0;
                this.state = 'wandering';
                this.wanderTargetX = this.x; this.wanderTargetY = this.y;
                this.wanderTimer = 0; this.maxWanderTime = 120 + Math.floor(Math.random() * 60);
                this.detectionRadius = TILE_SIZE * 6; 

                switch (type) {
                    case 'rusher':
                        this.radius = TILE_SIZE / 2.8;
                        this.speed = (selectedDifficulty === 'easy' ? 1.0 : 1.5) + Math.random() * 0.5 + (currentLevel * 0.1); 
                        this.chaseSpeed = (selectedDifficulty === 'easy' ? 1.5 : 2.0) + Math.random() * 0.6 + (currentLevel * 0.15); 
                        this.health = 30 + currentLevel * 8;
                        this.damage = 15 + currentLevel * 3; 
                        this.color = 'magenta';
                        this.canShoot = false;
                        this.scoreValue = 120;
                        break;
                    case 'shooter':
                        this.radius = TILE_SIZE / 2.5;
                        this.speed = (0.7 + Math.random() * 0.3) + (currentLevel * 0.05);
                        this.chaseSpeed = (0.9 + Math.random() * 0.4) + (currentLevel * 0.08);
                        this.health = 40 + currentLevel * 10;
                        this.damage = 8 + currentLevel * 2;
                        this.color = `hsl(${220 + Math.random()*40}, 70%, 60%)`; 
                        this.canShoot = true;
                        this.shootCooldown = 0; this.maxShootCooldown = 80 + Math.random() * 40;
                        this.bulletSpeed = 6; this.bulletDamage = 7 + currentLevel * 1.5;
                        this.detectionRadius = TILE_SIZE * 7; 
                        this.scoreValue = 150;
                        break;
                    case 'tank':
                        this.radius = TILE_SIZE / 2; 
                        this.speed = (0.4 + Math.random() * 0.2) + (currentLevel * 0.03);
                        this.chaseSpeed = (0.6 + Math.random() * 0.3) + (currentLevel * 0.05);
                        this.health = 150 + currentLevel * 25; 
                        this.damage = 20 + currentLevel * 4; 
                        this.color = '#444444'; 
                        this.canShoot = false; 
                        this.detectionRadius = TILE_SIZE * 4.5; 
                        this.scoreValue = 250;
                        break;
                    case 'teleporter': 
                        this.radius = TILE_SIZE / 2.6;
                        this.speed = 1.2 + Math.random() * 0.3 + (currentLevel * 0.06);
                        this.chaseSpeed = 1.5 + Math.random() * 0.4 + (currentLevel * 0.08);
                        this.health = 60 + currentLevel * 12;
                        this.damage = 12 + currentLevel * 2.5; 
                        this.color = 'cyan';
                        this.canShoot = true; 
                        this.shootCooldown = 0; this.maxShootCooldown = 90 + Math.random() * 30;
                        this.bulletSpeed = 7; this.bulletDamage = 8 + currentLevel * 1.8;
                        this.teleportCooldown = 0; this.maxTeleportCooldown = 180 + Math.floor(Math.random() * 120);
                        this.scoreValue = 180;
                        break;
                    case 'splitter': 
                        this.radius = TILE_SIZE / 2.2;
                        this.speed = 0.6 + Math.random() * 0.2 + (currentLevel * 0.04);
                        this.chaseSpeed = 0.8 + Math.random() * 0.3 + (currentLevel * 0.06);
                        this.health = 100 + currentLevel * 20;
                        this.damage = 18 + currentLevel * 3.5;
                        this.color = 'darkorange';
                        this.canShoot = false; 
                        this.scoreValue = 200;
                        break;
                     case 'mini_splitter': 
                        this.radius = TILE_SIZE / 3.5;
                        this.speed = 1.5 + Math.random() * 0.5 + (currentLevel * 0.1);
                        this.chaseSpeed = 1.8 + Math.random() * 0.5 + (currentLevel * 0.12);
                        this.health = 25 + currentLevel * 5;
                        this.damage = 5 + currentLevel * 1;
                        this.color = 'sandybrown';
                        this.canShoot = false;
                        this.scoreValue = 50;
                        break;
                    case 'grunt':
                    default:
                        this.radius = TILE_SIZE / 2.5;
                        this.speed = (0.8 + Math.random() * 0.4) + (currentLevel * 0.05);
                        this.chaseSpeed = (1 + Math.random() * 0.5) + (currentLevel * 0.1);
                        this.health = 50 + currentLevel * 10;
                        this.damage = 10 + currentLevel * 2;
                        this.color = `hsl(${Math.random() * 60}, 70%, 50%)`; 
                        this.canShoot = Math.random() < 0.15; 
                        this.shootCooldown = 0; this.maxShootCooldown = 100 + Math.random() * 50;
                        this.bulletSpeed = 5; this.bulletDamage = 5 + currentLevel;
                        this.scoreValue = 100;
                        break;
                }
                this.maxHealth = this.health;
            }

            draw() {
                if (player && visibilityMap) { 
                    const enemyTileX = Math.floor(this.x / TILE_SIZE);
                    const enemyTileY = Math.floor(this.y / TILE_SIZE);

                    if (enemyTileY < 0 || enemyTileY >= MAP_ROWS || enemyTileX < 0 || enemyTileX >= MAP_COLS || !visibilityMap[enemyTileY][enemyTileX]) {
                        return; 
                    }
                }


                ctx.fillStyle = this.hitTimer > 0 ? 'white' : this.color;
                ctx.beginPath();
                if (this.enemyType === 'tank') {
                    ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
                } else if (this.enemyType === 'rusher' || this.enemyType === 'mini_splitter') {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    let angleToTarget = (this.state === 'wandering') ? Math.atan2(this.wanderTargetY - this.y, this.wanderTargetX - this.x) : Math.atan2(player.y - this.y, player.x - this.x);
                    ctx.rotate(angleToTarget + Math.PI / 2); 
                    ctx.beginPath();
                    ctx.moveTo(0, -this.radius);
                    ctx.lineTo(this.radius * 0.8, this.radius * 0.8);
                    ctx.lineTo(-this.radius * 0.8, this.radius * 0.8);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                } else { 
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }

                let targetX = player.x, targetY = player.y;
                if (this.state === 'wandering') { targetX = this.wanderTargetX; targetY = this.wanderTargetY; }
                const angleToTarget = Math.atan2(targetY - this.y, targetX - this.x);
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(this.x + Math.cos(angleToTarget) * this.radius * 0.5, this.y + Math.sin(angleToTarget) * this.radius * 0.5, this.radius * 0.2, 0, Math.PI * 2);
                ctx.fill();

                if (this.health < this.maxHealth) {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x - this.radius, this.y - this.radius - 10, this.radius * 2, 5);
                    ctx.fillStyle = 'green';
                    ctx.fillRect(this.x - this.radius, this.y - this.radius - 10, (this.radius * 2) * (this.health / this.maxHealth), 5);
                }
            }
            update(){
                if(this.hitTimer>0) this.hitTimer--; if(!player) return; 
                const dTP = Math.hypot(this.x - player.x, this.y - player.y);
                
                if (this.enemyType === 'teleporter') {
                    this.teleportCooldown--;
                    if (this.teleportCooldown <= 0 && dTP < this.detectionRadius * 2) { 
                        this.teleport();
                        this.teleportCooldown = this.maxTeleportCooldown;
                        if (this.canShoot && this.shootCooldown === 0) {
                            this.shoot();
                            this.shootCooldown = this.maxShootCooldown;
                        }
                    }
                }
                
                if (this.canShoot && dTP < this.detectionRadius * (this.enemyType === 'shooter' || this.enemyType === 'teleporter' ? 1.5 : 1.2) && dTP > TILE_SIZE * 1.5) {
                     this.state = 'shooting';
                } else if (dTP < this.detectionRadius) {
                    this.state = 'chasing';
                } else { 
                    if (this.state === 'chasing' || this.state === 'shooting') this.setNewWanderTarget(); 
                    this.state = 'wandering';
                }
                
                if (this.shootCooldown > 0) this.shootCooldown--;

                let tX, tY, cS; 
                if (this.state === 'shooting') { 
                    tX=player.x; tY=player.y; cS=this.speed*0.5; 
                    if(this.shootCooldown===0 && this.canShoot){this.shoot();this.shootCooldown=this.maxShootCooldown;} 
                } else if (this.state === 'chasing') { 
                    tX=player.x; tY=player.y; cS=this.chaseSpeed; 
                } else { 
                    this.wanderTimer--; 
                    if (this.wanderTimer <= 0 || Math.hypot(this.x-this.wanderTargetX,this.y-this.wanderTargetY)<TILE_SIZE/2) this.setNewWanderTarget(); 
                    tX=this.wanderTargetX;tY=this.wanderTargetY;cS=this.speed;
                }
                const aTT=Math.atan2(tY-this.y,tX-this.x),mX=Math.cos(aTT)*cS,mY=Math.sin(aTT)*cS,nX=this.x+mX,nY=this.y+mY;
                if (!this.checkWallCollision(nX,this.y))this.x=nX; if(!this.checkWallCollision(this.x,nY))this.y=nY;
                if (dTP < this.radius+player.radius) { player.takeDamage(this.damage); this.x-=Math.cos(aTT)*TILE_SIZE*0.5; this.y-=Math.sin(aTT)*TILE_SIZE*0.5; if(this.state==='wandering')this.state='chasing';}
            }
            teleport() {
                playTeleportSound();
                let newX, newY, validSpot = false;
                let attempts = 0;
                const teleportRadius = TILE_SIZE * 5;
                while (!validSpot && attempts < 20) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = TILE_SIZE * 2 + Math.random() * teleportRadius;
                    newX = player.x + Math.cos(angle) * distance;
                    newY = player.y + Math.sin(angle) * distance;

                    newX = Math.max(this.radius, Math.min(newX, MAP_COLS * TILE_SIZE - this.radius));
                    newY = Math.max(this.radius, Math.min(newY, MAP_ROWS * TILE_SIZE - this.radius));
                    
                    const tileX = Math.floor(newX / TILE_SIZE);
                    const tileY = Math.floor(newY / TILE_SIZE);

                    if (tileX >= 0 && tileX < MAP_COLS && tileY >= 0 && tileY < MAP_ROWS && gameMap[tileY][tileX] === TILE_EMPTY) {
                        let tooCloseToOtherEnemy = false;
                        for(const otherEnemy of enemies){
                            if(otherEnemy !== this && Math.hypot(newX - otherEnemy.x, newY - otherEnemy.y) < (this.radius + otherEnemy.radius) * 1.5){
                                tooCloseToOtherEnemy = true;
                                break;
                            }
                        }
                        if(!tooCloseToOtherEnemy) validSpot = true;
                    }
                    attempts++;
                }
                if (validSpot) {
                    this.x = newX;
                    this.y = newY;
                }
            }
            shoot() {
                if (!player || !this.canShoot) return; 
                playEnemyShootSound(); 
                const aTP = Math.atan2(player.y-this.y,player.x-this.x);
                const inaccuracy = (Math.random()-0.5) * (this.enemyType === 'shooter' || this.enemyType === 'teleporter' ? 0.15 : 0.25); 
                const bA=aTP+inaccuracy;
                const bX=this.x+Math.cos(bA)*(this.radius+5),bY=this.y+Math.sin(bA)*(this.radius+5);
                bullets.push(new Bullet(bX,bY,bA,this.bulletSpeed,'enemy',this.bulletDamage));
            }
            setNewWanderTarget() {
                let nTF=false,att=0;const MAX_A=10;
                while(!nTF&&att<MAX_A){
                    const wA=Math.random()*Math.PI*2,wD=TILE_SIZE*(Math.random()*3+2);
                    let tTX=this.x+Math.cos(wA)*wD,tTY=this.y+Math.sin(wA)*wD;
                    tTX=Math.max(TILE_SIZE*1.5,Math.min(tTX,(MAP_COLS*TILE_SIZE)-TILE_SIZE*1.5));
                    tTY=Math.max(TILE_SIZE*1.5,Math.min(tTY,(MAP_ROWS*TILE_SIZE)-TILE_SIZE*1.5));
                    const tX=Math.floor(tTX/TILE_SIZE),tY=Math.floor(tTY/TILE_SIZE);
                    if(tX>0&&tX<MAP_COLS-1&&tY>0&&tY<MAP_ROWS-1&&gameMap[tY][tX]===TILE_EMPTY){this.wanderTargetX=tTX;this.wanderTargetY=tTY;nTF=true;}
                    att++;
                }
                if(!nTF){this.wanderTargetX=Math.floor(this.x/TILE_SIZE)*TILE_SIZE+TILE_SIZE/2;this.wanderTargetY=Math.floor(this.y/TILE_SIZE)*TILE_SIZE+TILE_SIZE/2;}
                this.wanderTimer=this.maxWanderTime;
            }
            checkWallCollision(cX,cY){ 
                const co=[{x:Math.floor((cX-this.radius)/TILE_SIZE),y:Math.floor((cY-this.radius)/TILE_SIZE)},{x:Math.floor((cX+this.radius)/TILE_SIZE),y:Math.floor((cY-this.radius)/TILE_SIZE)},{x:Math.floor((cX-this.radius)/TILE_SIZE),y:Math.floor((cY+this.radius)/TILE_SIZE)},{x:Math.floor((cX+this.radius)/TILE_SIZE),y:Math.floor((cY+this.radius)/TILE_SIZE)}]; 
                for(const t of co) {
                    if(t.x<0||t.x>=MAP_COLS||t.y<0||t.y>=MAP_ROWS||
                       gameMap[t.y][t.x] === TILE_WALL ||
                       gameMap[t.y][t.x] === TILE_DOOR_RED ||
                       gameMap[t.y][t.x] === TILE_DOOR_YELLOW ||
                       gameMap[t.y][t.x] === TILE_DOOR_BLUE
                    ) return true; 
                }
                return false;
            }
            takeDamage(amount){ 
                this.health-=amount; this.hitTimer=5; playHitSound(); this.state = 'chasing'; 
                if(this.health<=0){ 
                    score+= this.scoreValue; 
                    scoreDisplay.textContent=score; 
                    enemiesRemaining--; 
                    playEnemyDestroySound(); 
                    if(Math.random()<0.3) healthPacks.push(new HealthPack(this.x,this.y));
                    
                    if (this.enemyType === 'splitter') {
                        spawnMiniSplitters(this.x, this.y);
                    }
                    return true; 
                } else {
                    return false; 
                }
            }
        }
        
        function spawnMiniSplitters(x, y) {
            playSplitSound();
            for (let i = 0; i < 2; i++) {
                let sX, sY, validSpawn = false;
                let attempts = 0;
                while(!validSpawn && attempts < 10) {
                    sX = x + (Math.random() - 0.5) * TILE_SIZE;
                    sY = y + (Math.random() - 0.5) * TILE_SIZE;
                    const tileX = Math.floor(sX / TILE_SIZE);
                    const tileY = Math.floor(sY / TILE_SIZE);
                    if (tileX >= 0 && tileX < MAP_COLS && tileY >= 0 && tileY < MAP_ROWS && gameMap[tileY][tileX] === TILE_EMPTY) {
                        validSpawn = true;
                    }
                    attempts++;
                }
                if (!validSpawn) { // Fallback if no good spot found nearby
                    sX = x; sY = y;
                }

                enemies.push(new Enemy(sX, sY, 'mini_splitter'));
                enemiesRemaining++; 
            }
        }

        // Game Initialization and State Management
        function initGame() {
            isLevelCompleting = false; 
            console.log(`Initializing game for level: ${currentLevel} with difficulty: ${selectedDifficulty}`);
            gameOver = false; gameRunning = true; 
            
            const mapData = generateMaze(MAP_COLS, MAP_ROWS); 
            gameMap = mapData.gameMap;
            let playerSpawnX = mapData.playerStart.c * TILE_SIZE + TILE_SIZE/2;
            let playerSpawnY = mapData.playerStart.r * TILE_SIZE + TILE_SIZE/2;

            player = new Player(playerSpawnX, playerSpawnY); 
            player.health = 100; healthDisplay.textContent = player.health;
            player.keysCollected = { red: false, yellow: false, blue: false }; 
            updateKeyUI();
            updateWeaponUI(); 
            updateVisibility(Math.floor(player.x / TILE_SIZE), Math.floor(player.y / TILE_SIZE), gameMap); // Initial visibility calc
            
            bullets = []; enemies = []; healthPacks = []; 
            
            camera.update(player); 
            scoreDisplay.textContent = score; 
            waveDisplay.textContent = currentLevel; 
            
            resetLevelParameters(); 
            spawnInitialEnemies(); // Spawn all enemies at the start
            
            if (gameLoopId) cancelAnimationFrame(gameLoopId); 
            messageOverlay.style.display = 'none'; 
            difficultySelectionDiv.style.display = 'none'; 
            gameLoop();
        }

        function resetLevelParameters() { 
            switch(selectedDifficulty) {
                case 'easy':
                    enemiesToSpawnPerLevel = Math.floor((6 + (currentLevel - 1) * 2) * 1.5); 
                    break;
                case 'hard':
                    enemiesToSpawnPerLevel = Math.floor((12 + (currentLevel - 1) * 4) * 1.5); 
                    break;
                case 'medium':
                default:
                    enemiesToSpawnPerLevel = Math.floor((10 + (currentLevel - 1) * 3) * 1.5); 
                    break;
            }
            enemiesSpawnedThisLevel = 0; 
            enemiesRemaining = 0; 
        }
        function spawnInitialEnemies() { 
            let validSpawnLocations = [];
            if (player && gameMap) {
                for (let r = 0; r < MAP_ROWS; r++) {
                    for (let c = 0; c < MAP_COLS; c++) {
                        if (gameMap[r][c] === TILE_EMPTY) {
                            const spawnX = c * TILE_SIZE + TILE_SIZE / 2;
                            const spawnY = r * TILE_SIZE + TILE_SIZE / 2;
                            if (Math.hypot(spawnX - player.x, spawnY - player.y) > VIEWPORT_WIDTH / 3) { 
                                validSpawnLocations.push({ x: spawnX, y: spawnY });
                            }
                        }
                    }
                }
            }

            for(let i=0; i < enemiesToSpawnPerLevel; i++) { 
                spawnEnemy(validSpawnLocations); 
            }
        }
        

        function spawnEnemy(validSpawnLocations) {
            if (!player) return; 
            
            let sX, sY, vS = false;

            if (validSpawnLocations && validSpawnLocations.length > 0) {
                const spawnIndex = Math.floor(Math.random() * validSpawnLocations.length);
                const spawnPoint = validSpawnLocations.splice(spawnIndex, 1)[0]; 
                sX = spawnPoint.x;
                sY = spawnPoint.y;
                vS = true;
            } else {
                let att = 0; const MAX_A = 20; 
                while(!vS && att < MAX_A){
                    const randR = Math.floor(Math.random() * MAP_ROWS);
                    const randC = Math.floor(Math.random() * MAP_COLS);
                    if (gameMap[randR][randC] === TILE_EMPTY) {
                        sX = randC * TILE_SIZE + TILE_SIZE / 2;
                        sY = randR * TILE_SIZE + TILE_SIZE / 2;
                        if(Math.hypot(sX-player.x,sY-player.y)>VIEWPORT_WIDTH/3) vS=true;
                    }
                    att++;
                }
            }
            
            if(vS){
                let enemyType = 'grunt';
                const rand = Math.random();
                if (currentLevel > 1 && rand < 0.15) enemyType = 'rusher'; 
                else if (currentLevel > 2 && rand < 0.30) enemyType = 'shooter'; 
                else if (currentLevel > 3 && rand < 0.45 && selectedDifficulty !== 'easy') enemyType = 'tank'; 
                else if (currentLevel > 2 && rand < 0.60) enemyType = 'teleporter'; 
                else if (currentLevel > 3 && rand < 0.75 && selectedDifficulty !== 'easy') enemyType = 'splitter'; 
                
                enemies.push(new Enemy(sX,sY, enemyType));
                enemiesSpawnedThisLevel++; 
                enemiesRemaining++;
            }
            else console.warn(`Could not find valid spawn point after several attempts.`);
        }
        
        function levelComplete() { 
            if (isLevelCompleting) return; 
            isLevelCompleting = true;

            gameRunning = false;
            if(gameLoopId) cancelAnimationFrame(gameLoopId);
            messageTitle.textContent = "Level Cleared!";
            messageText.innerHTML = `Level ${currentLevel} complete! Score: ${score} <br> Click 'Next Level' to continue.`;
            messageOverlay.style.display = 'flex';
            restartButton.textContent = "Next Level";
            difficultySelectionDiv.style.display = 'none'; 
            currentLevel++; 
        }
        
        function gameLoop(){ 
            if(!gameRunning || gameOver) return;
            update(); draw(); gameLoopId=requestAnimationFrame(gameLoop);
        }
        function update(){
            if(!player) return; 
            const prevPlayerTileX = Math.floor(player.x / TILE_SIZE);
            const prevPlayerTileY = Math.floor(player.y / TILE_SIZE);

            player.update(); 
            camera.update(player); 

            const newPlayerTileX = Math.floor(player.x / TILE_SIZE);
            const newPlayerTileY = Math.floor(player.y / TILE_SIZE);

            if (newPlayerTileX !== prevPlayerTileX || newPlayerTileY !== prevPlayerTileY) {
                updateVisibility(newPlayerTileX, newPlayerTileY, gameMap);
            }
            
            bullets = bullets.filter(b => b.life > 0); bullets.forEach(b => b.update());      
            healthPacks.forEach((p, i) => { if(player && Math.hypot(player.x-p.x,player.y-p.y)<player.radius+p.radius){player.gainHealth(p.healthValue);healthPacks.splice(i,1);}});
            let cE=[...enemies];enemies=[]; 
            cE.forEach(e => { e.update(); let eSF=true; 
                bullets=bullets.filter(b=>{if(b.owner==='player'&&Math.hypot(b.x-e.x,b.y-e.y)<b.radius+e.radius){if(e.takeDamage(b.damage))eSF=false;return false;}return true;});
                bullets.forEach((b,bi)=>{if(b.owner==='enemy'&&player&&Math.hypot(b.x-player.x,b.y-player.y)<b.radius+player.radius){player.takeDamage(b.damage);bullets.splice(bi,1);}});
                if(eSF)enemies.push(e); 
            });
            // handleEnemySpawning(); // Removed call
        }

        function draw(){
            ctx.fillStyle='#333'; ctx.fillRect(0,0,VIEWPORT_WIDTH,VIEWPORT_HEIGHT);
            ctx.save(); ctx.translate(-camera.x, -camera.y);
            const sC=Math.floor(camera.x/TILE_SIZE),eC=Math.min(sC+Math.ceil(camera.width/TILE_SIZE)+1,MAP_COLS);
            const sR=Math.floor(camera.y/TILE_SIZE),eR=Math.min(sR+Math.ceil(camera.height/TILE_SIZE)+1,MAP_ROWS);

            for(let r=sR;r<eR;r++){
                for(let c=sC;c<eC;c++){
                    if(!gameMap[r] || gameMap[r][c] === undefined || !visibilityMap || !visibilityMap[r] || visibilityMap[r][c] === undefined) {
                        ctx.fillStyle = '#202020'; 
                        ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        continue; 
                    }
                    
                    const tileIsVisible = visibilityMap[r][c];
                    const tileType = gameMap[r][c];
                    let tileColor = null;

                    if (tileIsVisible) {
                        currentWallStyle = wallStyles[(currentLevel -1) % wallStyles.length];
                        switch(tileType) {
                            case TILE_WALL: 
                                tileColor = currentWallStyle.fillColor; 
                                break;
                            case TILE_DOOR_RED: tileColor = 'darkred'; break;
                            case TILE_DOOR_YELLOW: tileColor = 'goldenrod'; break;
                            case TILE_DOOR_BLUE: tileColor = 'darkblue'; break;
                            case TILE_KEY_RED: tileColor = 'red'; break;
                            case TILE_KEY_YELLOW: tileColor = 'yellow'; break;
                            case TILE_KEY_BLUE: tileColor = 'blue'; break;
                            case TILE_EXIT: tileColor = 'purple'; break;
                            case TILE_WEAPON_SHOTGUN: tileColor = '#FFA500'; break; 
                            case TILE_WEAPON_MACHINEGUN: tileColor = '#ADD8E6'; break; 
                            case TILE_EMPTY: tileColor = null; break; 
                        }
                        if(tileColor) {
                            ctx.fillStyle = tileColor; 
                            ctx.fillRect(c*TILE_SIZE, r*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            if (tileType === TILE_WALL) {
                               ctx.strokeStyle = currentWallStyle.borderColor; 
                               ctx.strokeRect(c*TILE_SIZE, r*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                               if (currentWallStyle.pattern) {
                                   currentWallStyle.pattern(c*TILE_SIZE, r*TILE_SIZE, TILE_SIZE, ctx);
                               }
                            } else if (tileType >= TILE_DOOR_RED && tileType <= TILE_DOOR_BLUE) {
                               ctx.strokeStyle = '#444'; ctx.strokeRect(c*TILE_SIZE, r*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            }
                            
                            let itemText = null;
                            let itemTextColor = 'white';
                            if (tileType >= TILE_KEY_RED && tileType <= TILE_KEY_BLUE) itemText = "K";
                            else if (tileType === TILE_EXIT) itemText = "E";
                            else if (tileType === TILE_WEAPON_SHOTGUN) {itemText = "SG"; itemTextColor = 'black';}
                            else if (tileType === TILE_WEAPON_MACHINEGUN) {itemText = "MG"; itemTextColor = 'black';}

                            if(itemText) {
                                ctx.fillStyle = itemTextColor; ctx.font = `${TILE_SIZE*0.7}px "Press Start 2P"`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                                ctx.fillText(itemText, c*TILE_SIZE + TILE_SIZE/2, r*TILE_SIZE + TILE_SIZE/2 + 2); 
                            }
                        } else if (tileType === TILE_EMPTY) {
                            // Optionally draw a floor tile for visible empty spaces
                            // ctx.fillStyle = '#404040'; // Example floor color
                            // ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        }
                    } else { 
                        ctx.fillStyle = '#202020'; // Fog color
                        ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
            healthPacks.forEach(p => p.draw()); 
            if(player) player.draw();
            bullets.forEach(b => b.draw());
            enemies.forEach(e => e.draw());
            ctx.restore();
        }
        
        // Wall pattern drawing functions
        function drawMetalPattern(x, y, size, context) {
            context.fillStyle = 'rgba(200, 200, 200, 0.5)'; 
            const rivetSize = size / 10;
            const offset = size / 8;
            context.beginPath(); context.arc(x + offset, y + offset, rivetSize, 0, Math.PI * 2); context.fill();
            context.beginPath(); context.arc(x + size - offset, y + offset, rivetSize, 0, Math.PI * 2); context.fill();
            context.beginPath(); context.arc(x + offset, y + size - offset, rivetSize, 0, Math.PI * 2); context.fill();
            context.beginPath(); context.arc(x + size - offset, y + size - offset, rivetSize, 0, Math.PI * 2); context.fill();
        }

        function drawStonePattern(x, y, size, context) {
            context.strokeStyle = 'rgba(0, 0, 0, 0.2)'; 
            context.lineWidth = 1;
            for (let i = 0; i < 2; i++) { 
                context.beginPath();
                context.moveTo(x + Math.random() * size, y + Math.random() * size);
                context.lineTo(x + Math.random() * size, y + Math.random() * size);
                context.stroke();
            }
        }

        function updateKeyUI() {
            if(player && player.keysCollected) {
                redKeyIcon.classList.toggle('collected', player.keysCollected.red);
                yellowKeyIcon.classList.toggle('collected', player.keysCollected.yellow);
                blueKeyIcon.classList.toggle('collected', player.keysCollected.blue);
            }
        }
        function updateWeaponUI() { 
            if (player && weaponInventoryIcons) { 
                const currentWeapon = player.getCurrentWeapon();
                
                const invIcons = weaponInventoryIcons.querySelectorAll('.weapon-icon-display');
                invIcons.forEach(icon => {
                    const weaponName = icon.dataset.weaponName; 
                    const weaponInInventory = player.weapons.find(w => w.name === weaponName);
                    const ammoTextSpan = icon.querySelector('.ammo-text-display');

                    if (weaponInInventory) {
                        icon.classList.add('collected');
                        if (ammoTextSpan) {
                            if (weaponInInventory.ammo === Infinity) {
                                ammoTextSpan.textContent = "Inf";
                            } else {
                                ammoTextSpan.textContent = `${weaponInInventory.ammo}`; 
                            }
                        }
                        if (currentWeapon.name === weaponName) {
                            icon.classList.add('selected-weapon-icon');
                        } else {
                            icon.classList.remove('selected-weapon-icon');
                        }
                    } else {
                        icon.classList.remove('collected'); 
                        icon.classList.remove('selected-weapon-icon');
                        if (ammoTextSpan) ammoTextSpan.textContent = "--";
                    }
                });
            }
        }


        function showGameOverScreen() { 
            gameOver = true; gameRunning = false;
            messageTitle.textContent = "Game Over!";
            messageText.textContent = `You survived ${currentLevel -1} levels. Final Score: ${score}`;
            restartButton.textContent = "Restart Game";
            difficultySelectionDiv.style.display = 'flex'; 
            messageOverlay.style.display = 'flex'; 
            if (gameLoopId) cancelAnimationFrame(gameLoopId); 
        } 
        function showStartScreen() { 
            gameOver = false; gameRunning = false;
            messageTitle.textContent = "Top-Down Mayhem";
            messageText.innerHTML = `Get ready to fight! <br>Arrow Keys or WASD to Move. <br>1/2/3 to Switch Weapon. Mouse to Aim. Click to Shoot. <br>Find keys, open doors, reach the Exit!`;
            restartButton.textContent = "Start Game";
            difficultySelectionDiv.style.display = 'flex'; 
            messageOverlay.style.display = 'flex'; 
            controlsInfo.textContent = "Controls: Arrow Keys or WASD to Move, 1/2/3 to Switch Weapon, Mouse to Aim, Click to Shoot.";
        }

        // Difficulty Button Listeners
        difficultyButtons.forEach(button => {
            button.addEventListener('click', () => {
                difficultyButtons.forEach(btn => btn.classList.remove('selected'));
                button.classList.add('selected');
                selectedDifficulty = button.dataset.difficulty;
                console.log("Difficulty set to:", selectedDifficulty);
            });
        });


        window.addEventListener('keydown', (e) => {
            const keyName = e.key.toLowerCase(); 
            
            if (keys.hasOwnProperty(e.key)) { 
                keys[e.key] = true;
            } else if (keys.hasOwnProperty(keyName)) { 
                keys[keyName] = true;
            }

            // Handle Cheats (one-shot actions per press)
            if (gameRunning && player) {
                if (keyName === 'i' && !keys.i_cheat_processed) { 
                    keys.i_cheat_processed = true; 
                    player.canPhase = !player.canPhase;
                    console.log("CHEAT: Phasing toggled to:", player.canPhase);
                } else if (keyName === 'k' && !keys.k_cheat_processed) {
                    keys.k_cheat_processed = true;
                    player.collectAllKeys();
                } else if (keyName === 'g' && !keys.g_cheat_processed) {
                    keys.g_cheat_processed = true;
                    player.collectAllGuns();
                }
            }

            // Handle Weapon Switching (one-shot actions per press)
            if (gameRunning && player) {
                if (keyName === '1' && !keys.weapon_1_processed) {
                    player.switchWeapon(0); // Pistol is always at index 0
                    keys.weapon_1_processed = true;
                } else if (keyName === '2' && !keys.weapon_2_processed) {
                    const shotgunIndex = player.weapons.findIndex(w => w.name === "Shotgun");
                    if (shotgunIndex !== -1) player.switchWeapon(shotgunIndex);
                    keys.weapon_2_processed = true;
                } else if (keyName === '3' && !keys.weapon_3_processed) {
                    const machineGunIndex = player.weapons.findIndex(w => w.name === "Machine Gun");
                    if (machineGunIndex !== -1) player.switchWeapon(machineGunIndex);
                    keys.weapon_3_processed = true;
                }
            }
        });
        window.addEventListener('keyup', (e) => {
            const keyName = e.key.toLowerCase();

            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
            } else if (keys.hasOwnProperty(keyName)) {
                keys[keyName] = false;
            }

            // Reset cheat processed flags on keyup
            if (keyName === 'i') {
                keys.i_cheat_processed = false;
            } else if (keyName === 'k') {
                keys.k_cheat_processed = false;
            } else if (keyName === 'g') {
                keys.g_cheat_processed = false;
            }
            // Reset weapon switch processed flags
            if (keyName === '1') keys.weapon_1_processed = false;
            if (keyName === '2') keys.weapon_2_processed = false;
            if (keyName === '3') keys.weapon_3_processed = false;
        });
        canvas.addEventListener('mousemove', (e)=>{ const r=canvas.getBoundingClientRect();mouse.x=e.clientX-r.left;mouse.y=e.clientY-r.top;});
        canvas.addEventListener('mousedown', (e)=>{if(e.button===0){ensureAudioAndSynths();mouse.down=true;}}); 
        canvas.addEventListener('mouseup', (e)=>{if(e.button===0)mouse.down=false;});
        canvas.addEventListener('contextmenu', (e)=>e.preventDefault()); 
        restartButton.addEventListener('click', async () => {
            try {
                await ensureAudioAndSynths(); 
                messageOverlay.style.display = 'none'; 
                if (gameOver) { 
                    currentLevel = 1;
                    score = 0; 
                }
                initGame(); 
            } catch (error) {
                console.error("Error in restartButton click handler:", error);
                messageText.textContent = `Error: ${error.message || JSON.stringify(error)}. Check console.`;
                messageTitle.textContent = "Error!";
                messageOverlay.style.display = 'flex'; 
            }
        });
        
        // Ensure player sprite is loaded before starting the game from the start screen
        if (playerSpriteImage.complete) {
            showStartScreen();
        } else {
            playerSpriteImage.onload = () => {
                showStartScreen();
            };
            playerSpriteImage.onerror = () => {
                console.error("Player sprite failed to load. Using fallback.");
                showStartScreen(); // Start even if sprite fails, will use fallback drawing
            }
        }

    </script>
</body>
</html>