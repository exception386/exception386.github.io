<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Top-Down Doom-like</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        #gameContainer {
            border: 4px solid #4a4a4a;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            position: relative; /* Important for absolute positioning of uiContainer */
            background-color: #2a2a2a;
            width: 800px; 
            height: 600px; 
        }
        canvas {
            display: block;
            background-color: #333; /* Default canvas background */
            cursor: crosshair;
        }
        #topUiContainer {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 800px; /* Match gameContainer width */
            padding: 5px 10px;
            font-size: 16px; 
            color: #cccccc;
            box-sizing: border-box;
            margin-bottom: 5px; 
        }
        #uiContainer { /* Bottom UI bar */
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center; 
            padding: 8px 15px; 
            font-size: 14px; 
            color: #cccccc; 
            background-color: rgba(0, 0, 0, 0.75); 
            box-sizing: border-box;
            z-index: 5; 
        }
        #healthDisplayContainer, #scoreDisplayContainer, #levelDisplayContainer {
             color: #ff4136; 
        }
        #keysDisplayContainer {
            display: flex;
            align-items: center;
            gap: 8px;
             color: #ff4136;
        }
        #keysDisplay { 
            display: flex;
            gap: 5px; 
        }
        .key-icon {
            width: 18px; 
            height: 18px;
            border: 1px solid #888;
            border-radius: 3px;
            display: inline-block;
            opacity: 0.3; 
        }
        .key-icon.red { background-color: red; }
        .key-icon.yellow { background-color: yellow; }
        .key-icon.blue { background-color: blue; }
        .key-icon.collected { opacity: 1; }
        
        #weaponInfoContainer { 
            display: flex;
            align-items: center;
            gap: 10px; 
        }
        
        #weaponInventoryIcons {
            display: flex;
            gap: 6px; 
            align-items: center;
            font-size: 14px; 
        }
        #weaponInventoryIcons > span:first-child { /* "Weapons:" label */
             color: #00ff00;
        }
        .weapon-icon-display {
            border: 1px solid #555;
            padding: 3px 5px;
            border-radius: 4px;
            font-size: 12px;
            opacity: 0.4;
            color: #888; 
            display: flex; 
            align-items: center;
            gap: 4px;
            min-width: 50px; 
            justify-content: center;
        }
        .weapon-icon-display .weapon-char {
            font-weight: bold;
        }
        .weapon-icon-display .ammo-text-display {
            font-size: 10px;
        }
        .weapon-icon-display.owned { /* Indicates the player has the weapon */
            opacity: 0.7; 
            border-color: #00aa00;
            color: #00aa00;
        }
        .weapon-icon-display.selected-weapon-icon { /* Indicates currently selected AND owned */
            opacity: 1;
            border-color: #00ff00; 
            color: #00ff00;
            box-shadow: 0 0 8px #00ff00;
            transform: scale(1.05);
        }

        #messageOverlay, #instructionsOverlay { /* Common styles for overlays */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85); 
            display: none; /* Initially hidden */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: white;
            z-index: 10;
            padding: 20px;
            box-sizing: border-box;
        }
        #messageOverlay h2 {
            font-size: 36px;
            color: #ff4136;
            margin-bottom: 15px; /* Adjusted margin */
        }
        #messageOverlay p {
            margin-bottom: 20px; 
            font-size: 20px; /* Adjusted for cleaner look if empty */
            min-height: 20px; /* Ensure space even if empty */
        }
        #difficultySelection {
            margin-bottom: 25px; /* Adjusted margin */
            display: flex;
            gap: 15px;
        }
         .game-button, .difficulty-button { 
            font-family: 'Press Start 2P', cursive;
            color: white;
            border-width: 2px;
            border-style: solid;
            padding: 10px 20px; 
            font-size: 16px; 
            cursor: pointer;
            text-transform: uppercase;
            transition: background-color 0.3s, transform 0.1s;
            margin-top: 10px; /* Added margin for spacing */
        }
        .game-button { 
            background-color: #c00;
            border-color: #800;
            box-shadow: 0 4px #500;
            padding: 15px 30px; 
            font-size: 18px;  
        }
        .game-button:hover { background-color: #e00; }
        .game-button:active { background-color: #a00; transform: translateY(2px); box-shadow: 0 2px #500; }

        .difficulty-button {
            background-color: #555;
            border-color: #333;
            box-shadow: 0 3px #222;
        }
        .difficulty-button:hover { background-color: #777; }
        .difficulty-button:active { background-color: #444; transform: translateY(1px); box-shadow: 0 2px #222; }
        .difficulty-button.selected {
            background-color: #ff4136; 
            border-color: #c00;
            box-shadow: 0 3px #800;
        }

        /* Styles for the new Instructions Overlay */
        #instructionsOverlay {
            background-color: rgba(0, 0, 0, 0.92); /* Slightly more opaque */
            z-index: 20; /* Ensure it's on top if messageOverlay is somehow visible */
        }
        #instructionsOverlay h2 {
            font-size: 30px;
            color: #00bcd4; /* Cyan color for instructions title */
            margin-bottom: 20px;
        }
        #instructionsOverlay #instructionsTextContent {
            margin-bottom: 25px;
            text-align: left;
            max-width: 600px;
            line-height: 1.7;
            font-size: 14px; /* Smaller for more text */
            max-height: 70vh; /* Make it scrollable if too long */
            overflow-y: auto;
            padding: 15px;
            border: 1px solid #444;
            border-radius: 8px;
            background-color: rgba(20,20,20,0.5);
        }
        #instructionsOverlay .game-button { /* For the close button */
            background-color: #007bff; /* Blue close button */
            border-color: #0056b3;
            box-shadow: 0 4px #003f7f;
        }
        #instructionsOverlay .game-button:hover { background-color: #009cff; }
        #instructionsOverlay .game-button:active { background-color: #0056b3; transform: translateY(2px); box-shadow: 0 2px #003f7f;}

    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">
    <div id="topUiContainer">
        <div id="scoreDisplayContainer">Score: <span id="scoreDisplay">0</span></div>
        <div id="levelDisplayContainer">Level: <span id="waveDisplay">1</span></div>
    </div>

    <div id="gameContainer" class="rounded-lg overflow-hidden shadow-2xl">
        <canvas id="gameCanvas"></canvas>
        <div id="uiContainer">
            <div id="healthDisplayContainer">Health: <span id="healthDisplay">100</span></div>
            
            <div id="weaponInfoContainer">
                <div id="weaponInventoryIcons">
                    <span class="text-gray-400 mr-1">Weapons:</span>
                    <span class="weapon-icon-display" data-weapon-name="Pistol" id="pistolIconDisplay">
                        <span class="weapon-char">P</span> <span class="ammo-text-display">Inf</span>
                    </span>
                    <span class="weapon-icon-display" data-weapon-name="Shotgun" id="shotgunIconDisplay">
                        <span class="weapon-char">S</span> <span class="ammo-text-display">--</span>
                    </span>
                    <span class="weapon-icon-display" data-weapon-name="Machine Gun" id="machineGunIconDisplay">
                        <span class="weapon-char">M</span> <span class="ammo-text-display">--</span>
                    </span>
                    <span class="weapon-icon-display" data-weapon-name="Rocket Launcher" id="rocketLauncherIconDisplay">
                        <span class="weapon-char">R</span> <span class="ammo-text-display">--</span>
                    </span>
                    <span class="weapon-icon-display" data-weapon-name="BFG" id="bfgIconDisplay"> <span class="weapon-char">B</span> <span class="ammo-text-display">--</span>
                    </span>
                </div>
            </div>

            <div id="keysDisplayContainer">
                <span class="text-gray-400">Keys:</span>
                <div id="keysDisplay">
                    <span class="key-icon red" id="redKeyIcon"></span>
                    <span class="key-icon yellow" id="yellowKeyIcon"></span>
                    <span class="key-icon blue" id="blueKeyIcon"></span>
                </div>
            </div>
        </div>
        <div id="messageOverlay" style="display: none;"> 
            <h2 id="messageTitle">Game Over</h2>
            <p id="messageText">Your score: 0</p>
            <div id="difficultySelection">
                <button class="difficulty-button" data-difficulty="easy">Easy</button>
                <button class="difficulty-button selected" data-difficulty="medium">Medium</button>
                <button class="difficulty-button" data-difficulty="hard">Hard</button>
            </div>
            <button id="restartButton" class="game-button">Restart Game</button>
            <button id="instructionsButton" class="game-button" style="margin-top: 15px; background-color: #555; border-color: #333; box-shadow: 0 4px #222;">Instructions</button>
        </div>

        <div id="instructionsOverlay" style="display: none;">
            <h2>Instructions</h2>
            <div id="instructionsTextContent">
                </div>
            <button id="closeInstructionsButton" class="game-button">Close</button>
        </div>
    </div>
    
    <img id="playerSprite" src="https://jeffhockema.com/sprites/military1.png" style="display: none;" alt="Player Sprite" crossorigin="anonymous">

    <script>
        console.log("SCRIPT START: Top-Down Doom-like game script initiated.");

        // Tile Types Constants
        const TILE_EMPTY = 0;
        const TILE_WALL = 1;
        const TILE_DOOR_RED = 2;
        const TILE_DOOR_YELLOW = 3;
        const TILE_DOOR_BLUE = 4;
        const TILE_KEY_RED = 5;
        const TILE_KEY_YELLOW = 6;
        const TILE_KEY_BLUE = 7;
        const TILE_EXIT = 8;
        const TILE_WEAPON_SHOTGUN = 9;
        const TILE_WEAPON_MACHINEGUN = 10;
        const TILE_WEAPON_ROCKETLAUNCHER = 11;
        const TILE_WEAPON_BFG = 12; 
        const TILE_HEALTH_PACK = 13; 
        const TILE_SECRET_DOOR = 14;

        // Offscreen canvas for static map elements
        let staticMapCanvas;
        let staticMapCtx;

        // Audio initialization
        async function initializeAudio() {
            try {
                if (Tone.context.state === 'suspended') {
                    await Tone.start();
                    console.log("AudioContext started successfully.");
                }
            } catch (e) {
                console.warn("Warning during initial Tone.start():", e);
            }
        }
        initializeAudio(); 

        // DOM Elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const healthDisplay = document.getElementById('healthDisplay');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const waveDisplay = document.getElementById('waveDisplay'); 
        const weaponInventoryIcons = document.getElementById('weaponInventoryIcons');
        const messageOverlay = document.getElementById('messageOverlay');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');
        const redKeyIcon = document.getElementById('redKeyIcon');
        const yellowKeyIcon = document.getElementById('yellowKeyIcon');
        const blueKeyIcon = document.getElementById('blueKeyIcon');
        const difficultySelectionDiv = document.getElementById('difficultySelection');
        const difficultyButtons = document.querySelectorAll('.difficulty-button');
        const playerSpriteImage = document.getElementById('playerSprite'); 

        const instructionsButton = document.getElementById('instructionsButton');
        const instructionsOverlay = document.getElementById('instructionsOverlay');
        const instructionsTextContent = document.getElementById('instructionsTextContent');
        const closeInstructionsButton = document.getElementById('closeInstructionsButton');


        // Game Constants
        const TILE_SIZE = 40; 
        const MAP_COLS = 50; 
        const MAP_ROWS = 40; 

        const VIEWPORT_WIDTH = 800; 
        const VIEWPORT_HEIGHT = 600; 
        canvas.width = VIEWPORT_WIDTH;
        canvas.height = VIEWPORT_HEIGHT;

        const PLAYER_SPRITE_FRAME_WIDTH = 26;
        const PLAYER_SPRITE_FRAME_HEIGHT = 36;
        const PLAYER_SPRITE_SCALE = 1.2; 

        const playerFrames = { 
            down:  { x: 3, y: 0 }, 
            left:  { x: 3, y: 1 },  
            right: { x: 3, y: 2 }, 
            up:    { x: 3, y: 3 },    
        };
        
        const camera = {
            x: 0, y: 0,
            width: VIEWPORT_WIDTH, height: VIEWPORT_HEIGHT,
            update: function(target) { 
                if (!target) { return; }
                let targetX = target.x; let targetY = target.y;
                if (isNaN(targetX) || isNaN(targetY)) {
                    console.warn(`Camera target position is NaN (x: ${targetX}, y: ${targetY}). Defaulting target to center for camera calculation.`);
                    targetX = (MAP_COLS * TILE_SIZE) / 2; targetY = (MAP_ROWS * TILE_SIZE) / 2;
                }
                this.x = Math.max(0, Math.min(targetX - this.width / 2, (MAP_COLS * TILE_SIZE) - this.width));
                this.y = Math.max(0, Math.min(targetY - this.height / 2, (MAP_ROWS * TILE_SIZE) - this.height));
                if (isNaN(this.x) || isNaN(this.y)) {
                    console.error(`Camera position became NaN (calculated x: ${this.x}, y: ${this.y}). Resetting to 0,0.`);
                    this.x = 0; this.y = 0;
                }
            }
        };

        const wallStyles = [ { name: "Classic Grey", fillColor: '#5a5a5a', borderColor: '#444444' }, { name: "Industrial Metal", fillColor: '#787A7C', borderColor: '#555759', pattern: drawMetalPattern }, { name: "Ancient Stone", fillColor: '#6F6659', borderColor: '#504A40', pattern: drawStonePattern },  { name: "Mossy Dungeon", fillColor: '#4A5D43', borderColor: '#384831' }, { name: "Crimson Hell", fillColor: '#7D2828', borderColor: '#5A1D1D' } ];
        let currentWallStyle = wallStyles[0]; 

        // Game State Variables
        let player; 
        let bullets, enemies, gameMap, healthPacks, ammoPacks, visibilityMap, explosions, temporaryVisualEffects; 
        let bulletPool = []; 
        const MAX_BULLETS_IN_POOL = 200;
        const MAX_ACTIVE_BULLETS = 100; 
        let allValidSpawnTiles = []; // For refined enemy spawning

        let currentBoss = null; 
        let isBossLevel = false; 
        let isCurrentLevelMiniBoss = false; 
        let nextMiniBossSpawnLevel = 0; 
        const MINI_BOSS_SPAWN_INTERVAL_MIN = 2; 
        const MINI_BOSS_SPAWN_INTERVAL_MAX = 3; 

        let score = 0; let currentLevel = 1; let gameOver = false; let gameRunning = false; 
        let enemiesToSpawnPerLevel = 10; let enemiesSpawnedThisLevel = 0; let enemiesRemaining = 0;
        let gameLoopId; let selectedDifficulty = 'medium'; let isLevelCompleting = false;

        const WEAPON_STATS = { "Pistol": { name: "Pistol", damage: () => 25 + currentLevel * 2, fireRate: 10, bulletSpeed: 10, spread: 0, numPellets: 1, color: '#ffeb3b', singleShot: true, ammo: Infinity, maxAmmo: Infinity, pickupAmmo: 0 }, "Shotgun": { name: "Shotgun", damage: () => 15 + currentLevel, fireRate: 25, bulletSpeed: 8, spread: 0.3, numPellets: 6, color: '#FFA500', singleShot: false, ammo: 0, maxAmmo: 30, pickupAmmo: 10 }, "Machine Gun": { name: "Machine Gun", damage: () => 8 + currentLevel * 0.5, fireRate: 4, bulletSpeed: 12, spread: 0.1, numPellets: 1, color: '#ADD8E6', singleShot: false, ammo: 0, maxAmmo: 150, pickupAmmo: 50 }, "Rocket Launcher": { name: "Rocket Launcher", damage: () => 50, fireRate: 60, bulletSpeed: 5, spread: 0, numPellets: 1, color: '#FF6347', singleShot: true, ammo: 0, maxAmmo: 10, pickupAmmo: 3, aoeRadius: TILE_SIZE * 2.5, explosionDuration: 30, isRocket: true }, "BFG": { name: "BFG", damage: () => 200, tracerDamage: 50, fireRate: 150, bulletSpeed: 4, spread: 0, numPellets: 1, color: '#00FF00', singleShot: true, ammo: 0, maxAmmo: 5, pickupAmmo: 1, isBFG: true } };

        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, w: false, s: false, a: false, d: false, '1': false, '2': false, '3': false, '4': false, '5': false, i_cheat_processed: false, k_cheat_processed: false, g_cheat_processed: false, l_cheat_processed: false, weapon_1_processed: false, weapon_2_processed: false, weapon_3_processed: false, weapon_4_processed: false, weapon_5_processed: false  };
        const mouse = { x: VIEWPORT_WIDTH / 2, y: VIEWPORT_HEIGHT / 2, down: false }; 

        let synth, metalSynth, hitSynth, explosionSynth, rocketFireSynth, bfgFireSynth, bossHitSynth, bossDeathSynth, bossRegularShootSynth, bossSeekingShootSynth, ammoPickupSynth, secretDoorOpenSynth; 
        let playerHitDedicatedSynth, machineGunShootSynth, rocketExplosionRefactoredSynth, bfgImpactRefactoredSynth, bfgImpactReverb, enemyShootRefactoredSynth, healthPickupRefactoredSynth, keyPickupRefactoredSynth, doorOpenRefactoredSynth, weaponPickupRefactoredSynth, teleportRefactoredSynth, splitRefactoredSynth, emptyGunRefactoredSynth;
        let lastHitSoundTime = 0; const HIT_SOUND_COOLDOWN = 50; let lastEnemyDestroySoundTime = 0; const ENEMY_DESTROY_SOUND_COOLDOWN = 100; 

        function setupSynths() {
            try {
                synth = new Tone.Synth({volume: -10}).toDestination(); 
                metalSynth = new Tone.MetalSynth({frequency: 50, envelope: { attack: 0.001, decay: 0.1, release: 0.1 }, harmonicity: 3.1, modulationIndex: 16, resonance: 2000, octaves: 0.5, volume: -15}).toDestination();
                hitSynth = new Tone.NoiseSynth({noise: { type: "pink" }, envelope: { attack: 0.001, decay: 0.05, sustain: 0 }, volume: -10}).toDestination();
                explosionSynth = new Tone.NoiseSynth({noise: { type: "white" }, envelope: { attack: 0.005, decay: 0.3, sustain: 0, release: 0.4 }, volume: -3}).toDestination(); 
                rocketFireSynth = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 5, oscillator: {type: "sine"}, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 0.4, attackCurve: "exponential"}, volume: -5 }).toDestination();
                bfgFireSynth = new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { attack: 0.1, decay: 0.8, sustain: 0.1, release: 0.5 }, volume: -2 }).toDestination();
                const bfgFireFilter = new Tone.AutoFilter("2n").toDestination().start(); bfgFireFilter.depth.value = 0.8; bfgFireSynth.connect(bfgFireFilter);
                bossHitSynth = new Tone.MetalSynth({frequency: 40, envelope: { attack: 0.005, decay: 0.2, release: 0.1 }, harmonicity: 5.1, modulationIndex: 20, resonance: 1000, octaves: 1.5, volume: -8}).toDestination();
                bossDeathSynth = new Tone.NoiseSynth({ noise: { type: "brown" }, envelope: { attack: 0.1, decay: 1.5, sustain: 0.2, release: 1.0 }, volume: -3 }).toDestination();
                const bossDeathChorus = new Tone.Chorus(4, 2.5, 0.7).toDestination().start(); bossDeathSynth.connect(bossDeathChorus);
                bossRegularShootSynth = new Tone.Synth({ oscillator: {type: "pwm", modulationFrequency: 0.2}, envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.2 }, volume: -10 }).toDestination();
                bossSeekingShootSynth = new Tone.Synth({ oscillator: {type: "sawtooth", modulationFrequency: 0.3}, envelope: { attack: 0.02, decay: 0.25, sustain: 0.1, release: 0.2 }, volume: -11 }).toDestination();
                ammoPickupSynth = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.005, decay: 0.1, release: 0.1 }, volume: -12 }).toDestination();
                secretDoorOpenSynth = new Tone.NoiseSynth({ noise: { type: "brown" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0 }, volume: -15 }).toDestination();
                const secretDoorFilter = new Tone.Filter(800, "lowpass").toDestination(); secretDoorOpenSynth.connect(secretDoorFilter);
                playerHitDedicatedSynth = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.001, decay: 0.1, sustain: 0.05, release: 0.1}, volume: -10 }).toDestination();
                machineGunShootSynth = new Tone.MetalSynth({ frequency: 70, envelope: { attack: 0.001, decay: 0.05, release: 0.05 }, harmonicity: 3.1, modulationIndex: 16, resonance: 1500, octaves: 0.5, volume: -18 }).toDestination();
                rocketExplosionRefactoredSynth = new Tone.NoiseSynth({ noise: { type: "white" }, envelope: { attack: 0.005, decay: 0.3, sustain: 0, release: 0.4 }, volume: -3 }).toDestination();
                bfgImpactRefactoredSynth = new Tone.NoiseSynth({ noise: { type: "white" }, envelope: { attack: 0.01, decay: 0.6, sustain: 0, release: 0.8 }, volume: 0 }).toDestination();
                bfgImpactReverb = new Tone.Reverb(1.5).toDestination(); bfgImpactRefactoredSynth.connect(bfgImpactReverb);
                enemyShootRefactoredSynth = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.005, decay: 0.05, sustain: 0.01, release: 0.1 }, volume: -20 }).toDestination();
                healthPickupRefactoredSynth = new Tone.Synth({oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.2 }, volume: -10}).toDestination();
                keyPickupRefactoredSynth = new Tone.Synth({oscillator: {type: "triangle"}, envelope: {attack: 0.01, decay: 0.2, release: 0.2}, volume: -8}).toDestination();
                doorOpenRefactoredSynth = new Tone.MetalSynth({frequency: 100, envelope: {attack:0.01, decay:0.3, release: 0.1}, harmonicity: 1.1, modulationIndex:5, resonance: 500, octaves: 1.5, volume: -12}).toDestination();
                weaponPickupRefactoredSynth = new Tone.Synth({ oscillator: {type: "sawtooth"}, envelope: {attack: 0.02, decay: 0.15, release: 0.2}, volume: -9}).toDestination();
                teleportRefactoredSynth = new Tone.Synth({ oscillator: { type: 'triangle8' }, envelope: { attack: 0.01, decay: 0.2, release: 0.2 }, volume: -10 }).toDestination();
                splitRefactoredSynth = new Tone.PluckSynth({ attackNoise: 0.5, dampening: 2000, resonance: 0.8, volume: -8 }).toDestination();
                emptyGunRefactoredSynth = new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 2, envelope: { attack: 0.001, decay: 0.1, sustain: 0 }, volume: -10 }).toDestination();
                console.log("Synths initialized successfully.");
            } catch (err) { console.error("Error during setupSynths:", err); }
        }
        async function ensureAudioAndSynths() { if (Tone.context.state === 'suspended') { try { await Tone.start(); console.log("Tone.js context started by ensureAudioAndSynths."); } catch (err) { console.error("Error starting Tone.js in ensureAudioAndSynths:", err); } } if (!synth || !playerHitDedicatedSynth) { try { setupSynths(); } catch (err) { console.error("Error setting up synths via ensureAudioAndSynths:", err); } } }

        function playShootSound(weaponName) { if (Tone.context.state !== 'running') return; const now = Tone.now() + 0.001; if (weaponName === 'Pistol' && metalSynth) { metalSynth.frequency.setValueAtTime(50, now); metalSynth.triggerAttackRelease("C2", "8n", now); } else if (weaponName === 'Shotgun' && metalSynth) { metalSynth.frequency.setValueAtTime(30, now); metalSynth.triggerAttackRelease("A1", "4n", now); } else if (weaponName === 'Machine Gun' && machineGunShootSynth) { machineGunShootSynth.triggerAttackRelease("D2", "32n", now); } else if (weaponName === 'Rocket Launcher' && rocketFireSynth) { rocketFireSynth.triggerAttackRelease("C1", "0.5s", now); } else if (weaponName === 'BFG' && bfgFireSynth) { bfgFireSynth.triggerAttackRelease("1s", now); } }
        function playHitSound() { const nowMs = Tone.now() * 1000; if (nowMs - lastHitSoundTime < HIT_SOUND_COOLDOWN) return; lastHitSoundTime = nowMs; if (hitSynth && Tone.context.state === 'running') hitSynth.triggerAttackRelease("8n", Tone.now() + 0.01); } 
        function playPlayerHitSound() { if (playerHitDedicatedSynth && Tone.context.state === 'running') playerHitDedicatedSynth.triggerAttackRelease("A1", "8n", Tone.now() + 0.01); else if (synth && Tone.context.state === 'running') synth.triggerAttackRelease("A1", "8n", Tone.now() + 0.01); } 
        function playEnemyDestroySound() { const nowMs = Tone.now() * 1000; if (nowMs - lastEnemyDestroySoundTime < ENEMY_DESTROY_SOUND_COOLDOWN) return; lastEnemyDestroySoundTime = nowMs; if (explosionSynth && Tone.context.state === 'running') explosionSynth.triggerAttackRelease("0.2", Tone.now() + 0.01); } 
        function playRocketExplosionSound() { if (rocketExplosionRefactoredSynth && Tone.context.state === 'running') rocketExplosionRefactoredSynth.triggerAttackRelease("0.4", Tone.now() + 0.01); }
        function playBFGImpactSound() { if (bfgImpactRefactoredSynth && bfgImpactReverb && Tone.context.state === 'running') bfgImpactRefactoredSynth.triggerAttackRelease("0.8s", Tone.now() + 0.01); }
        function playEnemyShootSound() { if (enemyShootRefactoredSynth && Tone.context.state === 'running') enemyShootRefactoredSynth.triggerAttackRelease("G3", "16n", Tone.now() + 0.001); }
        function playHealthPickupSound() { if (healthPickupRefactoredSynth && Tone.context.state === 'running') healthPickupRefactoredSynth.triggerAttackRelease("C5", "8n", Tone.now() + 0.01); }
        function playKeyPickupSound() { if (keyPickupRefactoredSynth && Tone.context.state === 'running') keyPickupRefactoredSynth.triggerAttackRelease("E5", "8n", Tone.now() + 0.01); }
        function playDoorOpenSound() { if (doorOpenRefactoredSynth && Tone.context.state === 'running') doorOpenRefactoredSynth.triggerAttackRelease("F#2", "4n", Tone.now() + 0.01); }
        function playWeaponPickupSound() { if (weaponPickupRefactoredSynth && Tone.context.state === 'running') weaponPickupRefactoredSynth.triggerAttackRelease("A4", "8n", Tone.now() + 0.01); }
        function playTeleportSound() { if (teleportRefactoredSynth && Tone.context.state === 'running') teleportRefactoredSynth.triggerAttackRelease("C6", "16n", Tone.now() + 0.01); }
        function playSplitSound() { if (splitRefactoredSynth && Tone.context.state === 'running') splitRefactoredSynth.triggerAttackRelease("G2", "8n", Tone.now() + 0.01); }
        function playEmptyGunSound() { if (emptyGunRefactoredSynth && Tone.context.state === 'running') emptyGunRefactoredSynth.triggerAttackRelease("C2", "16n", Tone.now() + 0.001); }
        function playBossHitSound() { if (bossHitSynth && Tone.context.state === 'running') bossHitSynth.triggerAttackRelease("G1", "4n", Tone.now() + 0.01);} 
        function playBossDeathSound() { if (bossDeathSynth && Tone.context.state === 'running') bossDeathSynth.triggerAttackRelease("2s", Tone.now() + 0.01);} 
        function playBossRegularShootSound() { if (bossRegularShootSynth && Tone.context.state === 'running') bossRegularShootSynth.triggerAttackRelease("A2", "8n", Tone.now() + 0.01); }
        function playBossSeekingShootSound() { if (bossSeekingShootSynth && Tone.context.state === 'running') bossSeekingShootSynth.triggerAttackRelease("G#2", "8n", Tone.now() + 0.01); }
        function playSecretDoorOpenSound() { if (secretDoorOpenSynth && Tone.context.state === 'running') secretDoorOpenSynth.triggerAttackRelease("0.1s", Tone.now() + 0.01); }
        function playAmmoPickupSound() { if (ammoPickupSynth && Tone.context.state === 'running') ammoPickupSynth.triggerAttackRelease("D4", "16n", Tone.now() + 0.01); }

        function findPath(startX, startY, endX, endY, currentMap, keysAvailable) { const queue = [[startX, startY, []]]; const visited = new Set(); visited.add(`${startX},${startY}`); while (queue.length > 0) { const [x, y, path] = queue.shift(); if (x === endX && y === endY) return true; const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; for (const [dx, dy] of directions) { const nextX = x + dx; const nextY = y + dy; if (nextX >= 0 && nextX < MAP_COLS && nextY >= 0 && nextY < MAP_ROWS && !visited.has(`${nextX},${nextY}`)) { const tileType = currentMap[nextY][nextX]; let canPass = false; if (tileType === TILE_EMPTY || (tileType >= TILE_KEY_RED && tileType <= TILE_HEALTH_PACK) || tileType === TILE_SECRET_DOOR || tileType === TILE_EXIT) { canPass = true; } else if (tileType === TILE_DOOR_RED && keysAvailable.red) { canPass = true; } else if (tileType === TILE_DOOR_YELLOW && keysAvailable.yellow) { canPass = true; } else if (tileType === TILE_DOOR_BLUE && keysAvailable.blue) { canPass = true; } if (canPass) { visited.add(`${nextX},${nextY}`); queue.push([nextX, nextY, [...path, [nextX, nextY]]]); } } } } return false; }
        function findPathForVisibility(startX, startY, endX, endY, currentMap) { const queue = [[startX, startY, []]]; const visited = new Set(); visited.add(`${startX},${startY}`); while (queue.length > 0) { const [x, y, path] = queue.shift(); if (x === endX && y === endY) return true; const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; for (const [dx, dy] of directions) { const nextX = x + dx; const nextY = y + dy; if (nextX >= 0 && nextX < MAP_COLS && nextY >= 0 && nextY < MAP_ROWS && !visited.has(`${nextX},${nextY}`)) { const tileType = currentMap[nextY][nextX]; if (tileType === TILE_EMPTY || (tileType >= TILE_KEY_RED && tileType <= TILE_HEALTH_PACK) || tileType === TILE_EXIT) { visited.add(`${nextX},${nextY}`); queue.push([nextX, nextY, [...path, [nextX, nextY]]]); } } } } return false; }
        function updateVisibility(playerTileX, playerTileY, currentMap) { if (!currentMap || !currentMap.length || !currentMap[0] || !currentMap[0].length) { console.error("updateVisibility: currentMap is invalid or not fully initialized."); visibilityMap = Array(MAP_ROWS).fill(null).map(() => Array(MAP_COLS).fill(true)); return; } visibilityMap = Array(MAP_ROWS).fill(null).map(() => Array(MAP_COLS).fill(false)); const queue = []; const visitedForBFS = new Set(); if (playerTileX >= 0 && playerTileX < MAP_COLS && playerTileY >= 0 && playerTileY < MAP_ROWS) { queue.push([playerTileX, playerTileY]); visitedForBFS.add(`${playerTileX},${playerTileY}`); if (visibilityMap[playerTileY]) visibilityMap[playerTileY][playerTileX] = true;  } let head = 0; while(head < queue.length){ const [x,y] = queue[head++]; const directions = [[0, 1], [0, -1], [1, 0], [-1, 0],[ -1, -1 ], [ -1, 1 ], [ 1, -1 ], [ 1, 1 ]]; for (const [dx, dy] of directions) { const nextX = x + dx; const nextY = y + dy; if (nextX >= 0 && nextX < MAP_COLS && nextY >= 0 && nextY < MAP_ROWS) { if (!currentMap[nextY] || currentMap[nextY][nextX] === undefined) { continue; } const neighborTileType = currentMap[nextY][nextX]; if (!visitedForBFS.has(`${nextX},${nextY}`)) { if (neighborTileType === TILE_EMPTY || (neighborTileType >= TILE_KEY_RED && neighborTileType <= TILE_HEALTH_PACK) || neighborTileType === TILE_EXIT) { if (visibilityMap[nextY]) visibilityMap[nextY][nextX] = true; visitedForBFS.add(`${nextX},${nextY}`); queue.push([nextX, nextY]); } else if (neighborTileType === TILE_WALL || (neighborTileType >= TILE_DOOR_RED && neighborTileType <= TILE_DOOR_BLUE) || neighborTileType === TILE_SECRET_DOOR ) { if (visibilityMap[nextY]) visibilityMap[nextY][nextX] = true;  visitedForBFS.add(`${nextX},${nextY}`);  } } } } } }
        function isPathClear(x1, y1, x2, y2, currentMap, step = TILE_SIZE / 4) { if (!currentMap || !currentMap.length || !currentMap[0] || !currentMap[0].length) return false; const dxTotal = x2 - x1; const dyTotal = y2 - y1; const distance = Math.hypot(dxTotal, dyTotal); const steps = Math.max(1, Math.floor(distance / step)); for (let i = 0; i <= steps; i++) { const t = i / steps; const currentX = x1 + t * dxTotal; const currentY = y1 + t * dyTotal; const tileX = Math.floor(currentX / TILE_SIZE); const tileY = Math.floor(currentY / TILE_SIZE); if (tileX < 0 || tileX >= MAP_COLS || tileY < 0 || tileY >= MAP_ROWS) return false; if (!currentMap[tileY] || currentMap[tileY][tileX] === undefined) return false; const tileType = currentMap[tileY][tileX]; if (tileType === TILE_WALL || tileType === TILE_DOOR_RED || tileType === TILE_DOOR_YELLOW || tileType === TILE_DOOR_BLUE || tileType === TILE_SECRET_DOOR) { if (i < steps) return false; } } return true; }

        function generateMaze(cols, rows, isMainBossLevelLayout) { console.log("generateMaze: Starting maze generation for level", currentLevel, "isMainBossLevelLayout:", isMainBossLevelLayout); let map = Array(rows).fill(null).map(() => Array(cols).fill(TILE_WALL)); let playerStartCell = { r: Math.floor(rows/2), c: Math.floor(cols/2) }; let bossSpawnCell = null; let actualPlayerStartRoom = null; let rooms = []; function placeItemInRandomEmptyTile(room, itemTileType, currentMap) { if (!room) return false; let placed = false; const emptyTiles = []; for(let r = room.y; r < room.y + room.height; r++){ for(let c = room.x; c < room.x + room.width; c++){ if(r >=0 && r < MAP_ROWS && c >= 0 && c < MAP_COLS && currentMap[r][c] === TILE_EMPTY) emptyTiles.push({r,c}); } } if(emptyTiles.length > 0){ const randTile = emptyTiles[Math.floor(Math.random() * emptyTiles.length)]; currentMap[randTile.r][randTile.c] = itemTileType; placed = true; } return placed; } if (isMainBossLevelLayout) { const bossRoomWidth = Math.max(15, Math.floor(cols * 0.6) ); const bossRoomHeight = Math.max(10, Math.floor(rows * 0.5)); const bossRoomX = Math.floor((cols - bossRoomWidth) / 2); const bossRoomY = Math.floor((rows - bossRoomHeight) / 2); const bossRoom = { x: bossRoomX, y: bossRoomY, width: bossRoomWidth, height: bossRoomHeight, id: 0, center: {x: bossRoomX + Math.floor(bossRoomWidth/2), y: bossRoomY + Math.floor(bossRoomHeight/2)}, connected: true}; rooms.push(bossRoom); for (let r = bossRoomY; r < bossRoomY + bossRoomHeight; r++) { for (let c = bossRoomX; c < bossRoomX + bossRoomWidth; c++) { if (r >= 0 && r < rows && c >=0 && c < cols) map[r][c] = TILE_EMPTY; } } bossSpawnCell = { r: bossRoom.center.y, c: bossRoom.center.x }; const numAntechambers = 1 + Math.floor(Math.random() * 2); let playerPlaced = false; for (let i = 0; i < numAntechambers; i++) { const anteWidth = 5 + Math.floor(Math.random() * 3); const anteHeight = 5 + Math.floor(Math.random() * 3); let anteX, anteY; if (i === 0) { anteX = Math.max(1, bossRoomX - anteWidth - 2); anteY = bossRoomY + Math.floor((bossRoomHeight - anteHeight) / 2); } else { anteX = Math.min(cols - anteWidth - 1, bossRoomX + bossRoomWidth + 2); anteY = bossRoomY + Math.floor((bossRoomHeight - anteHeight) / 2); } anteX = Math.max(1, Math.min(anteX, cols - anteWidth - 1)); anteY = Math.max(1, Math.min(anteY, rows - anteHeight - 1)); const antechamber = {x: anteX, y: anteY, width: anteWidth, height: anteHeight, id: i+1, center: {x: anteX + Math.floor(anteWidth/2), y: anteY + Math.floor(anteHeight/2)}, connected: false}; rooms.push(antechamber); for (let r = anteY; r < anteY + anteHeight; r++) { for (let c = anteX; c < anteX + anteWidth; c++) { if (r >= 0 && r < rows && c >=0 && c < cols) map[r][c] = TILE_EMPTY; } } let tunnelStartX = antechamber.center.x; let tunnelStartY = antechamber.center.y; let tunnelEndX = bossRoom.center.x; let tunnelEndY = bossRoom.center.y; while(tunnelStartX !== tunnelEndX) { if(map[tunnelStartY][tunnelStartX] === TILE_WALL) map[tunnelStartY][tunnelStartX] = TILE_EMPTY; tunnelStartX += Math.sign(tunnelEndX - tunnelStartX); } if(map[tunnelStartY][tunnelStartX] === TILE_WALL) map[tunnelStartY][tunnelStartX] = TILE_EMPTY; while(tunnelStartY !== tunnelEndY) { if(map[tunnelStartY][tunnelStartX] === TILE_WALL) map[tunnelStartY][tunnelStartX] = TILE_EMPTY; tunnelStartY += Math.sign(tunnelEndY - tunnelStartY); } if(map[tunnelStartY][tunnelStartX] === TILE_WALL) map[tunnelStartY][tunnelStartX] = TILE_EMPTY; if (!playerPlaced) { playerStartCell = { r: antechamber.center.y, c: antechamber.center.x }; playerPlaced = true; } if (i < 2) placeItemInRandomEmptyTile(antechamber, TILE_HEALTH_PACK, map);  } if (!playerPlaced && rooms.length > 0 && rooms[0].center) { playerStartCell = { r: rooms[0].center.y, c: rooms[0].center.x }; } return { gameMap: map, playerStart: playerStartCell, bossSpawn: bossSpawnCell }; } else { let generationAttempts = 0; const MAX_GENERATION_ATTEMPTS = 25; let levelIsValid = false; while (!levelIsValid && generationAttempts < MAX_GENERATION_ATTEMPTS) { map = Array(rows).fill(null).map(() => Array(cols).fill(TILE_WALL)); rooms = []; const MIN_ROOM_SIZE = 5; const MAX_ROOM_SIZE = 11; const NUM_ROOMS_ATTEMPT = 30; const MIN_ROOMS_FOR_LOGIC = 6; playerStartCell = { r: Math.floor(rows/2), c: Math.floor(cols/2) }; for (let i = 0; i < NUM_ROOMS_ATTEMPT && rooms.length < NUM_ROOMS_ATTEMPT * 0.8; i++) { const roomWidth = MIN_ROOM_SIZE + Math.floor(Math.random() * (MAX_ROOM_SIZE - MIN_ROOM_SIZE + 1)); const roomHeight = MIN_ROOM_SIZE + Math.floor(Math.random() * (MAX_ROOM_SIZE - MIN_ROOM_SIZE + 1)); const roomX = Math.floor(Math.random() * (cols - roomWidth - 2)) + 1; const roomY = Math.floor(Math.random() * (rows - roomHeight - 2)) + 1; const newRoom = { x: roomX, y: roomY, width: roomWidth, height: roomHeight, connected: false, id: rooms.length, center: {x: roomX + Math.floor(roomWidth/2), y: roomY + Math.floor(roomHeight/2)} }; let overlaps = false; for (const existingRoom of rooms) { if (newRoom.x < existingRoom.x + existingRoom.width + 1 && newRoom.x + newRoom.width + 1 > existingRoom.x && newRoom.y < existingRoom.y + existingRoom.height + 1 && newRoom.y + newRoom.height + 1 > existingRoom.y) { overlaps = true; break; } } if (!overlaps) { rooms.push(newRoom); for (let r = newRoom.y; r < newRoom.y + newRoom.height; r++) { for (let c = newRoom.x; c < newRoom.x + newRoom.width; c++) { map[r][c] = TILE_EMPTY; } } } } if (rooms.length < MIN_ROOMS_FOR_LOGIC) { generationAttempts++; levelIsValid = false; continue;  } if (rooms.length > 0) { playerStartCell = { r: rooms[0].center.y, c: rooms[0].center.x }; actualPlayerStartRoom = rooms[0]; let connectedSet = new Set(); connectedSet.add(rooms[0].id); rooms[0].connected = true; while (connectedSet.size < rooms.length) { let closestDist = Infinity; let roomA = null, roomB = null; for (const rA of rooms) { if (!rA.connected) continue; for (const rB of rooms) { if (rB.connected) continue; const dist = Math.hypot(rA.center.x - rB.center.x, rA.center.y - rB.center.y); if (dist < closestDist) { closestDist = dist; roomA = rA; roomB = rB; } } } if (roomA && roomB) { let curX = roomA.center.x; let curY = roomA.center.y; while (curX !== roomB.center.x) { if (map[curY][curX] === TILE_WALL) map[curY][curX] = TILE_EMPTY; curX += Math.sign(roomB.center.x - curX); } if (map[curY][curX] === TILE_WALL) map[curY][curX] = TILE_EMPTY;  while (curY !== roomB.center.y) { if (map[curY][curX] === TILE_WALL) map[curY][curX] = TILE_EMPTY; curY += Math.sign(roomB.center.y - curY); } if (map[curY][curX] === TILE_WALL) map[curY][curX] = TILE_EMPTY;  roomB.connected = true; connectedSet.add(roomB.id); } else { break;  } } } let availableRoomsForItems = [...rooms]; function pickRoomForItem(mustBeDifferentFromRooms = []) { if (availableRoomsForItems.length === 0) return null; let pickedRoom = null; const playerStartRoomIdToAvoid = actualPlayerStartRoom ? actualPlayerStartRoom.id : -1; const validRoomsToPickFrom = availableRoomsForItems.filter(candidateRoom => { if (candidateRoom.id === playerStartRoomIdToAvoid) return false; for (const diffRoom of mustBeDifferentFromRooms) { if (diffRoom && candidateRoom.id === diffRoom.id) return false; } return true; }); if (validRoomsToPickFrom.length === 0) { const lessRestricted = availableRoomsForItems.filter(r => r.id !== playerStartRoomIdToAvoid); if (lessRestricted.length > 0) { pickedRoom = lessRestricted[Math.floor(Math.random() * lessRestricted.length)]; } else if (availableRoomsForItems.length > 0) { pickedRoom = availableRoomsForItems[Math.floor(Math.random() * availableRoomsForItems.length)]; } } else { pickedRoom = validRoomsToPickFrom[Math.floor(Math.random() * validRoomsToPickFrom.length)]; } if (pickedRoom) { availableRoomsForItems = availableRoomsForItems.filter(r => r.id !== pickedRoom.id); } return pickedRoom; } let exitRoomDetails = null; const roomsToAvoidForKeyItems = actualPlayerStartRoom ? [actualPlayerStartRoom] : []; const redKeyRoom = pickRoomForItem(roomsToAvoidForKeyItems); if (redKeyRoom) { placeItemInRandomEmptyTile(redKeyRoom, TILE_KEY_RED, map); roomsToAvoidForKeyItems.push(redKeyRoom); } const yellowKeyRoom = pickRoomForItem(roomsToAvoidForKeyItems); if (yellowKeyRoom) { placeItemInRandomEmptyTile(yellowKeyRoom, TILE_KEY_YELLOW, map); roomsToAvoidForKeyItems.push(yellowKeyRoom); } const blueKeyRoom = pickRoomForItem(roomsToAvoidForKeyItems); if (blueKeyRoom) { placeItemInRandomEmptyTile(blueKeyRoom, TILE_KEY_BLUE, map); roomsToAvoidForKeyItems.push(blueKeyRoom); } const exitRoom = pickRoomForItem(roomsToAvoidForKeyItems); if (exitRoom) { placeItemInRandomEmptyTile(exitRoom, TILE_EXIT, map); exitRoomDetails = exitRoom; roomsToAvoidForKeyItems.push(exitRoom); } const shotgunRoom = pickRoomForItem(roomsToAvoidForKeyItems);  if (shotgunRoom) placeItemInRandomEmptyTile(shotgunRoom, TILE_WEAPON_SHOTGUN, map); if (currentLevel > 3) { const rocketLauncherRoom = pickRoomForItem(roomsToAvoidForKeyItems); if (rocketLauncherRoom && (!player || !player.weapons.find(w => w.name === "Rocket Launcher" && w.owned))) { placeItemInRandomEmptyTile(rocketLauncherRoom, TILE_WEAPON_ROCKETLAUNCHER, map); } } if (currentLevel > 5) { const bfgRoom = pickRoomForItem(roomsToAvoidForKeyItems); if (bfgRoom && (!player || !player.weapons.find(w => w.name === "BFG" && w.owned))) { placeItemInRandomEmptyTile(bfgRoom, TILE_WEAPON_BFG, map); } } const machineGunRoom = pickRoomForItem(roomsToAvoidForKeyItems); if (machineGunRoom && (!player || !player.weapons.find(w => w.name === "Machine Gun" && w.owned))) { placeItemInRandomEmptyTile(machineGunRoom, TILE_WEAPON_MACHINEGUN, map); } function placeDoorGuardingRoom(targetRoom, doorType) { if (!targetRoom || !targetRoom.center) return false; const { x: roomX, y: roomY, width: roomW, height: roomH } = targetRoom; const potentialDoorLocations = []; for (let r = roomY - 1; r <= roomY + roomH; r++) { for (let c = roomX - 1; c <= roomX + roomW; c++) { if (r < 0 || r >= rows || c < 0 || c >= cols) continue; if (r >= roomY && r < roomY + roomH && c >= roomX && c < roomX + roomW) continue; if (map[r][c] === TILE_EMPTY) { let connectsToTargetInterior = false; let wallNeighborCount = 0; const directions = [[0,1], [0,-1], [1,0], [-1,0]]; for(const [dr, dc] of directions) { const nr = r + dr; const nc = c + dc; if(nr >=0 && nr < rows && nc >=0 && nc < cols) { if (nr >= roomY && nr < roomY + roomH && nc >= roomX && nc < roomX + roomW && map[nr][nc] === TILE_EMPTY) { connectsToTargetInterior = true;  } else if (map[nr][nc] === TILE_WALL) { wallNeighborCount++; } } else { wallNeighborCount++; } } if (connectsToTargetInterior && wallNeighborCount >= 2) { potentialDoorLocations.push({ r, c }); } } } } if (potentialDoorLocations.length > 0) { const doorLoc = potentialDoorLocations[Math.floor(Math.random() * potentialDoorLocations.length)]; map[doorLoc.r][doorLoc.c] = doorType; return true; } return false;  } if (yellowKeyRoom) placeDoorGuardingRoom(yellowKeyRoom, TILE_DOOR_RED); if (blueKeyRoom) placeDoorGuardingRoom(blueKeyRoom, TILE_DOOR_YELLOW); if (exitRoomDetails) placeDoorGuardingRoom(exitRoomDetails, TILE_DOOR_BLUE); levelIsValid = true; const pStartR = playerStartCell.r; const pStartC = playerStartCell.c; if (redKeyRoom && !findPath(pStartC, pStartR, redKeyRoom.center.x, redKeyRoom.center.y, map, {red:false, yellow:false, blue:false})) { levelIsValid = false; } if (levelIsValid && yellowKeyRoom && redKeyRoom && !findPath(redKeyRoom.center.x, redKeyRoom.center.y, yellowKeyRoom.center.x, yellowKeyRoom.center.y, map, {red:true, yellow:false, blue:false})) { levelIsValid = false; } if (levelIsValid && blueKeyRoom && yellowKeyRoom && !findPath(yellowKeyRoom.center.x, yellowKeyRoom.center.y, blueKeyRoom.center.x, blueKeyRoom.center.y, map, {red:true, yellow:true, blue:false})) { levelIsValid = false; } if (levelIsValid && exitRoomDetails && blueKeyRoom && !findPath(blueKeyRoom.center.x, blueKeyRoom.center.y, exitRoomDetails.center.x, exitRoomDetails.center.y, map, {red:true, yellow:true, blue:true})) { levelIsValid = false; } if (!redKeyRoom || !yellowKeyRoom || !blueKeyRoom || !exitRoomDetails) { levelIsValid = false; } generationAttempts++; }  const SECRET_ROOM_CHANCE = 0.25; const MIN_SECRET_ROOM_SIZE = 2; const MAX_SECRET_ROOM_SIZE = 3; for (const room of rooms) { if (room.id === actualPlayerStartRoom?.id) continue; if (Math.random() > SECRET_ROOM_CHANCE) { continue; } const potentialSides = []; if (room.y > MIN_SECRET_ROOM_SIZE) potentialSides.push(0); if (room.x + room.width < cols - MIN_SECRET_ROOM_SIZE -1) potentialSides.push(1); if (room.y + room.height < rows - MIN_SECRET_ROOM_SIZE -1) potentialSides.push(2); if (room.x > MIN_SECRET_ROOM_SIZE) potentialSides.push(3); if (potentialSides.length === 0) continue; potentialSides.sort(() => Math.random() - 0.5); for (const side of potentialSides) { const srWidth = MIN_SECRET_ROOM_SIZE + Math.floor(Math.random() * (MAX_SECRET_ROOM_SIZE - MIN_SECRET_ROOM_SIZE + 1)); const srHeight = MIN_SECRET_ROOM_SIZE + Math.floor(Math.random() * (MAX_SECRET_ROOM_SIZE - MIN_SECRET_ROOM_SIZE + 1)); let doorX = -1, doorY = -1; let srCarveX = -1, srCarveY = -1; let possibleDoorLocations = []; if (side === 0) { for (let c = room.x; c < room.x + room.width; c++) if (room.y - 1 > 0 && map[room.y - 1][c] === TILE_WALL) possibleDoorLocations.push({x:c, y:room.y - 1}); } else if (side === 1) { for (let r = room.y; r < room.y + room.height; r++) if (room.x + room.width < cols - 1 && map[r][room.x + room.width] === TILE_WALL) possibleDoorLocations.push({x:room.x + room.width, y:r}); } else if (side === 2) {  for (let c = room.x; c < room.x + room.width; c++) if (room.y + room.height < rows - 1 && map[room.y + room.height][c] === TILE_WALL) possibleDoorLocations.push({x:c, y:room.y + room.height}); } else { for (let r = room.y; r < room.y + room.height; r++) if (room.x - 1 > 0 && map[r][room.x - 1] === TILE_WALL) possibleDoorLocations.push({x:room.x - 1, y:r}); } if (possibleDoorLocations.length === 0) continue; const doorCand = possibleDoorLocations[Math.floor(Math.random() * possibleDoorLocations.length)]; doorX = doorCand.x; doorY = doorCand.y; if (side === 0) { srCarveY = doorY - srHeight; srCarveX = doorX - Math.floor(Math.random() * srWidth);  } else if (side === 1) { srCarveX = doorX + 1; srCarveY = doorY - Math.floor(Math.random() * srHeight); } else if (side === 2) { srCarveY = doorY + 1; srCarveX = doorX - Math.floor(Math.random() * srWidth); } else { srCarveX = doorX - srWidth; srCarveY = doorY - Math.floor(Math.random() * srHeight); } srCarveX = Math.max(1, Math.min(srCarveX, cols - 1 - srWidth)); srCarveY = Math.max(1, Math.min(srCarveY, rows - 1 - srHeight)); if (srCarveX + srWidth >= cols -1 || srCarveY + srHeight >= rows -1 ) continue; let footprintIsAllWalls = true; for (let r_sr = srCarveY; r_sr < srCarveY + srHeight; r_sr++) { for (let c_sr = srCarveX; c_sr < srCarveX + srWidth; c_sr++) { if (r_sr < 0 || r_sr >= rows || c_sr < 0 || c_sr >= cols || map[r_sr][c_sr] !== TILE_WALL) { footprintIsAllWalls = false; break; } } if (!footprintIsAllWalls) break; } if (doorY < 0 || doorY >= rows || doorX < 0 || doorX >= cols || map[doorY][doorX] !== TILE_WALL) footprintIsAllWalls = false; if (footprintIsAllWalls) { for (let r_sr = srCarveY; r_sr < srCarveY + srHeight; r_sr++) { for (let c_sr = srCarveX; c_sr < srCarveX + srWidth; c_sr++) { map[r_sr][c_sr] = TILE_EMPTY; } } map[doorY][doorX] = TILE_SECRET_DOOR; const secretRoomObj = { x: srCarveX, y: srCarveY, width: srWidth, height: srHeight }; let itemsPlacedInSecret = 0; const maxItemsInSecret = 1 + Math.floor(Math.random() * 2); if (Math.random() < 0.7 && itemsPlacedInSecret < maxItemsInSecret) { if(placeItemInRandomEmptyTile(secretRoomObj, TILE_HEALTH_PACK, map)) itemsPlacedInSecret++; } if (Math.random() < 0.5 && itemsPlacedInSecret < maxItemsInSecret) { const weaponPool = []; if (!player || !player.weapons.find(w => w.name === "Shotgun" && w.owned)) weaponPool.push(TILE_WEAPON_SHOTGUN); if (!player || !player.weapons.find(w => w.name === "Machine Gun" && w.owned)) weaponPool.push(TILE_WEAPON_MACHINEGUN); if (currentLevel > 2 && (!player || !player.weapons.find(w => w.name === "Rocket Launcher" && w.owned))) weaponPool.push(TILE_WEAPON_ROCKETLAUNCHER); if (currentLevel > 4 && (!player || !player.weapons.find(w => w.name === "BFG" && w.owned))) weaponPool.push(TILE_WEAPON_BFG); if (weaponPool.length > 0) { if(placeItemInRandomEmptyTile(secretRoomObj, weaponPool[Math.floor(Math.random() * weaponPool.length)], map)) itemsPlacedInSecret++; } } if (itemsPlacedInSecret === 0) { placeItemInRandomEmptyTile(secretRoomObj, TILE_HEALTH_PACK, map); } console.log(`Placed secret room at [${srCarveX},${srCarveY}] (size ${srWidth}x${srHeight}) for room ${room.id} via door at [${doorX},${doorY}]`); break;  } } } return { gameMap: map, playerStart: playerStartCell, bossSpawn: null };  } }
        
        class HealthPack { constructor(x, y) { this.x = x; this.y = y; this.radius = TILE_SIZE / 3; this.healthValue = 25; this.color = 'lime'; } draw() { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = 'white'; const cW = this.radius/2.5, cL = this.radius*1.2; ctx.fillRect(this.x - cW/2, this.y - cL/2, cW, cL); ctx.fillRect(this.x - cL/2, this.y - cW/2, cL, cW); } }
        class AmmoPack { constructor(x, y, weaponName, ammoAmount) { this.x = x; this.y = y; this.radius = TILE_SIZE / 3.5; this.weaponName = weaponName; this.ammoAmount = ammoAmount; this.color = '#AAAAAA'; this.char = '?'; if (weaponName === "Shotgun") { this.color = '#FFA500'; this.char = 'S'; } else if (weaponName === "Machine Gun") { this.color = '#ADD8E6'; this.char = 'M'; } else if (weaponName === "Rocket Launcher") { this.color = '#FF6347'; this.char = 'R'; } else if (weaponName === "BFG") { this.color = '#00DD00'; this.char = 'B'; } } draw() { ctx.fillStyle = this.color; ctx.beginPath(); ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); ctx.fill(); ctx.fillStyle = 'black'; ctx.font = `${this.radius * 1.5}px "Press Start 2P"`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.char, this.x, this.y + 2); } }

        class Player { constructor(x, y) { this.x = x; this.y = y; this.radius = TILE_SIZE / 3; this.speed = 3.5; this.health = 100; this.maxHealth = 100; this.angle = Math.PI / 2; this.keysCollected = { red: false, yellow: false, blue: false }; this.canPhase = false; this.weapons = []; for (const weaponKey in WEAPON_STATS) { const stats = WEAPON_STATS[weaponKey]; this.weapons.push({ ...stats, damage: stats.damage(), ammo: (stats.name === "Pistol" ? Infinity : 0), owned: (stats.name === "Pistol") }); } this.currentWeaponIndex = this.weapons.findIndex(w => w.name === "Pistol"); this.shootCooldown = 0; this.justFiredPistolOnThisClick = false; this.currentAnimFrame = 0; this.animTimer = 0; this.animSpeed = 8; this.isMoving = false; } getCurrentWeapon() { return this.weapons[this.currentWeaponIndex]; } addWeapon(weaponDataFromTile) { let weaponInstance = this.weapons.find(w => w.name === weaponDataFromTile.name); const evaluatedDamage = WEAPON_STATS[weaponDataFromTile.name].damage(); if (weaponInstance) { if (!weaponInstance.owned) { weaponInstance.owned = true; weaponInstance.ammo = weaponDataFromTile.pickupAmmo; playWeaponPickupSound(); } else if (weaponInstance.ammo !== Infinity) { weaponInstance.ammo = Math.min(weaponInstance.ammo + weaponDataFromTile.pickupAmmo, weaponInstance.maxAmmo); playAmmoPickupSound(); } weaponInstance.damage = evaluatedDamage; } else { console.error(`Player.addWeapon: Weapon ${weaponDataFromTile.name} was expected to be pre-initialized but not found.`); } updateWeaponUI(); } addAmmo(weaponName, amount) { const weapon = this.weapons.find(w => w.name === weaponName); if (weapon && weapon.ammo !== Infinity) { weapon.ammo = Math.min(weapon.ammo + amount, weapon.maxAmmo); playAmmoPickupSound(); updateWeaponUI(); } } switchWeapon(index) { if (index >= 0 && index < this.weapons.length && this.weapons[index].owned) { this.currentWeaponIndex = index; updateWeaponUI(); } } draw() { if (playerSpriteImage && playerSpriteImage.complete && playerSpriteImage.naturalHeight !== 0) { ctx.save(); ctx.translate(this.x, this.y); let frameDirection = playerFrames.down; const normalizedAngle = (this.angle + 2 * Math.PI) % (2 * Math.PI); if (normalizedAngle >= Math.PI * 0.25 && normalizedAngle < Math.PI * 0.75) { frameDirection = playerFrames.down; } else if (normalizedAngle >= Math.PI * 0.75 && normalizedAngle < Math.PI * 1.25) { frameDirection = playerFrames.left; } else if (normalizedAngle >= Math.PI * 1.25 && normalizedAngle < Math.PI * 1.75) { frameDirection = playerFrames.up; } else { frameDirection = playerFrames.right; } const frameToDraw = this.isMoving ? this.currentAnimFrame : 0; const sX = (frameDirection.x + frameToDraw) * PLAYER_SPRITE_FRAME_WIDTH; const sY = frameDirection.y * PLAYER_SPRITE_FRAME_HEIGHT; const dWidth = PLAYER_SPRITE_FRAME_WIDTH * PLAYER_SPRITE_SCALE; const dHeight = PLAYER_SPRITE_FRAME_HEIGHT * PLAYER_SPRITE_SCALE; ctx.drawImage( playerSpriteImage, sX, sY, PLAYER_SPRITE_FRAME_WIDTH, PLAYER_SPRITE_FRAME_HEIGHT, -dWidth / 2, -dHeight + this.radius, dWidth, dHeight ); ctx.restore(); } else { ctx.save(); ctx.translate(this.x, this.y); ctx.fillStyle = this.canPhase ? 'rgba(0, 123, 255, 0.5)' : '#007bff'; ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#555'; ctx.fillRect(this.radius * 0.8, -this.radius / 5, this.radius, this.radius / 2.5); ctx.restore(); } } update() { let moveX = 0; let moveY = 0; if (keys.w || keys.ArrowUp) moveY -= this.speed; if (keys.s || keys.ArrowDown) moveY += this.speed; if (keys.a || keys.ArrowLeft) moveX -= this.speed; if (keys.d || keys.ArrowRight) moveX += this.speed; this.isMoving = (moveX !== 0 || moveY !== 0); if (this.isMoving) { this.animTimer++; if (this.animTimer >= this.animSpeed) { this.currentAnimFrame = (this.currentAnimFrame + 1) % 3; this.animTimer = 0; } } else { this.currentAnimFrame = 0; this.animTimer = 0; } const worldMouseX = mouse.x + camera.x; const worldMouseY = mouse.y + camera.y; this.angle = Math.atan2(worldMouseY - this.y, worldMouseX - this.x); if (moveX !== 0 && moveY !== 0) { const factor = Math.sqrt(0.5); moveX *= factor; moveY *= factor; } const newX = this.x + moveX; const newY = this.y + moveY; const currentTileX = Math.floor(this.x / TILE_SIZE); const currentTileY = Math.floor(this.y / TILE_SIZE); let collisionX = false; let collisionY = false; const checkRadius = this.radius * 0.9; if (moveX !== 0) { const nextTileCenterX = Math.floor((this.x + moveX + Math.sign(moveX) * checkRadius) / TILE_SIZE); if (this.checkTileInteraction(nextTileCenterX, Math.floor((this.y - checkRadius) / TILE_SIZE)) || this.checkTileInteraction(nextTileCenterX, Math.floor((this.y + checkRadius) / TILE_SIZE)) || this.checkTileInteraction(nextTileCenterX, currentTileY) ) { collisionX = true; } } if (moveY !== 0) { const nextTileCenterY = Math.floor((this.y + moveY + Math.sign(moveY) * checkRadius) / TILE_SIZE); if (this.checkTileInteraction(Math.floor((this.x - checkRadius) / TILE_SIZE), nextTileCenterY) || this.checkTileInteraction(Math.floor((this.x + checkRadius) / TILE_SIZE), nextTileCenterY) || this.checkTileInteraction(currentTileX, nextTileCenterY) ) { collisionY = true; } } if (!collisionX) this.x += moveX; if (!collisionY) this.y += moveY; const weapon = this.getCurrentWeapon(); if (this.shootCooldown > 0) this.shootCooldown--; if (mouse.down && this.shootCooldown === 0) { if (weapon.singleShot) { if (!this.justFiredPistolOnThisClick) { this.shoot(); this.justFiredPistolOnThisClick = true; } } else { this.shoot(); } } if (!mouse.down) { this.justFiredPistolOnThisClick = false; } if (this.health <= 0) { gameOver = true; showGameOverScreen(); } } checkTileInteraction(tileX, tileY) { if (this.canPhase) return false; if (tileX < 0 || tileX >= MAP_COLS || tileY < 0 || tileY >= MAP_ROWS) return true; const tileType = gameMap[tileY][tileX]; switch (tileType) { case TILE_WALL: return true; case TILE_DOOR_RED: if (this.keysCollected.red) { gameMap[tileY][tileX] = TILE_EMPTY; playDoorOpenSound(); updateKeyUI(); updateVisibility(Math.floor(this.x / TILE_SIZE), Math.floor(this.y / TILE_SIZE), gameMap); renderStaticMapToCache(); return false; } return true; case TILE_DOOR_YELLOW: if (this.keysCollected.yellow) { gameMap[tileY][tileX] = TILE_EMPTY; playDoorOpenSound(); updateKeyUI(); updateVisibility(Math.floor(this.x / TILE_SIZE), Math.floor(this.y / TILE_SIZE), gameMap); renderStaticMapToCache(); return false; } return true; case TILE_DOOR_BLUE: if (this.keysCollected.blue) { gameMap[tileY][tileX] = TILE_EMPTY; playDoorOpenSound(); updateKeyUI(); updateVisibility(Math.floor(this.x / TILE_SIZE), Math.floor(this.y / TILE_SIZE), gameMap); renderStaticMapToCache(); return false; } return true; case TILE_KEY_RED: this.keysCollected.red = true; gameMap[tileY][tileX] = TILE_EMPTY; playKeyPickupSound(); updateKeyUI(); score += 50; scoreDisplay.textContent = score; renderStaticMapToCache(); return false; case TILE_KEY_YELLOW: this.keysCollected.yellow = true; gameMap[tileY][tileX] = TILE_EMPTY; playKeyPickupSound(); updateKeyUI(); score += 50; scoreDisplay.textContent = score; renderStaticMapToCache(); return false; case TILE_KEY_BLUE: this.keysCollected.blue = true; gameMap[tileY][tileX] = TILE_EMPTY; playKeyPickupSound(); updateKeyUI(); score += 50; scoreDisplay.textContent = score; renderStaticMapToCache(); return false; case TILE_EXIT: if (isCurrentLevelMiniBoss && currentBoss && currentBoss.health > 0) { console.log("Mini-boss alive, cannot exit."); return true;  } levelComplete(); return false; case TILE_WEAPON_SHOTGUN: this.addWeapon(WEAPON_STATS["Shotgun"]); gameMap[tileY][tileX] = TILE_EMPTY; renderStaticMapToCache(); return false; case TILE_WEAPON_MACHINEGUN: this.addWeapon(WEAPON_STATS["Machine Gun"]); gameMap[tileY][tileX] = TILE_EMPTY; renderStaticMapToCache(); return false; case TILE_WEAPON_ROCKETLAUNCHER: this.addWeapon(WEAPON_STATS["Rocket Launcher"]); gameMap[tileY][tileX] = TILE_EMPTY; renderStaticMapToCache(); return false; case TILE_WEAPON_BFG: this.addWeapon(WEAPON_STATS["BFG"]); gameMap[tileY][tileX] = TILE_EMPTY; renderStaticMapToCache(); return false; case TILE_HEALTH_PACK: if (player) player.gainHealth(25); gameMap[tileY][tileX] = TILE_EMPTY; renderStaticMapToCache(); return false; case TILE_SECRET_DOOR: gameMap[tileY][tileX] = TILE_EMPTY; playSecretDoorOpenSound(); updateVisibility(Math.floor(this.x / TILE_SIZE), Math.floor(this.y / TILE_SIZE), gameMap); score += 25; scoreDisplay.textContent = score; renderStaticMapToCache(); return false; case TILE_EMPTY: default: return false; } } 
            shoot() { 
                const weapon = this.getCurrentWeapon(); 
                if (!weapon.owned) { return; }
                if (weapon.ammo !== Infinity && weapon.ammo <= 0) { playEmptyGunSound(); this.shootCooldown = weapon.fireRate; if (this.currentWeaponIndex !== 0) { this.switchWeapon(0); if (mouse.down && this.getCurrentWeapon().singleShot && !this.justFiredPistolOnThisClick) { this.shoot(); this.justFiredPistolOnThisClick = true; } else if (mouse.down && !this.getCurrentWeapon().singleShot) { this.shoot(); } } return; } 
                playShootSound(weapon.name); this.shootCooldown = weapon.fireRate; if (weapon.ammo !== Infinity) { weapon.ammo--; } updateWeaponUI(); 
                const worldMouseX = mouse.x + camera.x; const worldMouseY = mouse.y + camera.y; const bulletAngle = Math.atan2(worldMouseY - this.y, worldMouseX - this.x); 
                for (let i = 0; i < weapon.numPellets; i++) { 
                    let currentBulletAngle = bulletAngle; 
                    if (weapon.spread > 0) { currentBulletAngle += (Math.random() - 0.5) * weapon.spread; } 
                    const bX = this.x + Math.cos(currentBulletAngle)*(this.radius+5); 
                    const bY = this.y + Math.sin(currentBulletAngle)*(this.radius+5); 
                    spawnBullet(bX, bY, currentBulletAngle, weapon.bulletSpeed, 'player', weapon.damage(), weapon.color, weapon.isRocket, weapon.aoeRadius, weapon.explosionDuration, weapon.isBFG, weapon.tracerDamage);
                } 
            } 
            takeDamage(amount) { if (this.canPhase) return; this.health -= amount; playPlayerHitSound(); if (this.health < 0) this.health = 0; healthDisplay.textContent = this.health; } 
            gainHealth(amount) { this.health += amount; if (this.health > this.maxHealth) this.health = this.maxHealth; healthDisplay.textContent = this.health; playHealthPickupSound(); } 
            collectAllKeys() { this.keysCollected.red = true; this.keysCollected.yellow = true; this.keysCollected.blue = true; updateKeyUI(); if (player) { updateVisibility(Math.floor(player.x / TILE_SIZE), Math.floor(player.y / TILE_SIZE), gameMap); renderStaticMapToCache();} } 
            collectAllGuns() { for (const weaponKey in WEAPON_STATS) { const stats = WEAPON_STATS[weaponKey]; let weaponInstance = this.weapons.find(w => w.name === stats.name); const evaluatedDamage = stats.damage(); if (weaponInstance) { weaponInstance.owned = true; weaponInstance.ammo = weaponInstance.maxAmmo; weaponInstance.damage = evaluatedDamage; } } playWeaponPickupSound(); updateWeaponUI(); console.log("CHEAT: All guns collected and max ammo given!"); } 
        }

        class Bullet {
            constructor(x,y,angle,speed,owner, damage, color = '#ffeb3b', isRocket = false, aoeRadius = 0, explosionDuration = 0, isBFG = false, tracerDamage = 0, isSeeking = false) {
                this.active = true; 
                this.init(x,y,angle,speed,owner, damage, color, isRocket, aoeRadius, explosionDuration, isBFG, tracerDamage, isSeeking);
            }

            init(x,y,angle,speed,owner, damage, color = '#ffeb3b', isRocket = false, aoeRadius = 0, explosionDuration = 0, isBFG = false, tracerDamage = 0, isSeeking = false) {
                this.x=x; this.y=y; this.angle = angle; this.initialSpeed = speed; 
                this.dx=Math.cos(angle)*speed; this.dy=Math.sin(angle)*speed; 
                this.owner=owner; this.damage = damage; 
                this.color = (owner === 'enemy' || owner === 'boss') ? '#ff6600' : color; 
                this.isRocket = isRocket; this.aoeRadius = aoeRadius; this.explosionDuration = explosionDuration; 
                this.isBFGMainProjectile = isBFG; this.tracerDamage = tracerDamage; 
                this.radius= (isRocket) ? 6 : (this.isBFGMainProjectile ? 12 : 4); 
                this.life= isRocket ? 180 : (this.isBFGMainProjectile ? 200 : 120); 
                this.isSeeking = isSeeking; 
                this.seekTarget = (isSeeking && (owner === 'boss' || owner === 'enemy') && player) ? player : null; 
                this.turnRate = 0.03;
                this.active = true;
            }

            draw() { if(!this.active) return; ctx.fillStyle = this.color; if (this.isRocket || this.isBFGMainProjectile) { ctx.save(); ctx.translate(this.x, this.y); if (this.isRocket || this.isSeeking) ctx.rotate(Math.atan2(this.dy, this.dx)); if (this.isBFGMainProjectile) { ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = 'rgba(200, 255, 200, 0.3)'; ctx.beginPath(); ctx.arc(0, 0, this.radius * 1.5, 0, Math.PI * 2); ctx.fill(); } else { ctx.beginPath(); ctx.moveTo(-this.radius, -this.radius / 2); ctx.lineTo(this.radius, 0); ctx.lineTo(-this.radius, this.radius / 2); ctx.closePath(); ctx.fill(); } ctx.restore(); } else { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); } } 
            update() { 
                if(!this.active) return;
                if (this.isSeeking && this.seekTarget && this.seekTarget.health > 0) { const targetAngle = Math.atan2(this.seekTarget.y - this.y, this.seekTarget.x - this.x); let currentAngle = Math.atan2(this.dy, this.dx); let angleDiff = targetAngle - currentAngle; while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI; while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI; if (Math.abs(angleDiff) > this.turnRate) { currentAngle += Math.sign(angleDiff) * this.turnRate; } else { currentAngle = targetAngle; } this.dx = Math.cos(currentAngle) * this.initialSpeed; this.dy = Math.sin(currentAngle) * this.initialSpeed; } 
                this.x+=this.dx; this.y+=this.dy; this.life--; 
                const tileX=Math.floor(this.x/TILE_SIZE); const tileY=Math.floor(this.y/TILE_SIZE); 
                let hitImpassableTile = false; if (tileX < 0 || tileX >= MAP_COLS || tileY < 0 || tileY >= MAP_ROWS || (gameMap[tileY] && ( gameMap[tileY][tileX] === TILE_WALL || gameMap[tileY][tileX] === TILE_DOOR_RED || gameMap[tileY][tileX] === TILE_DOOR_YELLOW || gameMap[tileY][tileX] === TILE_DOOR_BLUE || gameMap[tileY][tileX] === TILE_SECRET_DOOR ))) { hitImpassableTile = true; } 
                if (this.isBFGMainProjectile) { if (hitImpassableTile || this.life <= 0) { this.active = false; playBFGImpactSound(); if (player) { fireBFGTracers(player, enemies, null, this.tracerDamage); } return; } } else if (this.isRocket) { let rocketHitEnemy = false; if (this.owner === 'player') { const allTargets = currentBoss ? [currentBoss, ...enemies] : enemies; for (const target of allTargets) { if (target && target.health > 0 && Math.hypot(this.x - target.x, this.y - target.y) < this.radius + target.radius) { rocketHitEnemy = true; break; } } } if (hitImpassableTile || rocketHitEnemy || this.life <= 0) { this.active = false; explosions.push(new Explosion(this.x, this.y, this.aoeRadius, this.explosionDuration)); playRocketExplosionSound(); return; } } else { if (hitImpassableTile || this.life <= 0) { this.active = false; return; } } 
            } 
        }
        
        function spawnBullet(x,y,angle,speed,owner, damage, color, isRocket, aoeRadius, explosionDuration, isBFG, tracerDamage, isSeeking = false) {
            let bullet = bulletPool.find(b => !b.active);
            if (bullet) {
                bullet.init(x,y,angle,speed,owner, damage, color, isRocket, aoeRadius, explosionDuration, isBFG, tracerDamage, isSeeking);
                const poolIndex = bulletPool.indexOf(bullet); 
                if (poolIndex > -1) bulletPool.splice(poolIndex, 1); 
                bullets.push(bullet); 
            } else if (bullets.length < MAX_ACTIVE_BULLETS) {
                bullets.push(new Bullet(x,y,angle,speed,owner, damage, color, isRocket, aoeRadius, explosionDuration, isBFG, tracerDamage, isSeeking));
            }
        }

        function fireBFGTracers(playerOrigin, allTargets, directHitEnemy, tracerDamageValue) { if (!playerOrigin || !gameMap || !visibilityMap) return; const BFG_CONE_ANGLE = Math.PI / 1.5; const MAX_TRACER_TARGETS = 10; let tracerHitCount = 0; const potentialTargets = []; allTargets.forEach(enemy => { if (!enemy || enemy.health <= 0 || enemy === directHitEnemy) return; const enemyTileX = Math.floor(enemy.x / TILE_SIZE); const enemyTileY = Math.floor(enemy.y / TILE_SIZE); if (enemyTileY >= 0 && enemyTileY < MAP_ROWS && enemyTileX >=0 && enemyTileX < MAP_COLS && visibilityMap[enemyTileY][enemyTileX]) { const angleToEnemy = Math.atan2(enemy.y - playerOrigin.y, enemy.x - playerOrigin.x); const playerViewAngle = playerOrigin.angle; const normalizeAngle = (angle) => (angle % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI); const normalizedAngleToEnemy = normalizeAngle(angleToEnemy); const normalizedPlayerAngle = normalizeAngle(playerViewAngle); let angleDiff = Math.abs(normalizedPlayerAngle - normalizedAngleToEnemy); if (angleDiff > Math.PI) { angleDiff = 2 * Math.PI - angleDiff; } if (angleDiff <= BFG_CONE_ANGLE / 2) { if (isPathClear(playerOrigin.x, playerOrigin.y, enemy.x, enemy.y, gameMap)) { potentialTargets.push(enemy); } } } }); potentialTargets.sort((a, b) => { return Math.hypot(a.x - playerOrigin.x, a.y - playerOrigin.y) - Math.hypot(b.x - playerOrigin.x, b.y - playerOrigin.y); }); for (let i = 0; i < Math.min(potentialTargets.length, MAX_TRACER_TARGETS); i++) { const enemy = potentialTargets[i]; enemy.takeDamage(tracerDamageValue); temporaryVisualEffects.push({ type: 'bfg_tracer', startX: playerOrigin.x, startY: playerOrigin.y, endX: enemy.x, endY: enemy.y, life: 15, color: `rgba(0, 255, 0, ${0.5 + Math.random() * 0.3})` }); tracerHitCount++; } }
        class Explosion { constructor(x, y, radius, duration, color = 'orange') { this.x = x; this.y = y; this.maxRadius = radius; this.currentRadius = 0; this.duration = duration; this.life = duration; this.color = color; this.damageDealt = false; } update() { this.life--; this.currentRadius = this.maxRadius * (1 - (this.life / this.duration) * (this.life / this.duration) ); if (!this.damageDealt && this.life < this.duration * 0.8) { const targetsToDamage = currentBoss && currentBoss.health > 0 ? [currentBoss, ...enemies] : [...enemies]; targetsToDamage.forEach(target => { if (target && target.health > 0 && Math.hypot(target.x - this.x, target.y - this.y) < this.currentRadius) { if (target instanceof Boss || target instanceof MiniBoss) target.takeDamage(100); else target.takeDamage(75); } }); if (player && Math.hypot(player.x - this.x, player.y - this.y) < this.currentRadius) { player.takeDamage(35); } this.damageDealt = true; } } draw() { if (this.life <= 0) return; const opacity = Math.max(0, this.life / this.duration); ctx.fillStyle = `rgba(255, ${Math.floor(165 * opacity) + 60}, 0, ${opacity * 0.6})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.currentRadius, 0, Math.PI * 2); ctx.fill(); if (this.currentRadius > TILE_SIZE * 0.2) { ctx.fillStyle = `rgba(255, 255, ${Math.floor(150 * opacity) + 100}, ${opacity * 0.8})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.currentRadius * 0.5, 0, Math.PI * 2); ctx.fill(); } } }
        class Enemy { constructor(x, y, type = 'grunt') { this.x = x; this.y = y; this.enemyType = type; this.hitTimer = 0; this.state = 'wandering'; this.wanderTargetX = this.x; this.wanderTargetY = this.y; this.wanderTimer = 0; this.maxWanderTime = 120 + Math.floor(Math.random() * 60); this.detectionRadius = TILE_SIZE * 6; switch (type) { case 'rusher': this.radius = TILE_SIZE / 2.8; this.speed = (selectedDifficulty === 'easy' ? 1.0 : 1.5) + Math.random() * 0.5 + (currentLevel * 0.1); this.chaseSpeed = (selectedDifficulty === 'easy' ? 1.5 : 2.0) + Math.random() * 0.6 + (currentLevel * 0.15); this.health = 30 + currentLevel * 8; this.damage = 15 + currentLevel * 3; this.color = 'magenta'; this.canShoot = false; this.scoreValue = 120; break; case 'shooter': this.radius = TILE_SIZE / 2.5; this.speed = (0.7 + Math.random() * 0.3) + (currentLevel * 0.05); this.chaseSpeed = (0.9 + Math.random() * 0.4) + (currentLevel * 0.08); this.health = 40 + currentLevel * 10; this.damage = 8 + currentLevel * 2; this.color = `hsl(${220 + Math.random()*40}, 70%, 60%)`; this.canShoot = true; this.shootCooldown = 0; this.maxShootCooldown = 80 + Math.random() * 40; this.bulletSpeed = 6; this.bulletDamage = 7 + currentLevel * 1.5; this.detectionRadius = TILE_SIZE * 7; this.scoreValue = 150; break; case 'tank': this.radius = TILE_SIZE / 2; this.speed = (0.4 + Math.random() * 0.2) + (currentLevel * 0.03); this.chaseSpeed = (0.6 + Math.random() * 0.3) + (currentLevel * 0.05); this.health = 150 + currentLevel * 25; this.damage = 20 + currentLevel * 4; this.color = '#444444'; this.canShoot = false; this.detectionRadius = TILE_SIZE * 4.5; this.scoreValue = 250; break; case 'teleporter': this.radius = TILE_SIZE / 2.6; this.speed = 1.2 + Math.random() * 0.3 + (currentLevel * 0.06); this.chaseSpeed = 1.5 + Math.random() * 0.4 + (currentLevel * 0.08); this.health = 60 + currentLevel * 12; this.damage = 12 + currentLevel * 2.5; this.color = 'cyan'; this.canShoot = true; this.shootCooldown = 0; this.maxShootCooldown = 90 + Math.random() * 30; this.bulletSpeed = 7; this.bulletDamage = 8 + currentLevel * 1.8; this.teleportCooldown = 0; this.maxTeleportCooldown = 180 + Math.floor(Math.random() * 120); this.scoreValue = 180; break; case 'splitter': this.radius = TILE_SIZE / 2.2; this.speed = 0.6 + Math.random() * 0.2 + (currentLevel * 0.04); this.chaseSpeed = 0.8 + Math.random() * 0.3 + (currentLevel * 0.06); this.health = 100 + currentLevel * 20; this.damage = 18 + currentLevel * 3.5; this.color = 'darkorange'; this.canShoot = false; this.scoreValue = 200; break; case 'mini_splitter': this.radius = TILE_SIZE / 3.5; this.speed = 1.5 + Math.random() * 0.5 + (currentLevel * 0.1); this.chaseSpeed = 1.8 + Math.random() * 0.5 + (currentLevel * 0.12); this.health = 25 + currentLevel * 5; this.damage = 5 + currentLevel * 1; this.color = 'sandybrown'; this.canShoot = false; this.scoreValue = 50; break; case 'grunt': default: this.radius = TILE_SIZE / 2.5; this.speed = (0.8 + Math.random() * 0.4) + (currentLevel * 0.05); this.chaseSpeed = (1 + Math.random() * 0.5) + (currentLevel * 0.1); this.health = 50 + currentLevel * 10; this.damage = 10 + currentLevel * 2; this.color = `hsl(${Math.random() * 60}, 70%, 50%)`; this.canShoot = Math.random() < 0.15; this.shootCooldown = 0; this.maxShootCooldown = 100 + Math.random() * 50; this.bulletSpeed = 5; this.bulletDamage = 5 + currentLevel; this.scoreValue = 100; break; } this.maxHealth = this.health; } draw() { if (player && visibilityMap) { const enemyTileX = Math.floor(this.x / TILE_SIZE); const enemyTileY = Math.floor(this.y / TILE_SIZE); if (enemyTileY < 0 || enemyTileY >= MAP_ROWS || enemyTileX < 0 || enemyTileX >= MAP_COLS || !visibilityMap[enemyTileY][enemyTileX]) { return; } } ctx.fillStyle = this.hitTimer > 0 ? 'white' : this.color; ctx.beginPath(); if (this.enemyType === 'tank') { ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); } else if (this.enemyType === 'rusher' || this.enemyType === 'mini_splitter') { ctx.save(); ctx.translate(this.x, this.y); let angleToTarget = (this.state === 'wandering') ? Math.atan2(this.wanderTargetY - this.y, this.wanderTargetX - this.x) : Math.atan2(player.y - this.y, player.x - this.x); ctx.rotate(angleToTarget + Math.PI / 2); ctx.beginPath(); ctx.moveTo(0, -this.radius); ctx.lineTo(this.radius * 0.8, this.radius * 0.8); ctx.lineTo(-this.radius * 0.8, this.radius * 0.8); ctx.closePath(); ctx.fill(); ctx.restore(); } else { ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); } let targetX = player.x, targetY = player.y; if (this.state === 'wandering') { targetX = this.wanderTargetX; targetY = this.wanderTargetY; } const angleToTarget = Math.atan2(targetY - this.y, targetX - this.x); ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(this.x + Math.cos(angleToTarget) * this.radius * 0.5, this.y + Math.sin(angleToTarget) * this.radius * 0.5, this.radius * 0.2, 0, Math.PI * 2); ctx.fill(); if (this.health < this.maxHealth) { ctx.fillStyle = 'red'; ctx.fillRect(this.x - this.radius, this.y - this.radius - 10, this.radius * 2, 5); ctx.fillStyle = 'green'; ctx.fillRect(this.x - this.radius, this.y - this.radius - 10, (this.radius * 2) * (this.health / this.maxHealth), 5); } } 
            update(){ if(this.hitTimer>0) this.hitTimer--; if(!player) return; const dTP = Math.hypot(this.x - player.x, this.y - player.y); if (this.enemyType === 'teleporter') { this.teleportCooldown--; if (this.teleportCooldown <= 0 && dTP < this.detectionRadius * 2) { this.teleport(); this.teleportCooldown = this.maxTeleportCooldown; if (this.canShoot && this.shootCooldown === 0) { this.shoot(); this.shootCooldown = this.maxShootCooldown; } } } if (this.canShoot && dTP < this.detectionRadius * (this.enemyType === 'shooter' || this.enemyType === 'teleporter' ? 1.5 : 1.2) && dTP > TILE_SIZE * 1.5) { this.state = 'shooting'; } else if (dTP < this.detectionRadius) { this.state = 'chasing'; } else { if (this.state === 'chasing' || this.state === 'shooting') this.setNewWanderTarget(); this.state = 'wandering'; } if (this.shootCooldown > 0) this.shootCooldown--; let tX, tY, cS; if (this.state === 'shooting') { tX=player.x; tY=player.y; cS=this.speed*0.5; if(this.shootCooldown===0 && this.canShoot){this.shoot();this.shootCooldown=this.maxShootCooldown;} } else if (this.state === 'chasing') { tX=player.x; tY=player.y; cS=this.chaseSpeed; } else { this.wanderTimer--; if (this.wanderTimer <= 0 || Math.hypot(this.x-this.wanderTargetX,this.y-this.wanderTargetY)<TILE_SIZE/2) this.setNewWanderTarget(); tX=this.wanderTargetX;tY=this.wanderTargetY;cS=this.speed; } const aTT=Math.atan2(tY-this.y,tX-this.x),mX=Math.cos(aTT)*cS,mY=Math.sin(aTT)*cS,nX=this.x+mX,nY=this.y+mY; if (!this.checkWallCollision(nX,this.y))this.x=nX; if(!this.checkWallCollision(this.x,nY))this.y=nY; if (dTP < this.radius+player.radius) { player.takeDamage(this.damage); this.x-=Math.cos(aTT)*TILE_SIZE*0.5; this.y-=Math.sin(aTT)*TILE_SIZE*0.5; if(this.state==='wandering')this.state='chasing';} } 
            teleport() { playTeleportSound(); let newX, newY, validSpot = false; let attempts = 0; const teleportRadius = TILE_SIZE * 5; while (!validSpot && attempts < 20) { const angle = Math.random() * Math.PI * 2; const distance = TILE_SIZE * 2 + Math.random() * teleportRadius; newX = player.x + Math.cos(angle) * distance; newY = player.y + Math.sin(angle) * distance; newX = Math.max(this.radius, Math.min(newX, MAP_COLS * TILE_SIZE - this.radius)); newY = Math.max(this.radius, Math.min(newY, MAP_ROWS * TILE_SIZE - this.radius)); const tileX = Math.floor(newX / TILE_SIZE); const tileY = Math.floor(newY / TILE_SIZE); if (tileX >= 0 && tileX < MAP_COLS && tileY >= 0 && tileY < MAP_ROWS && gameMap[tileY][tileX] === TILE_EMPTY) { let tooCloseToOtherEnemy = false; for(const otherEnemy of enemies){ if(otherEnemy !== this && Math.hypot(newX - otherEnemy.x, newY - otherEnemy.y) < (this.radius + otherEnemy.radius) * 1.5){ tooCloseToOtherEnemy = true; break; } } if(!tooCloseToOtherEnemy) validSpot = true; } attempts++; } if (validSpot) { this.x = newX; this.y = newY; } } 
            shoot() { if (!player || !this.canShoot) return; playEnemyShootSound(); const aTP = Math.atan2(player.y-this.y,player.x-this.x); const inaccuracy = (Math.random()-0.5) * (this.enemyType === 'shooter' || this.enemyType === 'teleporter' ? 0.15 : 0.25); const bA=aTP+inaccuracy; const bX=this.x+Math.cos(bA)*(this.radius+5),bY=this.y+Math.sin(bA)*(this.radius+5); spawnBullet(bX,bY,bA,this.bulletSpeed,'enemy',this.bulletDamage); } 
            setNewWanderTarget() {
                let nTF = false;
                let att = 0;
                const MAX_A = 10; // Max random attempts
                const currentEnemyTileX = Math.floor(this.x / TILE_SIZE);
                const currentEnemyTileY = Math.floor(this.y / TILE_SIZE);

                // Initial random attempts
                while (!nTF && att < MAX_A) {
                    const wA = Math.random() * Math.PI * 2;
                    const wD = TILE_SIZE * (Math.random() * 3 + 2); // Wander 2-5 tiles away
                    let tTX = this.x + Math.cos(wA) * wD;
                    let tTY = this.y + Math.sin(wA) * wD;
                    tTX = Math.max(TILE_SIZE * 1.5, Math.min(tTX, (MAP_COLS * TILE_SIZE) - TILE_SIZE * 1.5));
                    tTY = Math.max(TILE_SIZE * 1.5, Math.min(tTY, (MAP_ROWS * TILE_SIZE) - TILE_SIZE * 1.5));
                    const tX = Math.floor(tTX / TILE_SIZE);
                    const tY = Math.floor(tTY / TILE_SIZE);

                    if (tX > 0 && tX < MAP_COLS - 1 && tY > 0 && tY < MAP_ROWS - 1 && gameMap[tY][tX] === TILE_EMPTY) {
                        this.wanderTargetX = tTX;
                        this.wanderTargetY = tTY;
                        nTF = true;
                    }
                    att++;
                }

                // If random attempts fail, try systematic search
                if (!nTF) {
                    const MAX_SEARCH_RADIUS = 5;
                    for (let searchRadius = 1; searchRadius <= MAX_SEARCH_RADIUS && !nTF; searchRadius++) {
                        for (let dX = -searchRadius; dX <= searchRadius && !nTF; dX++) {
                            for (let dY = -searchRadius; dY <= searchRadius && !nTF; dY++) {
                                if (dX === 0 && dY === 0) continue; // Skip current tile

                                const checkTileX = currentEnemyTileX + dX;
                                const checkTileY = currentEnemyTileY + dY;

                                if (checkTileX > 0 && checkTileX < MAP_COLS - 1 && 
                                    checkTileY > 0 && checkTileY < MAP_ROWS - 1 && 
                                    gameMap[checkTileY][checkTileX] === TILE_EMPTY) {
                                    this.wanderTargetX = checkTileX * TILE_SIZE + TILE_SIZE / 2;
                                    this.wanderTargetY = checkTileY * TILE_SIZE + TILE_SIZE / 2;
                                    nTF = true;
                                }
                            }
                        }
                    }
                }

                if (!nTF) { // Fallback if still no target found
                    this.wanderTargetX = Math.floor(this.x / TILE_SIZE) * TILE_SIZE + TILE_SIZE / 2;
                    this.wanderTargetY = Math.floor(this.y / TILE_SIZE) * TILE_SIZE + TILE_SIZE / 2;
                }
                this.wanderTimer = this.maxWanderTime;
            }
            checkWallCollision(cX,cY){ const co=[{x:Math.floor((cX-this.radius)/TILE_SIZE),y:Math.floor((cY-this.radius)/TILE_SIZE)},{x:Math.floor((cX+this.radius)/TILE_SIZE),y:Math.floor((cY-this.radius)/TILE_SIZE)},{x:Math.floor((cX-this.radius)/TILE_SIZE),y:Math.floor((cY+this.radius)/TILE_SIZE)},{x:Math.floor((cX+this.radius)/TILE_SIZE),y:Math.floor((cY+this.radius)/TILE_SIZE)}]; for(const t of co) { if(t.x<0||t.x>=MAP_COLS||t.y<0||t.y>=MAP_ROWS|| (gameMap[t.y] && (gameMap[t.y][t.x] === TILE_WALL || gameMap[t.y][t.x] === TILE_DOOR_RED || gameMap[t.y][t.x] === TILE_DOOR_YELLOW || gameMap[t.y][t.x] === TILE_DOOR_BLUE || gameMap[t.y][t.x] === TILE_SECRET_DOOR))) return true; } return false; }  
            takeDamage(amount){ this.health-=amount; this.hitTimer=5; playHitSound(); this.state = 'chasing'; if(this.health<=0){ score+= this.scoreValue; scoreDisplay.textContent=score; enemiesRemaining--; playEnemyDestroySound(); if(Math.random()<0.25){ const ammoTypes = ["Shotgun", "Machine Gun", "Rocket Launcher", "BFG"]; const selectedAmmoType = ammoTypes[Math.floor(Math.random()*ammoTypes.length)]; const weaponStats = WEAPON_STATS[selectedAmmoType]; if (weaponStats && weaponStats.maxAmmo !== Infinity) { let ammoDropAmount = Math.max(1, Math.floor(weaponStats.maxAmmo * 0.05)); ammoPacks.push(new AmmoPack(this.x, this.y, selectedAmmoType, ammoDropAmount)); } } else if(Math.random()<0.15) { healthPacks.push(new HealthPack(this.x,this.y)); } if (this.enemyType === 'splitter') { spawnMiniSplitters(this.x, this.y); } return true; } else { return false; } }
        }
        class MiniBoss extends Enemy { constructor(x, y) { super(x, y, 'grunt'); this.enemyType = 'mini_boss_rl_dropper'; this.radius = TILE_SIZE * 0.8; this.speed = 0.7; this.chaseSpeed = 1.0; this.health = 300 * (selectedDifficulty === 'easy' ? 0.8 : (selectedDifficulty === 'hard' ? 1.2 : 1)); this.maxHealth = this.health; this.damage = 20; this.color = '#AA00AA'; this.canShoot = true; this.shootCooldown = 0; this.maxShootCooldown = 90; this.bulletSpeed = 7; this.bulletDamage = 15; this.scoreValue = 400; this.droppedWeapon = false; } takeDamage(amount) { const killed = super.takeDamage(amount); if (killed && !this.droppedWeapon && player) { console.log("MiniBoss defeated, dropping Rocket Launcher!"); const rlStats = WEAPON_STATS["Rocket Launcher"]; let weaponInstance = player.weapons.find(w => w.name === "Rocket Launcher"); if (weaponInstance && !weaponInstance.owned) { player.addWeapon({ ...rlStats, name: "Rocket Launcher", owned: true, ammo: rlStats.pickupAmmo }); } else if (weaponInstance && weaponInstance.owned) { player.addAmmo("Rocket Launcher", rlStats.pickupAmmo); } else { player.addWeapon({ ...rlStats, name: "Rocket Launcher", owned: true, ammo: rlStats.pickupAmmo }); } this.droppedWeapon = true; } return killed; } }
        class Boss { constructor(x, y, level) { this.x = x; this.y = y; this.bossTier = Math.max(1, Math.floor(level / 5)); this.radius = TILE_SIZE * (0.8 + this.bossTier * 0.4); this.speed = 0.5 + this.bossTier * 0.1; this.maxHealth = 250 * Math.pow(1.8, this.bossTier -1) * (selectedDifficulty === 'easy' ? 0.7 : (selectedDifficulty === 'hard' ? 1.3 : 1)); this.health = this.maxHealth; this.damage = 25 + this.bossTier * 10; this.color = `hsl(${this.bossTier * 40}, 80%, 40%)`; this.hitTimer = 0; this.scoreValue = 500 * this.bossTier; this.state = 'moving'; this.moveTargetX = this.x; this.moveTargetY = this.y; this.moveTimer = 0; this.maxMoveTime = 150 - this.bossTier * 10; this.shootCooldown = 0; this.maxShootCooldown = Math.max(30, 100 - this.bossTier * 10); this.numProjectiles = 1 + Math.floor((this.bossTier-1) * 0.8); this.projectileSpread = 0.15 + this.bossTier * 0.05; this.bulletSpeed = 5 + this.bossTier * 0.5; this.bulletDamage = 15 + this.bossTier * 5; this.seekingShotCooldown = 0; this.maxSeekingShotCooldown = Math.max(120, 300 - this.bossTier * 30); this.canUseSeekingShot = this.bossTier >= 2; } draw() { ctx.fillStyle = this.hitTimer > 0 ? 'white' : this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); const angleToPlayer = player ? Math.atan2(player.y - this.y, player.x - this.x) : 0; ctx.fillStyle = 'black'; for (let i = -1; i <= 1; i += 2) { const eyeOffsetX = Math.cos(angleToPlayer + i * 0.5) * this.radius * 0.5; const eyeOffsetY = Math.sin(angleToPlayer + i * 0.5) * this.radius * 0.5; ctx.beginPath(); ctx.arc(this.x + eyeOffsetX, this.y + eyeOffsetY, this.radius * 0.15, 0, Math.PI * 2); ctx.fill(); } if (this.health < this.maxHealth) { const barWidth = VIEWPORT_WIDTH * 0.6; const barHeight = 20; const barX = camera.x + (VIEWPORT_WIDTH - barWidth) / 2; const barY = camera.y + VIEWPORT_HEIGHT - barHeight - 20; ctx.fillStyle = 'darkred'; ctx.fillRect(barX, barY, barWidth, barHeight); ctx.fillStyle = 'red'; ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight); ctx.strokeStyle = 'white'; ctx.strokeRect(barX, barY, barWidth, barHeight); ctx.fillStyle = 'white'; ctx.font = '12px "Press Start 2P"'; ctx.textAlign = 'center'; ctx.fillText(`BOSS HEALTH: ${Math.ceil(this.health)} / ${Math.ceil(this.maxHealth)}`, camera.x + VIEWPORT_WIDTH / 2, barY + barHeight / 2 + 4); } } 
            update() { if (this.hitTimer > 0) this.hitTimer--; if (!player) return; this.moveTimer--; if (this.moveTimer <= 0) { this.setNewMoveTarget(); } const angleToMoveTarget = Math.atan2(this.moveTargetY - this.y, this.moveTargetX - this.x); const moveX = Math.cos(angleToMoveTarget) * this.speed; const moveY = Math.sin(angleToMoveTarget) * this.speed; if (!this.checkWallCollision(this.x + moveX, this.y)) this.x += moveX; if (!this.checkWallCollision(this.x, this.y + moveY)) this.y += moveY; if (Math.hypot(this.x - player.x, this.y - player.y) < this.radius + player.radius) { player.takeDamage(this.damage); } this.shootCooldown--; if (this.shootCooldown <= 0) { this.shoot(); this.shootCooldown = this.maxShootCooldown; } if (this.canUseSeekingShot) { this.seekingShotCooldown--; if (this.seekingShotCooldown <= 0) { this.fireSeekingShot(); this.seekingShotCooldown = this.maxSeekingShotCooldown; } } } 
            fireSeekingShot() { if (!player) return; playBossSeekingShootSound(); const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x); spawnBullet( this.x, this.y, angleToPlayer, this.bulletSpeed * 0.7, 'boss', this.bulletDamage * 1.2, '#FF8800', false, 0, 0, false, 0, true ); } 
            shoot() { if (!player) return; playBossRegularShootSound(); const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x); for (let i = 0; i < this.numProjectiles; i++) { let currentBulletAngle = angleToPlayer; if (this.numProjectiles > 1) { currentBulletAngle += (i - (this.numProjectiles - 1) / 2) * this.projectileSpread / (this.numProjectiles -1 + 0.001) ; } const bulletX = this.x + Math.cos(currentBulletAngle) * (this.radius + 5); const bulletY = this.y + Math.sin(currentBulletAngle) * (this.radius + 5); spawnBullet(bulletX, bulletY, currentBulletAngle, this.bulletSpeed, 'boss', this.bulletDamage, '#FF33CC'); } } 
            setNewMoveTarget() { const attempts = 5; for (let i = 0; i < attempts; i++) { const angle = Math.random() * Math.PI * 2; const distance = TILE_SIZE * (Math.random() * 5 + 3); let targetX = this.x + Math.cos(angle) * distance; let targetY = this.y + Math.sin(angle) * distance; targetX = Math.max(this.radius, Math.min(targetX, MAP_COLS * TILE_SIZE - this.radius)); targetY = Math.max(this.radius, Math.min(targetY, MAP_ROWS * TILE_SIZE - this.radius)); const tileX = Math.floor(targetX / TILE_SIZE); const tileY = Math.floor(targetY / TILE_SIZE); if (tileX > 0 && tileX < MAP_COLS -1 && tileY > 0 && tileY < MAP_ROWS -1 && gameMap[tileY][tileX] === TILE_EMPTY) { if (isPathClear(this.x, this.y, targetX, targetY, gameMap, TILE_SIZE)) { this.moveTargetX = targetX; this.moveTargetY = targetY; this.moveTimer = this.maxMoveTime; return; } } } this.moveTargetX = player.x; this.moveTargetY = player.y; this.moveTimer = this.maxMoveTime / 2; } checkWallCollision(checkX, checkY) { const corners = [ { x: Math.floor((checkX - this.radius) / TILE_SIZE), y: Math.floor((checkY - this.radius) / TILE_SIZE) }, { x: Math.floor((checkX + this.radius) / TILE_SIZE), y: Math.floor((checkY - this.radius) / TILE_SIZE) }, { x: Math.floor((checkX - this.radius) / TILE_SIZE), y: Math.floor((checkY + this.radius) / TILE_SIZE) }, { x: Math.floor((checkX + this.radius) / TILE_SIZE), y: Math.floor((checkY + this.radius) / TILE_SIZE) }, ]; for (const tile of corners) { if (tile.x < 0 || tile.x >= MAP_COLS || tile.y < 0 || tile.y >= MAP_ROWS || (gameMap[tile.y] && (gameMap[tile.y][tile.x] === TILE_WALL || gameMap[tile.y][tile.x] === TILE_DOOR_RED || gameMap[tile.y][tile.x] === TILE_DOOR_YELLOW || gameMap[tile.y][tile.x] === TILE_DOOR_BLUE || gameMap[tile.y][tile.x] === TILE_SECRET_DOOR))) { return true; } } return false; }  
            takeDamage(amount) { this.health -= amount; this.hitTimer = 10; playBossHitSound(); if (this.health <= 0) { this.health = 0; score += this.scoreValue; scoreDisplay.textContent = score; playBossDeathSound(); enemiesRemaining--; return true; } return false; } 
        }
        
        function spawnMiniSplitters(x, y) { playSplitSound(); for (let i = 0; i < 2; i++) { let sX, sY, validSpawn = false; let attempts = 0; while(!validSpawn && attempts < 10) { sX = x + (Math.random() - 0.5) * TILE_SIZE; sY = y + (Math.random() - 0.5) * TILE_SIZE; const tileX = Math.floor(sX / TILE_SIZE); const tileY = Math.floor(sY / TILE_SIZE); if (tileX >= 0 && tileX < MAP_COLS && tileY >= 0 && tileY < MAP_ROWS && gameMap[tileY][tileX] === TILE_EMPTY) { validSpawn = true; } attempts++; } if (!validSpawn) { sX = x; sY = y; } enemies.push(new Enemy(sX,sY, 'mini_splitter')); enemiesRemaining++; } }

        function startGame() { 
            score = 0; currentLevel = 1; gameOver = false;
            nextMiniBossSpawnLevel = 0; 
            
            staticMapCanvas = document.createElement('canvas');
            staticMapCanvas.width = MAP_COLS * TILE_SIZE;
            staticMapCanvas.height = MAP_ROWS * TILE_SIZE;
            staticMapCtx = staticMapCanvas.getContext('2d');

            bulletPool = []; 
            for (let i = 0; i < MAX_BULLETS_IN_POOL; i++) {
                let bullet = new Bullet(0,0,0,0,'player',0,'white', false,0,0,false,0,false); 
                bullet.active = false; 
                bulletPool.push(bullet);
            }
            player = new Player((MAP_COLS * TILE_SIZE) / 2, (MAP_ROWS * TILE_SIZE) / 2);
            if (isNaN(player.x) || isNaN(player.y)) { player.x = VIEWPORT_WIDTH / 2; player.y = VIEWPORT_HEIGHT / 2; }
            initLevel(); 
        }

        function initLevel() { 
            isLevelCompleting = false; gameRunning = true; currentBoss = null; 
            isBossLevel = (currentLevel % 5 === 0); isCurrentLevelMiniBoss = false;
            if (!isBossLevel) { if (currentLevel === 3) { isCurrentLevelMiniBoss = true; nextMiniBossSpawnLevel = currentLevel + MINI_BOSS_SPAWN_INTERVAL_MIN + Math.floor(Math.random() * (MINI_BOSS_SPAWN_INTERVAL_MAX - MINI_BOSS_SPAWN_INTERVAL_MIN + 1)); } else if (currentLevel > 3) { if (nextMiniBossSpawnLevel === 0 || currentLevel >= nextMiniBossSpawnLevel ) { isCurrentLevelMiniBoss = true; nextMiniBossSpawnLevel = currentLevel + MINI_BOSS_SPAWN_INTERVAL_MIN + Math.floor(Math.random() * (MINI_BOSS_SPAWN_INTERVAL_MAX - MINI_BOSS_SPAWN_INTERVAL_MIN + 1)); } } }
            gameMap = Array(MAP_ROWS).fill(null).map(() => Array(MAP_COLS).fill(TILE_EMPTY));
            visibilityMap = Array(MAP_ROWS).fill(null).map(() => Array(MAP_COLS).fill(true)); 
            const mapData = generateMaze(MAP_COLS, MAP_ROWS, isBossLevel); gameMap = mapData.gameMap;
            
            allValidSpawnTiles = []; // Populate the list of all empty tiles
            for(let r = 0; r < MAP_ROWS; r++) {
                for(let c = 0; c < MAP_COLS; c++) {
                    if (gameMap[r][c] === TILE_EMPTY) {
                        allValidSpawnTiles.push({r, c});
                    }
                }
            }

            if (player) { player.x = mapData.playerStart.c * TILE_SIZE + TILE_SIZE/2; player.y = mapData.playerStart.r * TILE_SIZE + TILE_SIZE/2; if (!isBossLevel) { player.keysCollected = { red: false, yellow: false, blue: false }; } } else { showStartScreen(); return; }
            updateKeyUI(); updateWeaponUI(); 
            if (player && gameMap && gameMap.length > 0 && gameMap[0] && gameMap[0].length > 0) { 
                updateVisibility(Math.floor(player.x / TILE_SIZE), Math.floor(player.y / TILE_SIZE), gameMap); 
            } 
            renderStaticMapToCache(); 
            bullets = []; enemies = []; healthPacks = []; ammoPacks = []; explosions = []; temporaryVisualEffects = []; 
            if(player) camera.update(player); 
            scoreDisplay.textContent = score; waveDisplay.textContent = currentLevel; 
            resetLevelParameters(); 
            if (isBossLevel) { let bossSpawnX = mapData.bossSpawn ? mapData.bossSpawn.c * TILE_SIZE + TILE_SIZE / 2 : MAP_COLS / 2 * TILE_SIZE; let bossSpawnY = mapData.bossSpawn ? mapData.bossSpawn.r * TILE_SIZE + TILE_SIZE / 2 : MAP_ROWS / 2 * TILE_SIZE; currentBoss = new Boss(bossSpawnX, bossSpawnY, currentLevel); enemiesRemaining = 1;  } else { spawnInitialEnemies(); if (isCurrentLevelMiniBoss) { let exitTile = null; for (let r = 0; r < MAP_ROWS; r++) { for (let c = 0; c < MAP_COLS; c++) { if (gameMap[r][c] === TILE_EXIT) { exitTile = { r, c }; break; } } if (exitTile) break; } if (exitTile) { let miniBossSpawnX, miniBossSpawnY; let foundSpawn = false; const directions = [[0,0],[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1],[-2,0],[2,0],[0,-2],[0,2],[-2,-1],[-2,1],[2,-1],[2,1],[-1,-2],[1,-2],[-1,2],[1,2]]; directions.sort(() => Math.random() - 0.5); for(const [dr,dc] of directions) { const checkR = exitTile.r + dr; const checkC = exitTile.c + dc; if (checkR >= 0 && checkR < MAP_ROWS && checkC >= 0 && checkC < MAP_COLS && gameMap[checkR][checkC] === TILE_EMPTY) { const tempX = checkC * TILE_SIZE + TILE_SIZE / 2; const tempY = checkR * TILE_SIZE + TILE_SIZE / 2; if (player && Math.hypot(tempX - player.x, tempY - player.y) > TILE_SIZE * 4) { miniBossSpawnX = tempX; miniBossSpawnY = tempY; foundSpawn = true; break; } } } if (!foundSpawn) { if(gameMap[exitTile.r][exitTile.c] === TILE_EMPTY){ miniBossSpawnX = exitTile.c * TILE_SIZE + TILE_SIZE / 2; miniBossSpawnY = exitTile.r * TILE_SIZE + TILE_SIZE / 2; } else { let fallbackEmpty = null; for (let r_fb = MAP_ROWS -1; r_fb >=0 ; r_fb--) { for (let c_fb = MAP_COLS-1; c_fb >=0; c_fb--) { if (gameMap[r_fb][c_fb] === TILE_EMPTY && (player && Math.hypot((c_fb+0.5)*TILE_SIZE - player.x, (r_fb+0.5)*TILE_SIZE - player.y) > TILE_SIZE * 5) ) { fallbackEmpty = {r: r_fb, c: c_fb}; break; } } if(fallbackEmpty) break; } if(fallbackEmpty){ miniBossSpawnX = fallbackEmpty.c * TILE_SIZE + TILE_SIZE / 2; miniBossSpawnY = fallbackEmpty.r * TILE_SIZE + TILE_SIZE / 2; } else { miniBossSpawnX = (MAP_COLS / 2) * TILE_SIZE; miniBossSpawnY = (MAP_ROWS / 2) * TILE_SIZE; } } } currentBoss = new MiniBoss(miniBossSpawnX, miniBossSpawnY); enemiesRemaining++; } else { isCurrentLevelMiniBoss = false;  } } }
            if (gameLoopId) { cancelAnimationFrame(gameLoopId); }
            messageOverlay.style.display = 'none'; difficultySelectionDiv.style.display = 'flex'; 
            if (ctx) { draw(); }
            gameLoopId = requestAnimationFrame(gameLoop);
        }
        
        function findRoomsInMap(currentMap) { if (!currentMap || !currentMap.length || !currentMap[0] || !currentMap[0].length) { return []; } const visited = Array(MAP_ROWS).fill(null).map(() => Array(MAP_COLS).fill(false)); const foundRooms = []; function getRoomSize(r, c) { if (r < 0 || r >= MAP_ROWS || c < 0 || c >= MAP_COLS || visited[r][c] || !currentMap[r] || currentMap[r][c] !== TILE_EMPTY) { return null; } const queue = [[r,c]]; visited[r][c] = true; const roomTiles = []; let minR = r, maxR = r, minC = c, maxC = c; while(queue.length > 0) { const [currR, currC] = queue.shift(); roomTiles.push({r: currR, c: currC}); minR = Math.min(minR, currR); maxR = Math.max(maxR, currR); minC = Math.min(minC, currC); maxC = Math.max(maxC, currC); const dirs = [[0,1],[0,-1],[1,0],[-1,0]]; for(const [dr,dc] of dirs) { const nr = currR + dr; const nc = currC + dc; if (nr >= 0 && nr < MAP_ROWS && nc >= 0 && nc < MAP_COLS && !visited[nr][nc] && currentMap[nr] && currentMap[nr][nc] === TILE_EMPTY) { visited[nr][nc] = true; queue.push([nr, nc]); } } } if (roomTiles.length > 10) { return { x: minC, y: minR, width: maxC - minC + 1, height: maxR - minR + 1, center: { x: Math.floor((minC+maxC)/2) , y: Math.floor((minR+maxR)/2) } }; } return null; } for (let r_idx = 0; r_idx < MAP_ROWS; r_idx++) { for (let c_idx = 0; c_idx < MAP_COLS; c_idx++) { if (!visited[r_idx][c_idx] && currentMap[r_idx] && currentMap[r_idx][c_idx] === TILE_EMPTY) { const room = getRoomSize(r_idx,c_idx); if (room) foundRooms.push(room); } } } return foundRooms; }
        function resetLevelParameters() { if (isBossLevel) { enemiesToSpawnPerLevel = 0; } else { switch(selectedDifficulty) { case 'easy': enemiesToSpawnPerLevel = Math.floor((6 + (currentLevel - 1) * 2) * 1.5); break; case 'hard': enemiesToSpawnPerLevel = Math.floor((12 + (currentLevel - 1) * 4) * 1.5); break; case 'medium': default: enemiesToSpawnPerLevel = Math.floor((10 + (currentLevel - 1) * 3) * 1.5); break; } } enemiesSpawnedThisLevel = 0; enemiesRemaining = 0;  }
        
        function spawnInitialEnemies() { 
            if (isBossLevel) return; 
            let initialSpawnLocations = []; 
            if (player && gameMap && allValidSpawnTiles.length > 0) { 
                initialSpawnLocations = allValidSpawnTiles.filter(tile => {
                    const spawnX = tile.c * TILE_SIZE + TILE_SIZE / 2; 
                    const spawnY = tile.r * TILE_SIZE + TILE_SIZE / 2; 
                    return Math.hypot(spawnX - player.x, spawnY - player.y) > VIEWPORT_WIDTH / 3;
                });
            } 
            for(let i=0; i < enemiesToSpawnPerLevel; i++) { 
                spawnEnemy(initialSpawnLocations); // Pass the filtered list
            } 
        }

        function spawnEnemy(preFilteredLocations) { 
            if (!player) return; 
            let sX, sY, vS = false; 
            
            // Try pre-filtered locations first if available and not empty
            if (preFilteredLocations && preFilteredLocations.length > 0) {
                const spawnIndex = Math.floor(Math.random() * preFilteredLocations.length);
                const spawnPoint = preFilteredLocations.splice(spawnIndex, 1)[0]; // Remove to avoid reuse in this batch
                sX = spawnPoint.c * TILE_SIZE + TILE_SIZE / 2; 
                sY = spawnPoint.r * TILE_SIZE + TILE_SIZE / 2; 
                vS = true;
            } else if (allValidSpawnTiles.length > 0) { // Fallback to allValidSpawnTiles
                let shuffledSpawnTiles = [...allValidSpawnTiles].sort(() => 0.5 - Math.random()); // Shuffle a copy
                for (const tile of shuffledSpawnTiles) {
                    sX = tile.c * TILE_SIZE + TILE_SIZE / 2;
                    sY = tile.r * TILE_SIZE + TILE_SIZE / 2;
                    if (Math.hypot(sX - player.x, sY - player.y) > VIEWPORT_WIDTH / 3) {
                        vS = true;
                        break;
                    }
                }
                if (!vS && allValidSpawnTiles.length > 0) { // Last resort: pick first from non-shuffled if any exist
                    const tile = allValidSpawnTiles[0];
                     sX = tile.c * TILE_SIZE + TILE_SIZE / 2;
                     sY = tile.r * TILE_SIZE + TILE_SIZE / 2;
                     vS = true; // Spawn even if close
                }
            }

            if(vS){ 
                let enemyType = 'grunt'; const rand = Math.random(); 
                if (currentLevel > 1 && rand < 0.15) enemyType = 'rusher'; 
                else if (currentLevel > 2 && rand < 0.30) enemyType = 'shooter'; 
                else if (currentLevel > 3 && rand < 0.45 && selectedDifficulty !== 'easy') enemyType = 'tank'; 
                else if (currentLevel > 2 && rand < 0.60) enemyType = 'teleporter'; 
                else if (currentLevel > 3 && rand < 0.75 && selectedDifficulty !== 'easy') enemyType = 'splitter'; 
                enemies.push(new Enemy(sX,sY, enemyType)); 
                enemiesSpawnedThisLevel++; 
                enemiesRemaining++; 
            } 
        }
        
        function levelComplete() { if (isLevelCompleting) return; isLevelCompleting = true; gameRunning = false; if(gameLoopId) cancelAnimationFrame(gameLoopId); messageTitle.textContent = (isBossLevel || isCurrentLevelMiniBoss) ? "BOSS DEFEATED!" : "Level Cleared!"; messageText.innerHTML = `Level ${currentLevel} complete! Score: ${score} <br> Click 'Next Level' to continue.`; messageOverlay.style.display = 'flex'; restartButton.textContent = "Next Level"; difficultySelectionDiv.style.display = 'none'; instructionsButton.style.display = 'none'; }
        
        let frameCount = 0; 
        function gameLoop(){ frameCount++; if(!gameRunning || gameOver) { return; } try { update(); draw(); gameLoopId=requestAnimationFrame(gameLoop); } catch (e) { console.error("FATAL ERROR in gameLoop:", e, e.stack); gameRunning = false; messageTitle.textContent = "Critical Error!"; messageText.innerHTML = `A critical error occurred: ${e.message || JSON.stringify(e)}.<br>Check console for details. Restart required. Stack: ${e.stack || 'N/A'}`; messageOverlay.style.display = 'flex'; restartButton.textContent = "Restart Game"; } }
        function update(){
            try {
                if(!player) { console.error("update: Player is null, cannot update."); gameRunning = false; return; }
                const prevPlayerTileX = Math.floor(player.x / TILE_SIZE); const prevPlayerTileY = Math.floor(player.y / TILE_SIZE); 
                player.update(); camera.update(player); 
                const newPlayerTileX = Math.floor(player.x / TILE_SIZE); const newPlayerTileY = Math.floor(player.y / TILE_SIZE); 
                if (newPlayerTileX !== prevPlayerTileX || newPlayerTileY !== prevPlayerTileY) { 
                    if (player && gameMap && gameMap.length > 0 && gameMap[0] && gameMap[0].length > 0) {
                        updateVisibility(newPlayerTileX, newPlayerTileY, gameMap); 
                        renderStaticMapToCache(); 
                    }
                } 
                
                const activeBulletsThisFrame = [];
                for (let i = 0; i < bullets.length; i++) {
                    const b = bullets[i];
                    if (!b.active) { 
                        if (bulletPool.length < MAX_BULLETS_IN_POOL) { bulletPool.push(b); }
                        continue; 
                    }
                    b.update(); 
                    if (b.active) { 
                        activeBulletsThisFrame.push(b);
                    } else { 
                        if (bulletPool.length < MAX_BULLETS_IN_POOL) { bulletPool.push(b); }
                    }
                }
                bullets = activeBulletsThisFrame;

                explosions = explosions.filter(exp => exp.life > 0); explosions.forEach(exp => exp.update()); 
                temporaryVisualEffects = temporaryVisualEffects.filter(eff => eff.life > 0); temporaryVisualEffects.forEach(eff => eff.life--); 
                healthPacks.forEach((p, i) => { if(player && Math.hypot(player.x-p.x,player.y-p.y)<player.radius+p.radius){player.gainHealth(p.healthValue);healthPacks.splice(i,1); /* Items are dynamic, no re-cache on pickup */ }}); 
                ammoPacks.forEach((pack, i) => { if (player && Math.hypot(player.x - pack.x, player.y - pack.y) < player.radius + pack.radius) { player.addAmmo(pack.weaponName, pack.ammoAmount); ammoPacks.splice(i, 1); } });
                
                if (currentBoss) {
                    currentBoss.update();
                    if (currentBoss.health <= 0) { if (!isLevelCompleting) { levelComplete(); } currentBoss = null; } else { 
                        for (let i = bullets.length - 1; i >= 0; i--) { const b = bullets[i]; if (b.owner === 'player' && currentBoss && b.active && Math.hypot(b.x - currentBoss.x, b.y - currentBoss.y) < b.radius + currentBoss.radius) { if (b.isBFGMainProjectile) { currentBoss.takeDamage(b.damage); b.active = false; playBFGImpactSound(); if (player) fireBFGTracers(player, enemies, currentBoss, b.tracerDamage);  } else { currentBoss.takeDamage(b.damage); b.active = false; } } if (b.owner === 'boss' && player && b.active && Math.hypot(b.x - player.x, b.y - player.y) < b.radius + player.radius) { player.takeDamage(b.damage); b.active = false; } }
                    }
                }

                let activeEnemies = [...enemies]; enemies = []; 
                activeEnemies.forEach(e => { 
                    if (!e) { console.warn("Update: Found null/undefined enemy in currentEnemies array, skipping."); return; }
                    e.update(); 
                    let enemySurvived = true; 
                    for (let i = bullets.length - 1; i >= 0; i--) { const b = bullets[i]; if (b.owner === 'player' && b.active && Math.hypot(b.x - e.x, b.y - e.y) < b.radius + e.radius) { if (b.isBFGMainProjectile) { if (e.takeDamage(b.damage)) enemySurvived = false; b.active = false; playBFGImpactSound(); if (player) fireBFGTracers(player, activeEnemies.filter(en => en !== e), e, b.tracerDamage);  } else if (!b.isRocket) { if (e.takeDamage(b.damage)) enemySurvived = false; b.active = false;  } } if (b.owner === 'enemy' && player && b.active && Math.hypot(b.x - player.x, b.y - player.y) < b.radius + player.radius) { player.takeDamage(b.damage); b.active = false; } }
                    if (enemySurvived && e.health > 0) { enemies.push(e); } 
                }); 

                if (!isBossLevel && !isCurrentLevelMiniBoss && enemiesRemaining <= 0 && enemiesSpawnedThisLevel >= enemiesToSpawnPerLevel) { if (!isLevelCompleting) { let exitTileExists = false; for (let r_ex = 0; r_ex < MAP_ROWS; r_ex++) { for (let c_ex = 0; c_ex < MAP_COLS; c_ex++) { if (gameMap[r_ex][c_ex] === TILE_EXIT) { exitTileExists = true; break; } } if(exitTileExists) break; } if(exitTileExists) levelComplete(); else console.log("All regular enemies cleared, but no exit tile found on map."); } }
            } catch (e) { console.error("Error in update function:", e, e.stack); gameRunning = false; messageTitle.textContent = "Update Error!"; messageText.innerHTML = `An error occurred in update: ${e.message || JSON.stringify(e)}.<br>Check console. Stack: ${e.stack || 'N/A'}`; messageOverlay.style.display = 'flex'; }
        }

        function renderStaticMapToCache() {
            if (!staticMapCtx || !gameMap || !visibilityMap) {
                console.error("Static map canvas or map data not ready for caching.");
                return;
            }
            staticMapCtx.fillStyle = '#202020'; 
            staticMapCtx.fillRect(0, 0, staticMapCanvas.width, staticMapCanvas.height);

            currentWallStyle = wallStyles[(currentLevel -1) % wallStyles.length]; 

            for (let r = 0; r < MAP_ROWS; r++) {
                for (let c = 0; c < MAP_COLS; c++) {
                    const tileType = gameMap[r][c];
                    const tileIsVisible = visibilityMap[r][c]; 

                    if (tileIsVisible) { 
                        let tileColor = null;
                        if (tileType === TILE_EMPTY) {
                            staticMapCtx.fillStyle = '#444'; 
                            staticMapCtx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        } else if (tileType === TILE_WALL) {
                            tileColor = currentWallStyle.fillColor;
                            staticMapCtx.fillStyle = tileColor;
                            staticMapCtx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            staticMapCtx.strokeStyle = currentWallStyle.borderColor;
                            staticMapCtx.strokeRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            if (currentWallStyle.pattern) {
                                currentWallStyle.pattern(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, staticMapCtx);
                            }
                        } else if (tileType === TILE_DOOR_RED) {
                            tileColor = 'darkred';
                            staticMapCtx.fillStyle = tileColor;
                            staticMapCtx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            staticMapCtx.strokeStyle = '#444'; staticMapCtx.strokeRect(c*TILE_SIZE, r*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        } else if (tileType === TILE_DOOR_YELLOW) {
                            tileColor = 'goldenrod';
                            staticMapCtx.fillStyle = tileColor;
                            staticMapCtx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            staticMapCtx.strokeStyle = '#444'; staticMapCtx.strokeRect(c*TILE_SIZE, r*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        } else if (tileType === TILE_DOOR_BLUE) {
                            tileColor = 'darkblue';
                            staticMapCtx.fillStyle = tileColor;
                            staticMapCtx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            staticMapCtx.strokeStyle = '#444'; staticMapCtx.strokeRect(c*TILE_SIZE, r*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        } else if (tileType === TILE_SECRET_DOOR) { 
                            tileColor = currentWallStyle.fillColor;
                            staticMapCtx.fillStyle = tileColor;
                            staticMapCtx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            staticMapCtx.strokeStyle = currentWallStyle.borderColor;
                            staticMapCtx.strokeRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                             if (currentWallStyle.pattern) { 
                                currentWallStyle.pattern(c*TILE_SIZE, r*TILE_SIZE, TILE_SIZE, staticMapCtx); 
                            }
                            staticMapCtx.fillStyle = 'rgba(0,0,0,0.15)'; 
                            staticMapCtx.fillRect(c * TILE_SIZE + TILE_SIZE * 0.15, r * TILE_SIZE + TILE_SIZE * 0.15, TILE_SIZE * 0.7, TILE_SIZE * 0.7);
                        }
                    }
                }
            }
            console.log("Static map elements cached.");
        }


        function draw(){ 
            try {
                ctx.fillStyle='#333'; ctx.fillRect(0,0,VIEWPORT_WIDTH,VIEWPORT_HEIGHT); 
                
                if (isNaN(camera.x) || isNaN(camera.y)) {
                    console.error("DRAW: Camera coordinates are NaN before translate. x:", camera.x, "y:", camera.y, "Not translating.");
                } else {
                    ctx.save(); 
                    ctx.translate(-camera.x, -camera.y);
                }

                if (staticMapCanvas) {
                    ctx.drawImage(
                        staticMapCanvas,
                        camera.x, camera.y,          
                        camera.width, camera.height,  
                        camera.x, camera.y,           
                        camera.width, camera.height   
                    );
                }

                const sC=Math.floor(camera.x/TILE_SIZE),eC=Math.min(sC+Math.ceil(camera.width/TILE_SIZE)+1,MAP_COLS);
                const sR=Math.floor(camera.y/TILE_SIZE),eR=Math.min(sR+Math.ceil(camera.height/TILE_SIZE)+1,MAP_ROWS);

                if (!gameMap || !visibilityMap) { console.error("DRAW: gameMap or visibilityMap is not initialized!"); if(ctx.getTransform && !(isNaN(camera.x) || isNaN(camera.y))) ctx.restore();  return; } 
                
                for(let r=sR;r<eR;r++){ 
                    for(let c=sC;c<eC;c++){ 
                        if(!gameMap[r] || gameMap[r][c] === undefined || !visibilityMap[r] || visibilityMap[r][c] === undefined) { continue; } 
                        const tileIsVisible = visibilityMap[r][c]; 
                        const tileType = gameMap[r][c]; 
                        let tileColor = null; 
                        if (tileIsVisible) { 
                            if (tileType === TILE_KEY_RED || tileType === TILE_KEY_YELLOW || tileType === TILE_KEY_BLUE ||
                                tileType === TILE_WEAPON_SHOTGUN || tileType === TILE_WEAPON_MACHINEGUN ||
                                tileType === TILE_WEAPON_ROCKETLAUNCHER || tileType === TILE_WEAPON_BFG ||
                                tileType === TILE_HEALTH_PACK) { 
                                switch(tileType) { 
                                    case TILE_KEY_RED: tileColor = 'red'; break; 
                                    case TILE_KEY_YELLOW: tileColor = 'yellow'; break; 
                                    case TILE_KEY_BLUE: tileColor = 'blue'; break; 
                                    case TILE_WEAPON_SHOTGUN: tileColor = '#FFA500'; break; 
                                    case TILE_WEAPON_MACHINEGUN: tileColor = '#ADD8E6'; break; 
                                    case TILE_WEAPON_ROCKETLAUNCHER: tileColor = '#FF4500'; break; 
                                    case TILE_WEAPON_BFG: tileColor = '#00DD00'; break; 
                                    case TILE_HEALTH_PACK: tileColor = 'lime'; break;
                                } 
                                if (tileColor) { 
                                    ctx.fillStyle = tileColor; 
                                    ctx.fillRect(c*TILE_SIZE, r*TILE_SIZE, TILE_SIZE, TILE_SIZE); 
                                    let itemText = null; let itemTextColor = 'white'; 
                                    if (tileType >= TILE_KEY_RED && tileType <= TILE_KEY_BLUE) itemText = "K"; 
                                    else if (tileType === TILE_WEAPON_SHOTGUN) {itemText = "SG"; itemTextColor = 'black';} 
                                    else if (tileType === TILE_WEAPON_MACHINEGUN) {itemText = "MG"; itemTextColor = 'black';} 
                                    else if (tileType === TILE_WEAPON_ROCKETLAUNCHER) {itemText = "RL"; itemTextColor = 'black';} 
                                    else if (tileType === TILE_WEAPON_BFG) {itemText = "BFG"; itemTextColor = 'black';} 
                                    else if (tileType === TILE_HEALTH_PACK) {itemText = "H"; itemTextColor = 'black';} 
                                    if(itemText) { ctx.fillStyle = itemTextColor; ctx.font = `${TILE_SIZE* (itemText.length > 2 ? 0.4 : 0.6)}px "Press Start 2P"`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(itemText, c*TILE_SIZE + TILE_SIZE/2, r*TILE_SIZE + TILE_SIZE/2 + 2); } 
                                } 
                            } else if (tileType === TILE_EXIT) {
                                tileColor = 'purple';
                                ctx.fillStyle = tileColor;
                                ctx.fillRect(c*TILE_SIZE, r*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                                let itemText = "E";
                                let itemTextColor = 'white';
                                if (isCurrentLevelMiniBoss && currentBoss && currentBoss.health > 0) {
                                    ctx.fillStyle = 'rgba(255, 0, 0, 0.7)'; 
                                    ctx.font = `${TILE_SIZE * 0.8}px "Press Start 2P"`; 
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';
                                    ctx.fillText("X", c * TILE_SIZE + TILE_SIZE / 2, r * TILE_SIZE + TILE_SIZE / 2 + 2);
                                } else {
                                    ctx.fillStyle = itemTextColor;
                                    ctx.font = `${TILE_SIZE * 0.6}px "Press Start 2P"`;
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';
                                    ctx.fillText(itemText, c * TILE_SIZE + TILE_SIZE / 2, r * TILE_SIZE + TILE_SIZE / 2 + 2);
                                }
                            }
                        } 
                    } 
                }

                if (visibilityMap && visibilityMap.length > 0) { 
                    healthPacks.forEach(p => { const packTileY = Math.floor(p.y/TILE_SIZE); const packTileX = Math.floor(p.x/TILE_SIZE); if(visibilityMap[packTileY] && visibilityMap[packTileY][packTileX]) { p.draw(); } }); 
                    ammoPacks.forEach(pack => { const packTileY = Math.floor(pack.y / TILE_SIZE); const packTileX = Math.floor(pack.x / TILE_SIZE); if (visibilityMap[packTileY] && visibilityMap[packTileY][packTileX]) { pack.draw(); } });
                }
                
                if ((isBossLevel || isCurrentLevelMiniBoss) && currentBoss) { currentBoss.draw(); } 
                enemies.forEach(e => e.draw()); 
                if (player) player.draw(); 
                bullets.forEach(b => b.draw()); 
                explosions.forEach(exp => exp.draw()); 
                temporaryVisualEffects.forEach(effect => { if (effect.type === 'bfg_tracer' && effect.life > 0) { ctx.strokeStyle = effect.color; ctx.lineWidth = 2 + (effect.life / 5); ctx.beginPath(); ctx.moveTo(effect.startX, effect.startY); ctx.lineTo(effect.endX, effect.endY); ctx.stroke(); } }); 

                if (!(isNaN(camera.x) || isNaN(camera.y))) { 
                    ctx.restore();
                }
            } catch (e) { console.error("Error in draw function:", e, e.stack); gameRunning = false; messageTitle.textContent = "Draw Error!"; messageText.innerHTML = `An error occurred in draw: ${e.message || JSON.stringify(e)}.<br>Check console. Stack: ${e.stack || 'N/A'}`; messageOverlay.style.display = 'flex'; }
        }
        
        function drawMetalPattern(x, y, size, context) { context.fillStyle = 'rgba(200, 200, 200, 0.5)'; const rivetSize = size / 10; const offset = size / 8; context.beginPath(); context.arc(x + offset, y + offset, rivetSize, 0, Math.PI * 2); context.fill(); context.beginPath(); context.arc(x + size - offset, y + offset, rivetSize, 0, Math.PI * 2); context.fill(); context.beginPath(); context.arc(x + offset, y + size - offset, rivetSize, 0, Math.PI * 2); context.fill(); context.beginPath(); context.arc(x + size - offset, y + size - offset, rivetSize, 0, Math.PI * 2); context.fill(); }
        function drawStonePattern(x, y, size, context) { context.strokeStyle = 'rgba(0, 0, 0, 0.2)'; context.lineWidth = 1; for (let i = 0; i < 2; i++) { context.beginPath(); context.moveTo(x + Math.random() * size, y + Math.random() * size); context.lineTo(x + Math.random() * size, y + Math.random() * size); context.stroke(); } }

        function updateKeyUI() { if(player && player.keysCollected) { redKeyIcon.classList.toggle('collected', player.keysCollected.red); yellowKeyIcon.classList.toggle('collected', player.keysCollected.yellow); blueKeyIcon.classList.toggle('collected', player.keysCollected.blue); } }
        function updateWeaponUI() { if (player && weaponInventoryIcons) { const currentWeapon = player.getCurrentWeapon(); const invIcons = weaponInventoryIcons.querySelectorAll('.weapon-icon-display'); invIcons.forEach(icon => { const weaponName = icon.dataset.weaponName; const weaponInInventory = player.weapons.find(w => w.name === weaponName); const ammoTextSpan = icon.querySelector('.ammo-text-display'); if (weaponInInventory) { icon.classList.toggle('owned', weaponInInventory.owned); if (ammoTextSpan) { if (weaponInInventory.ammo === Infinity) { ammoTextSpan.textContent = "Inf"; } else if (weaponInInventory.ammo >= 0 || weaponInInventory.owned) { ammoTextSpan.textContent = `${weaponInInventory.ammo}`; } else { ammoTextSpan.textContent = "--"; } } if (currentWeapon && currentWeapon.name === weaponName && weaponInInventory.owned) { icon.classList.add('selected-weapon-icon'); } else { icon.classList.remove('selected-weapon-icon'); } } else { icon.classList.remove('owned'); icon.classList.remove('selected-weapon-icon'); if (ammoTextSpan) ammoTextSpan.textContent = "--"; } }); } }

        function showGameOverScreen() { gameOver = true; gameRunning = false; messageTitle.textContent = "Game Over!"; messageText.textContent = `You survived ${currentLevel} levels. Final Score: ${score}`; restartButton.textContent = "Restart Game"; difficultySelectionDiv.style.display = 'flex'; instructionsButton.style.display = 'block'; messageOverlay.style.display = 'flex'; if (gameLoopId) cancelAnimationFrame(gameLoopId); } 
        function showStartScreen() { gameOver = false; gameRunning = false; messageTitle.textContent = "Top-Down Doom-Like Game"; messageText.innerHTML = ""; restartButton.textContent = "Start Game"; difficultySelectionDiv.style.display = 'flex'; instructionsButton.style.display = 'block'; messageOverlay.style.display = 'flex'; }
        function showInstructions() { instructionsTextContent.innerHTML = `<strong>Objective:</strong> Find keys, open doors, and reach the Exit!<br> A Mini-Boss guards the exit on Level 3, and randomly on later levels (not main boss levels). <br> Main Bosses appear every 5 levels!<br> Look for subtly different wall tiles to find secret rooms!<br><br> <strong>Movement:</strong> Arrow Keys or WASD<br> <strong>Aim:</strong> Mouse<br> <strong>Shoot:</strong> Click<br> <strong>Switch Weapon:</strong> Keys 1, 2, 3, 4, 5<br> (Pistol, Shotgun, Machine Gun, Rocket Launcher, BFG respectively)<br><br> <strong>Pickups:</strong><br> <span style="color:lime;">Green Cross:</span> Health Pack<br> <span style="color:red;">Red/</span><span style="color:yellow;">Yellow/</span><span style="color:blue;">Blue Squares:</span> Keys<br> <span style="color:purple;">Purple Square:</span> Level Exit (may be locked!)<br> <span style="color:#FFA500;">SG</span>/<span style="color:#ADD8E6;">MG</span>/<span style="color:#FF4500;">RL</span>/<span style="color:#00DD00;">BFG</span>: Weapon Pickups<br> <span style="color:#AAAAAA;">Grey Boxes (S,M,R,B):</span> Ammo Pickups<br><br> <strong>Cheats (for testing):</strong><br> I - Toggle Invincibility/Phasing<br> K - Collect All Keys<br> G - Collect All Guns & Max Ammo<br> L - Complete Level (skip to next) `; instructionsOverlay.style.display = 'flex'; }
        function hideInstructions() { instructionsOverlay.style.display = 'none'; }

        difficultyButtons.forEach(button => { button.addEventListener('click', () => { difficultyButtons.forEach(btn => btn.classList.remove('selected')); button.classList.add('selected'); selectedDifficulty = button.dataset.difficulty; }); });
        window.addEventListener('keydown', (e) => { const keyName = e.key.toLowerCase(); if (keys.hasOwnProperty(e.key)) keys[e.key] = true; else if (keys.hasOwnProperty(keyName)) keys[keyName] = true; if (gameRunning && player) { if (keyName === 'i' && !keys.i_cheat_processed) { keys.i_cheat_processed = true; player.canPhase = !player.canPhase; } else if (keyName === 'k' && !keys.k_cheat_processed) { keys.k_cheat_processed = true; player.collectAllKeys(); } else if (keyName === 'g' && !keys.g_cheat_processed) { keys.g_cheat_processed = true; player.collectAllGuns(); } else if (keyName === 'l' && !keys.l_cheat_processed) { keys.l_cheat_processed = true; levelComplete(); } } if (gameRunning && player) { if (keyName === '1' && !keys.weapon_1_processed) { player.switchWeapon(0); keys.weapon_1_processed = true; } else if (keyName === '2' && !keys.weapon_2_processed) { const idx = player.weapons.findIndex(w=>w.name==="Shotgun"); if(idx!==-1 && player.weapons[idx].owned) player.switchWeapon(idx); keys.weapon_2_processed = true; } else if (keyName === '3' && !keys.weapon_3_processed) { const idx = player.weapons.findIndex(w=>w.name==="Machine Gun"); if(idx!==-1 && player.weapons[idx].owned)player.switchWeapon(idx); keys.weapon_3_processed = true; } else if (keyName === '4' && !keys.weapon_4_processed) { const idx = player.weapons.findIndex(w=>w.name==="Rocket Launcher"); if(idx!==-1 && player.weapons[idx].owned)player.switchWeapon(idx); keys.weapon_4_processed = true; } else if (keyName === '5' && !keys.weapon_5_processed) { const idx = player.weapons.findIndex(w=>w.name==="BFG"); if(idx!==-1 && player.weapons[idx].owned)player.switchWeapon(idx); keys.weapon_5_processed = true; } } });
        window.addEventListener('keyup', (e) => { const keyName = e.key.toLowerCase(); if (keys.hasOwnProperty(e.key)) keys[e.key] = false; else if (keys.hasOwnProperty(keyName)) keys[keyName] = false; if (keyName === 'i') keys.i_cheat_processed = false; else if (keyName === 'k') keys.k_cheat_processed = false; else if (keyName === 'g') keys.g_cheat_processed = false; else if (keyName === 'l') keys.l_cheat_processed = false; if (keyName === '1') keys.weapon_1_processed = false; if (keyName === '2') keys.weapon_2_processed = false; if (keyName === '3') keys.weapon_3_processed = false; if (keyName === '4') keys.weapon_4_processed = false; if (keyName === '5') keys.weapon_5_processed = false; });
        canvas.addEventListener('mousemove', (e)=>{ const r=canvas.getBoundingClientRect();mouse.x=e.clientX-r.left;mouse.y=e.clientY-r.top;});
        canvas.addEventListener('mousedown', (e)=>{if(e.button===0){ensureAudioAndSynths();mouse.down=true;}}); 
        canvas.addEventListener('mouseup', (e)=>{if(e.button===0)mouse.down=false;});
        canvas.addEventListener('contextmenu', (e)=>e.preventDefault()); 
        restartButton.addEventListener('click', () => { ensureAudioAndSynths(); messageOverlay.style.display = 'none'; const buttonText = restartButton.textContent.trim(); if (buttonText === "Start Game") { startGame(); } else if (gameOver || buttonText === "Restart Game") { startGame(); } else if (buttonText === "Next Level") { currentLevel++; initLevel(); } else { console.error("DEBUG: Button text NOT RECOGNIZED:", `"${buttonText}"`, "gameOver:", gameOver); } });
        instructionsButton.addEventListener('click', showInstructions);
        closeInstructionsButton.addEventListener('click', hideInstructions);
        playerSpriteImage.onload = () => { console.log("Player sprite loaded successfully."); showStartScreen(); };
        playerSpriteImage.onerror = () => { console.error("Player sprite failed to load. Using fallback drawing."); showStartScreen(); }
        if (playerSpriteImage.complete && playerSpriteImage.naturalHeight !== 0) { showStartScreen(); } else if (playerSpriteImage.complete && playerSpriteImage.naturalHeight === 0) { console.error("Player sprite reported complete but has no dimensions (likely failed to load)."); showStartScreen(); }
        console.log("SCRIPT END: Event listeners attached, game ready for user interaction.");
    </script>
</body>
</html>
