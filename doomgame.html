<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Top-Down Doom-like</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        #gameContainer {
            border: 4px solid #4a4a4a;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            position: relative; /* Important for absolute positioning of uiContainer */
            background-color: #2a2a2a;
            width: 800px; 
            height: 600px; 
        }
        canvas {
            display: block;
            background-color: #333; /* Default canvas background */
            cursor: crosshair;
        }
        #topUiContainer {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 800px; /* Match gameContainer width */
            padding: 5px 10px;
            font-size: 16px; 
            color: #cccccc;
            box-sizing: border-box;
            margin-bottom: 5px; 
        }
        #uiContainer { /* Bottom UI bar */
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center; 
            padding: 8px 15px; 
            font-size: 14px; 
            color: #cccccc; 
            background-color: rgba(0, 0, 0, 0.75); 
            box-sizing: border-box;
            z-index: 5; 
        }
        #healthDisplayContainer, #scoreDisplayContainer, #levelDisplayContainer {
             color: #ff4136; 
        }
        #keysDisplayContainer {
            display: flex;
            align-items: center;
            gap: 8px;
             color: #ff4136;
        }
        #keysDisplay { 
            display: flex;
            gap: 5px; 
        }
        .key-icon {
            width: 18px; 
            height: 18px;
            border: 1px solid #888;
            border-radius: 3px;
            display: inline-block;
            opacity: 0.3; 
        }
        .key-icon.red { background-color: red; }
        .key-icon.yellow { background-color: yellow; }
        .key-icon.blue { background-color: blue; }
        .key-icon.collected { opacity: 1; }
        
        #weaponInfoContainer { 
            display: flex;
            align-items: center;
            gap: 10px; 
        }
        
        #weaponInventoryIcons {
            display: flex;
            gap: 6px; 
            align-items: center;
            font-size: 14px; 
        }
        #weaponInventoryIcons > span:first-child { /* "Weapons:" label */
             color: #00ff00;
        }
        .weapon-icon-display {
            border: 1px solid #555;
            padding: 3px 5px;
            border-radius: 4px;
            font-size: 12px;
            opacity: 0.4;
            color: #888; 
            display: flex; 
            align-items: center;
            gap: 4px;
            min-width: 50px; 
            justify-content: center;
        }
        .weapon-icon-display .weapon-char {
            font-weight: bold;
        }
        .weapon-icon-display .ammo-text-display {
            font-size: 10px;
        }
        .weapon-icon-display.owned { /* Indicates the player has the weapon */
            opacity: 0.7; 
            border-color: #00aa00;
            color: #00aa00;
        }
        .weapon-icon-display.selected-weapon-icon { /* Indicates currently selected AND owned */
            opacity: 1;
            border-color: #00ff00; 
            color: #00ff00;
            box-shadow: 0 0 8px #00ff00;
            transform: scale(1.05);
        }

        #messageOverlay, #instructionsOverlay { /* Common styles for overlays */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85); 
            display: none; /* Initially hidden */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: white;
            z-index: 10;
            padding: 20px;
            box-sizing: border-box;
        }
        #messageOverlay h2 {
            font-size: 36px;
            color: #ff4136;
            margin-bottom: 15px; /* Adjusted margin */
        }
        #messageOverlay p {
            margin-bottom: 20px; 
            font-size: 20px; /* Adjusted for cleaner look if empty */
            min-height: 20px; /* Ensure space even if empty */
        }
        #difficultySelection {
            margin-bottom: 25px; /* Adjusted margin */
            display: flex;
            gap: 15px;
        }
         .game-button, .difficulty-button { 
            font-family: 'Press Start 2P', cursive;
            color: white;
            border-width: 2px;
            border-style: solid;
            padding: 10px 20px; 
            font-size: 16px; 
            cursor: pointer;
            text-transform: uppercase;
            transition: background-color 0.3s, transform 0.1s;
            margin-top: 10px; /* Added margin for spacing */
        }
        .game-button { 
            background-color: #c00;
            border-color: #800;
            box-shadow: 0 4px #500;
            padding: 15px 30px; 
            font-size: 18px;  
        }
        .game-button:hover { background-color: #e00; }
        .game-button:active { background-color: #a00; transform: translateY(2px); box-shadow: 0 2px #500; }

        .difficulty-button {
            background-color: #555;
            border-color: #333;
            box-shadow: 0 3px #222;
        }
        .difficulty-button:hover { background-color: #777; }
        .difficulty-button:active { background-color: #444; transform: translateY(1px); box-shadow: 0 2px #222; }
        .difficulty-button.selected {
            background-color: #ff4136; 
            border-color: #c00;
            box-shadow: 0 3px #800;
        }

        /* Styles for the new Instructions Overlay */
        #instructionsOverlay {
            background-color: rgba(0, 0, 0, 0.92); /* Slightly more opaque */
            z-index: 20; /* Ensure it's on top if messageOverlay is somehow visible */
        }
        #instructionsOverlay h2 {
            font-size: 30px;
            color: #00bcd4; /* Cyan color for instructions title */
            margin-bottom: 20px;
        }
        #instructionsOverlay #instructionsTextContent {
            margin-bottom: 25px;
            text-align: left;
            max-width: 600px;
            line-height: 1.7;
            font-size: 14px; /* Smaller for more text */
            max-height: 70vh; /* Make it scrollable if too long */
            overflow-y: auto;
            padding: 15px;
            border: 1px solid #444;
            border-radius: 8px;
            background-color: rgba(20,20,20,0.5);
        }
        #instructionsOverlay .game-button { /* For the close button */
            background-color: #007bff; /* Blue close button */
            border-color: #0056b3;
            box-shadow: 0 4px #003f7f;
        }
        #instructionsOverlay .game-button:hover { background-color: #009cff; }
        #instructionsOverlay .game-button:active { background-color: #0056b3; transform: translateY(2px); box-shadow: 0 2px #003f7f;}

    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">
    <div id="topUiContainer">
        <div id="scoreDisplayContainer">Score: <span id="scoreDisplay">0</span></div>
        <div id="levelDisplayContainer">Level: <span id="waveDisplay">1</span></div>
    </div>

    <div id="gameContainer" class="rounded-lg overflow-hidden shadow-2xl">
        <canvas id="gameCanvas"></canvas>
        <div id="uiContainer">
            <div id="healthDisplayContainer">Health: <span id="healthDisplay">100</span></div>
            
            <div id="weaponInfoContainer">
                <div id="weaponInventoryIcons">
                    <span class="text-gray-400 mr-1">Weapons:</span>
                    <span class="weapon-icon-display" data-weapon-name="Pistol" id="pistolIconDisplay">
                        <span class="weapon-char">P</span> <span class="ammo-text-display">Inf</span>
                    </span>
                    <span class="weapon-icon-display" data-weapon-name="Shotgun" id="shotgunIconDisplay">
                        <span class="weapon-char">S</span> <span class="ammo-text-display">--</span>
                    </span>
                    <span class="weapon-icon-display" data-weapon-name="Machine Gun" id="machineGunIconDisplay">
                        <span class="weapon-char">M</span> <span class="ammo-text-display">--</span>
                    </span>
                    <span class="weapon-icon-display" data-weapon-name="Rocket Launcher" id="rocketLauncherIconDisplay">
                        <span class="weapon-char">R</span> <span class="ammo-text-display">--</span>
                    </span>
                    <span class="weapon-icon-display" data-weapon-name="BFG" id="bfgIconDisplay"> <span class="weapon-char">B</span> <span class="ammo-text-display">--</span>
                    </span>
                </div>
            </div>

            <div id="keysDisplayContainer">
                <span class="text-gray-400">Keys:</span>
                <div id="keysDisplay">
                    <span class="key-icon red" id="redKeyIcon"></span>
                    <span class="key-icon yellow" id="yellowKeyIcon"></span>
                    <span class="key-icon blue" id="blueKeyIcon"></span>
                </div>
            </div>
        </div>
        <div id="messageOverlay" style="display: none;"> 
            <h2 id="messageTitle">Game Over</h2>
            <p id="messageText">Your score: 0</p>
            <div id="difficultySelection">
                <button class="difficulty-button" data-difficulty="easy">Easy</button>
                <button class="difficulty-button selected" data-difficulty="medium">Medium</button>
                <button class="difficulty-button" data-difficulty="hard">Hard</button>
            </div>
            <button id="restartButton" class="game-button">Restart Game</button>
            <button id="instructionsButton" class="game-button" style="margin-top: 15px; background-color: #555; border-color: #333; box-shadow: 0 4px #222;">Instructions</button>
        </div>

        <div id="instructionsOverlay" style="display: none;">
            <h2>Instructions</h2>
            <div id="instructionsTextContent">
                </div>
            <button id="closeInstructionsButton" class="game-button">Close</button>
        </div>
    </div>
    
    <img id="playerSprite" src="https://jeffhockema.com/sprites/military1.png" style="display: none;" alt="Player Sprite" crossorigin="anonymous">

    <script>
        console.log("SCRIPT START: Top-Down Doom-like game script initiated.");

        // Audio initialization
        async function initializeAudio() {
            try {
                if (Tone.context.state === 'suspended') {
                    await Tone.start();
                    console.log("AudioContext started successfully.");
                }
            } catch (e) {
                console.warn("Warning during initial Tone.start():", e);
            }
        }
        initializeAudio(); 

        // DOM Elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const healthDisplay = document.getElementById('healthDisplay');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const waveDisplay = document.getElementById('waveDisplay'); 
        const weaponInventoryIcons = document.getElementById('weaponInventoryIcons');
        const messageOverlay = document.getElementById('messageOverlay');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');
        // const controlsInfo = document.getElementById('controlsInfo'); // This element is removed
        const redKeyIcon = document.getElementById('redKeyIcon');
        const yellowKeyIcon = document.getElementById('yellowKeyIcon');
        const blueKeyIcon = document.getElementById('blueKeyIcon');
        const difficultySelectionDiv = document.getElementById('difficultySelection');
        const difficultyButtons = document.querySelectorAll('.difficulty-button');
        const playerSpriteImage = document.getElementById('playerSprite'); 

        // New DOM elements for Instructions Modal
        const instructionsButton = document.getElementById('instructionsButton');
        const instructionsOverlay = document.getElementById('instructionsOverlay');
        const instructionsTextContent = document.getElementById('instructionsTextContent');
        const closeInstructionsButton = document.getElementById('closeInstructionsButton');


        // Game Constants
        const TILE_SIZE = 40;
        const MAP_COLS = 50; 
        const MAP_ROWS = 40; 

        const VIEWPORT_WIDTH = 800; 
        const VIEWPORT_HEIGHT = 600; 
        canvas.width = VIEWPORT_WIDTH;
        canvas.height = VIEWPORT_HEIGHT;

        // Player Sprite Constants
        const PLAYER_SPRITE_FRAME_WIDTH = 26;
        const PLAYER_SPRITE_FRAME_HEIGHT = 36;
        const PLAYER_SPRITE_SCALE = 1.2; 

        const playerFrames = { 
            down:  { x: 3, y: 0 }, 
            left:  { x: 3, y: 1 },  
            right: { x: 3, y: 2 }, 
            up:    { x: 3, y: 3 },    
        };
        
        const camera = {
            x: 0, y: 0,
            width: VIEWPORT_WIDTH, height: VIEWPORT_HEIGHT,
            update: function(target) { 
                if (!target) {
                    return;
                }
                
                let targetX = target.x;
                let targetY = target.y;

                if (isNaN(targetX) || isNaN(targetY)) {
                    console.warn(`Camera target position is NaN (x: ${targetX}, y: ${targetY}). Defaulting target to center for camera calculation.`);
                    targetX = (MAP_COLS * TILE_SIZE) / 2;
                    targetY = (MAP_ROWS * TILE_SIZE) / 2;
                }

                this.x = Math.max(0, Math.min(targetX - this.width / 2, (MAP_COLS * TILE_SIZE) - this.width));
                this.y = Math.max(0, Math.min(targetY - this.height / 2, (MAP_ROWS * TILE_SIZE) - this.height));

                if (isNaN(this.x) || isNaN(this.y)) {
                    console.error(`Camera position became NaN (calculated x: ${this.x}, y: ${this.y}). Resetting to 0,0.`);
                    this.x = 0;
                    this.y = 0;
                }
            }
        };

        // Tile Types
        const TILE_EMPTY = 0;
        const TILE_WALL = 1;
        const TILE_DOOR_RED = 2;
        const TILE_DOOR_YELLOW = 3;
        const TILE_DOOR_BLUE = 4;
        const TILE_KEY_RED = 5;
        const TILE_KEY_YELLOW = 6;
        const TILE_KEY_BLUE = 7;
        const TILE_EXIT = 8;
        const TILE_WEAPON_SHOTGUN = 9;
        const TILE_WEAPON_MACHINEGUN = 10;
        const TILE_WEAPON_ROCKETLAUNCHER = 11;
        const TILE_WEAPON_BFG = 12; 
        const TILE_HEALTH_PACK = 13; 
        const TILE_SECRET_DOOR = 14; // New tile type for secret doors


        // Wall Styles
        const wallStyles = [
            { name: "Classic Grey", fillColor: '#5a5a5a', borderColor: '#444444' },
            { name: "Industrial Metal", fillColor: '#787A7C', borderColor: '#555759', pattern: drawMetalPattern }, 
            { name: "Ancient Stone", fillColor: '#6F6659', borderColor: '#504A40', pattern: drawStonePattern },  
            { name: "Mossy Dungeon", fillColor: '#4A5D43', borderColor: '#384831' }, 
            { name: "Crimson Hell", fillColor: '#7D2828', borderColor: '#5A1D1D' }   
        ];
        let currentWallStyle = wallStyles[0]; 

        // Game State Variables
        let player; 
        let bullets, enemies, gameMap, healthPacks, ammoPacks, visibilityMap, explosions, temporaryVisualEffects; 
        let currentBoss = null; 
        let isBossLevel = false; // For main bosses (level % 5 === 0)
        let isCurrentLevelMiniBoss = false; // For mini-bosses (level 3, and then randomly)
        let nextMiniBossSpawnLevel = 0; // Tracks when the next random mini-boss might spawn
        const MINI_BOSS_SPAWN_INTERVAL_MIN = 2; 
        const MINI_BOSS_SPAWN_INTERVAL_MAX = 3; 

        let score = 0;
        let currentLevel = 1; 
        let gameOver = false;
        let gameRunning = false; 
        let enemiesToSpawnPerLevel = 10; 
        let enemiesSpawnedThisLevel = 0; 
        let enemiesRemaining = 0;
        let gameLoopId;
        let selectedDifficulty = 'medium'; 
        let isLevelCompleting = false;

        const WEAPON_STATS = {
            "Pistol": { name: "Pistol", damage: () => 25 + currentLevel * 2, fireRate: 10, bulletSpeed: 10, spread: 0, numPellets: 1, color: '#ffeb3b', singleShot: true, ammo: Infinity, maxAmmo: Infinity, pickupAmmo: 0 },
            "Shotgun": { name: "Shotgun", damage: () => 15 + currentLevel, fireRate: 25, bulletSpeed: 8, spread: 0.3, numPellets: 6, color: '#FFA500', singleShot: false, ammo: 0, maxAmmo: 30, pickupAmmo: 10 },
            "Machine Gun": { name: "Machine Gun", damage: () => 8 + currentLevel * 0.5, fireRate: 4, bulletSpeed: 12, spread: 0.1, numPellets: 1, color: '#ADD8E6', singleShot: false, ammo: 0, maxAmmo: 150, pickupAmmo: 50 },
            "Rocket Launcher": { name: "Rocket Launcher", damage: () => 50, fireRate: 60, bulletSpeed: 5, spread: 0, numPellets: 1, color: '#FF6347', singleShot: true, ammo: 0, maxAmmo: 10, pickupAmmo: 3, aoeRadius: TILE_SIZE * 2.5, explosionDuration: 30, isRocket: true },
            "BFG": { name: "BFG", damage: () => 200, tracerDamage: 50, fireRate: 150, bulletSpeed: 4, spread: 0, numPellets: 1, color: '#00FF00', singleShot: true, ammo: 0, maxAmmo: 5, pickupAmmo: 1, isBFG: true }
        };


        const keys = { 
            ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
            w: false, s: false, a: false, d: false,
            '1': false, '2': false, '3': false, '4': false, '5': false, 
            i_cheat_processed: false, 
            k_cheat_processed: false,
            g_cheat_processed: false,
            l_cheat_processed: false, 
            weapon_1_processed: false, 
            weapon_2_processed: false,
            weapon_3_processed: false,
            weapon_4_processed: false,
            weapon_5_processed: false 
        };
        const mouse = { x: VIEWPORT_WIDTH / 2, y: VIEWPORT_HEIGHT / 2, down: false }; 

        // Audio Synths
        let synth, metalSynth, hitSynth, explosionSynth, rocketFireSynth, bfgFireSynth, bossHitSynth, bossDeathSynth, bossRegularShootSynth, bossSeekingShootSynth, ammoPickupSynth, secretDoorOpenSynth; 
        let lastHitSoundTime = 0; 
        const HIT_SOUND_COOLDOWN = 50; 
        let lastEnemyDestroySoundTime = 0; 
        const ENEMY_DESTROY_SOUND_COOLDOWN = 100; 

        function setupSynths() {
            try {
                synth = new Tone.Synth().toDestination();
                metalSynth = new Tone.MetalSynth({frequency: 50, envelope: { attack: 0.001, decay: 0.1, release: 0.1 }, harmonicity: 3.1, modulationIndex: 16, resonance: 2000, octaves: 0.5}).toDestination();
                metalSynth.volume.value = -15;
                hitSynth = new Tone.NoiseSynth({noise: { type: "pink" }, envelope: { attack: 0.001, decay: 0.05, sustain: 0 }}).toDestination();
                hitSynth.volume.value = -10;
                explosionSynth = new Tone.NoiseSynth({noise: { type: "white" }, envelope: { attack: 0.005, decay: 0.3, sustain: 0, release: 0.4 }, volume: -3}).toDestination(); 
                rocketFireSynth = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 5, oscillator: {type: "sine"}, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 0.4, attackCurve: "exponential"}, volume: -5 }).toDestination();
                
                bfgFireSynth = new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { attack: 0.1, decay: 0.8, sustain: 0.1, release: 0.5 }, volume: -2 }).toDestination();
                const bfgFireFilter = new Tone.AutoFilter("2n").toDestination().start();
                bfgFireFilter.depth.value = 0.8;
                bfgFireSynth.connect(bfgFireFilter);

                bossHitSynth = new Tone.MetalSynth({frequency: 40, envelope: { attack: 0.005, decay: 0.2, release: 0.1 }, harmonicity: 5.1, modulationIndex: 20, resonance: 1000, octaves: 1.5, volume: -8}).toDestination();
                bossDeathSynth = new Tone.NoiseSynth({ noise: { type: "brown" }, envelope: { attack: 0.1, decay: 1.5, sustain: 0.2, release: 1.0 }, volume: -3 }).toDestination();
                const bossDeathChorus = new Tone.Chorus(4, 2.5, 0.7).toDestination().start();
                bossDeathSynth.connect(bossDeathChorus);
                
                // Boss shoot synths
                bossRegularShootSynth = new Tone.Synth({ oscillator: {type: "pwm", modulationFrequency: 0.2}, envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.2 }, volume: -10 }).toDestination();
                bossSeekingShootSynth = new Tone.Synth({ oscillator: {type: "sawtooth", modulationFrequency: 0.3}, envelope: { attack: 0.02, decay: 0.25, sustain: 0.1, release: 0.2 }, volume: -11 }).toDestination();


                ammoPickupSynth = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.005, decay: 0.1, release: 0.1 }, volume: -12 }).toDestination();
                
                // Secret Door Sound
                secretDoorOpenSynth = new Tone.NoiseSynth({ noise: { type: "brown" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0 }, volume: -15 }).toDestination();
                const secretDoorFilter = new Tone.Filter(800, "lowpass").toDestination();
                secretDoorOpenSynth.connect(secretDoorFilter);


                console.log("Synths initialized successfully.");
            } catch (err) {
                console.error("Error during setupSynths:", err);
            }
        }
         async function ensureAudioAndSynths() {
            if (Tone.context.state === 'suspended') {
                try { 
                    await Tone.start(); 
                    console.log("Tone.js context started by ensureAudioAndSynths.");
                } catch (err) { console.error("Error starting Tone.js in ensureAudioAndSynths:", err); }
            }
            if (!synth) { 
                try {
                    setupSynths(); 
                } catch (err) {
                    console.error("Error setting up synths via ensureAudioAndSynths:", err);
                }
            }
        }

        // Sound Playback Functions
        function playShootSound(weaponName) { if (Tone.context.state !== 'running') return; const now = Tone.now() + 0.001; if (weaponName === 'Pistol' && metalSynth) { metalSynth.frequency.setValueAtTime(50, now); metalSynth.triggerAttackRelease("C2", "8n", now); } else if (weaponName === 'Shotgun' && metalSynth) { metalSynth.frequency.setValueAtTime(30, now); metalSynth.triggerAttackRelease("A1", "4n", now); } else if (weaponName === 'Machine Gun') { const mgSynth = new Tone.MetalSynth({ frequency: 70, envelope: { attack: 0.001, decay: 0.05, release: 0.05 }, harmonicity: 3.1, modulationIndex: 16, resonance: 1500, octaves: 0.5, volume: -18 }).toDestination(); mgSynth.triggerAttackRelease("D2", "32n", now); const duration = 0.001 + 0.05 + 0.05 + 0.02; setTimeout(() => { if (mgSynth && !mgSynth.disposed) { mgSynth.dispose(); } }, duration * 1000); } else if (weaponName === 'Rocket Launcher' && rocketFireSynth) { rocketFireSynth.triggerAttackRelease("C1", "0.5s", now); } else if (weaponName === 'BFG' && bfgFireSynth) { bfgFireSynth.triggerAttackRelease("1s", now); } }
        function playHitSound() { const nowMs = Tone.now() * 1000; if (nowMs - lastHitSoundTime < HIT_SOUND_COOLDOWN) return; lastHitSoundTime = nowMs; if (hitSynth && Tone.context.state === 'running') hitSynth.triggerAttackRelease("8n", Tone.now() + 0.01); } 
        function playPlayerHitSound() { if (synth && Tone.context.state === 'running') synth.triggerAttackRelease("A1", "8n", Tone.now() + 0.01); } 
        function playEnemyDestroySound() { const nowMs = Tone.now() * 1000; if (nowMs - lastEnemyDestroySoundTime < ENEMY_DESTROY_SOUND_COOLDOWN) return; lastEnemyDestroySoundTime = nowMs; if (explosionSynth && Tone.context.state === 'running') explosionSynth.triggerAttackRelease("0.2", Tone.now() + 0.01); } 
        
        function playRocketExplosionSound() {
            if (Tone.context.state === 'running') {
                const tempExplosionSynth = new Tone.NoiseSynth({
                    noise: { type: "white" }, 
                    envelope: { attack: 0.005, decay: 0.3, sustain: 0, release: 0.4 }, 
                    volume: -3
                }).toDestination();
                tempExplosionSynth.triggerAttackRelease("0.4", Tone.now() + 0.01);
                const duration = 0.005 + 0.3 + 0.4 + 0.05;
                setTimeout(() => {
                    if (tempExplosionSynth && !tempExplosionSynth.disposed) {
                        tempExplosionSynth.dispose();
                    }
                }, duration * 1000);
            }
        }
        function playBFGImpactSound() {
            if (Tone.context.state === 'running') {
                const tempBfgImpactSynth = new Tone.NoiseSynth({
                    noise: { type: "white" },
                    envelope: { attack: 0.01, decay: 0.6, sustain: 0, release: 0.8 },
                    volume: 0 
                }).toDestination();
                const reverb = new Tone.Reverb(1.5).toDestination(); 
                tempBfgImpactSynth.connect(reverb);
                tempBfgImpactSynth.triggerAttackRelease("0.8s", Tone.now() + 0.01);
                const duration = 0.01 + 0.6 + 0.8 + 0.05;
                setTimeout(() => {
                    if (tempBfgImpactSynth && !tempBfgImpactSynth.disposed) {
                        tempBfgImpactSynth.dispose();
                    }
                    if (reverb && !reverb.disposed) { 
                        reverb.dispose();
                    }
                }, duration * 1000);
            }
        }
        function playEnemyShootSound() { if (Tone.context.state === 'running') { const tempEnemySynth = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.005, decay: 0.05, sustain: 0.01, release: 0.1 }, volume: -20 }).toDestination(); tempEnemySynth.triggerAttackRelease("G3", "16n", Tone.now() + 0.001); const duration = 0.005 + 0.05 + 0.01 + 0.1 + 0.05; setTimeout(() => { if (tempEnemySynth && !tempEnemySynth.disposed) { tempEnemySynth.dispose(); } }, duration * 1000); } }
        function playHealthPickupSound() { if (Tone.context.state === 'running') { const tempHealthSynth = new Tone.Synth({oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.2 }, volume: -10}).toDestination(); tempHealthSynth.triggerAttackRelease("C5", "8n", Tone.now() + 0.01); const duration = 0.01 + 0.1 + 0.05 + 0.2 + 0.05; setTimeout(() => { if (tempHealthSynth && !tempHealthSynth.disposed) { tempHealthSynth.dispose(); } }, duration * 1000); } }
        function playKeyPickupSound() { if (Tone.context.state === 'running') { const tempKeyPickupSynth = new Tone.Synth({oscillator: {type: "triangle"}, envelope: {attack: 0.01, decay: 0.2, release: 0.2}, volume: -8}).toDestination(); tempKeyPickupSynth.triggerAttackRelease("E5", "8n", Tone.now() + 0.01); const duration = 0.01 + 0.2 + 0.2 + 0.05; setTimeout(() => { if (tempKeyPickupSynth && !tempKeyPickupSynth.disposed) { tempKeyPickupSynth.dispose(); } }, duration * 1000); } }
        function playDoorOpenSound() { if (Tone.context.state === 'running') { const tempDoorOpenSynth = new Tone.MetalSynth({frequency: 100, envelope: {attack:0.01, decay:0.3, release: 0.1}, harmonicity: 1.1, modulationIndex:5, resonance: 500, octaves: 1.5, volume: -12}).toDestination(); tempDoorOpenSynth.triggerAttackRelease("F#2", "4n", Tone.now() + 0.01); const duration = 0.01 + 0.3 + 0.1 + 0.05; setTimeout(() => { if (tempDoorOpenSynth && !tempDoorOpenSynth.disposed) { tempDoorOpenSynth.dispose(); } }, duration * 1000); } }
        function playWeaponPickupSound() { if (Tone.context.state === 'running') { const tempWeaponPickupSynth = new Tone.Synth({ oscillator: {type: "sawtooth"}, envelope: {attack: 0.02, decay: 0.15, release: 0.2}, volume: -9}).toDestination(); tempWeaponPickupSynth.triggerAttackRelease("A4", "8n", Tone.now() + 0.01); const duration = 0.02 + 0.15 + 0.2 + 0.05; setTimeout(() => { if (tempWeaponPickupSynth && !tempWeaponPickupSynth.disposed) { tempWeaponPickupSynth.dispose(); } }, duration * 1000); } }
        function playTeleportSound() { if (Tone.context.state === 'running') { const tempTeleportSynth = new Tone.Synth({ oscillator: { type: 'triangle8' }, envelope: { attack: 0.01, decay: 0.2, release: 0.2 }, volume: -10 }).toDestination(); tempTeleportSynth.triggerAttackRelease("C6", "16n", Tone.now() + 0.01); const duration = 0.01 + 0.2 + 0.2 + 0.05; setTimeout(() => { if (tempTeleportSynth && !tempTeleportSynth.disposed) { tempTeleportSynth.dispose(); } }, duration * 1000); } }
        function playSplitSound() { if (Tone.context.state === 'running') { const tempSplitSynth = new Tone.PluckSynth({ attackNoise: 0.5, dampening: 2000, resonance: 0.8, volume: -8 }).toDestination(); tempSplitSynth.triggerAttackRelease("G2", "8n", Tone.now() + 0.01); setTimeout(() => { if (tempSplitSynth && !tempSplitSynth.disposed) { tempSplitSynth.dispose(); } }, 500); } }
        function playEmptyGunSound() { if (Tone.context.state === 'running') { const tempEmptyGunSynth = new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 2, envelope: { attack: 0.001, decay: 0.1, sustain: 0 }, volume: -10 }).toDestination(); tempEmptyGunSynth.triggerAttackRelease("C2", "16n", Tone.now() + 0.001); const duration = 0.001 + 0.1 + 0.05; setTimeout(() => { if (tempEmptyGunSynth && !tempEmptyGunSynth.disposed) { tempEmptyGunSynth.dispose(); } }, duration * 1000); } }
        function playBossHitSound() { if (bossHitSynth && Tone.context.state === 'running') bossHitSynth.triggerAttackRelease("G1", "4n", Tone.now() + 0.01);} 
        function playBossDeathSound() { if (bossDeathSynth && Tone.context.state === 'running') bossDeathSynth.triggerAttackRelease("2s", Tone.now() + 0.01);} 
        
        function playBossRegularShootSound() {
            if (bossRegularShootSynth && Tone.context.state === 'running') {
                bossRegularShootSynth.triggerAttackRelease("A2", "8n", Tone.now() + 0.01);
            }
        }
        function playBossSeekingShootSound() {
            if (bossSeekingShootSynth && Tone.context.state === 'running') {
                bossSeekingShootSynth.triggerAttackRelease("G#2", "8n", Tone.now() + 0.01); 
            }
        }
        function playSecretDoorOpenSound() { 
            if (secretDoorOpenSynth && Tone.context.state === 'running') {
                secretDoorOpenSynth.triggerAttackRelease("0.1s", Tone.now() + 0.01); 
            }
        }

        function playAmmoPickupSound() { if (ammoPickupSynth && Tone.context.state === 'running') ammoPickupSynth.triggerAttackRelease("D4", "16n", Tone.now() + 0.01); }


        // BFS Pathfinding (for level validation)
        function findPath(startX, startY, endX, endY, currentMap, keysAvailable) {
            const queue = [[startX, startY, []]]; 
            const visited = new Set();
            visited.add(`${startX},${startY}`);

            while (queue.length > 0) {
                const [x, y, path] = queue.shift();

                if (x === endX && y === endY) return true; 

                const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                for (const [dx, dy] of directions) {
                    const nextX = x + dx;
                    const nextY = y + dy;

                    if (nextX >= 0 && nextX < MAP_COLS && nextY >= 0 && nextY < MAP_ROWS && !visited.has(`${nextX},${nextY}`)) {
                        const tileType = currentMap[nextY][nextX];
                        let canPass = false;
                        if (tileType === TILE_EMPTY || 
                            (tileType >= TILE_KEY_RED && tileType <= TILE_HEALTH_PACK) || 
                            tileType === TILE_SECRET_DOOR || // Player can pass through secret doors (interaction handles opening)
                            tileType === TILE_EXIT) {
                            canPass = true;
                        } else if (tileType === TILE_DOOR_RED && keysAvailable.red) {
                            canPass = true;
                        } else if (tileType === TILE_DOOR_YELLOW && keysAvailable.yellow) {
                            canPass = true;
                        } else if (tileType === TILE_DOOR_BLUE && keysAvailable.blue) {
                            canPass = true;
                        }
                        
                        if (canPass) {
                            visited.add(`${nextX},${nextY}`);
                            queue.push([nextX, nextY, [...path, [nextX, nextY]]]);
                        }
                    }
                }
            }
            return false; 
        }
        
        // BFS Pathfinding for Visibility (treats all closed doors and secret doors as walls)
        function findPathForVisibility(startX, startY, endX, endY, currentMap) {
            const queue = [[startX, startY, []]];
            const visited = new Set();
            visited.add(`${startX},${startY}`);

            while (queue.length > 0) {
                const [x, y, path] = queue.shift();

                if (x === endX && y === endY) return true;

                const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                for (const [dx, dy] of directions) {
                    const nextX = x + dx;
                    const nextY = y + dy;

                    if (nextX >= 0 && nextX < MAP_COLS && nextY >= 0 && nextY < MAP_ROWS && !visited.has(`${nextX},${nextY}`)) {
                        const tileType = currentMap[nextY][nextX];
                        if (tileType === TILE_EMPTY || 
                            (tileType >= TILE_KEY_RED && tileType <= TILE_HEALTH_PACK) || 
                            tileType === TILE_EXIT) { // Secret doors are not inherently visible until opened
                            visited.add(`${nextX},${nextY}`);
                            queue.push([nextX, nextY, [...path, [nextX, nextY]]]);
                        }
                    }
                }
            }
            return false;
        }
        
        function updateVisibility(playerTileX, playerTileY, currentMap) {
            if (!currentMap || !currentMap.length || !currentMap[0] || !currentMap[0].length) { 
                console.error("updateVisibility: currentMap is invalid or not fully initialized.");
                visibilityMap = Array(MAP_ROWS).fill(null).map(() => Array(MAP_COLS).fill(true)); 
                return;
            }
            visibilityMap = Array(MAP_ROWS).fill(null).map(() => Array(MAP_COLS).fill(false));
            const queue = [];
            const visitedForBFS = new Set(); 

            if (playerTileX >= 0 && playerTileX < MAP_COLS && playerTileY >= 0 && playerTileY < MAP_ROWS) {
                queue.push([playerTileX, playerTileY]);
                visitedForBFS.add(`${playerTileX},${playerTileY}`);
                if (visibilityMap[playerTileY]) visibilityMap[playerTileY][playerTileX] = true; 
            }

            let head = 0;
            while(head < queue.length){
                const [x,y] = queue[head++];
                
                const directions = [[0, 1], [0, -1], [1, 0], [-1, 0],[ -1, -1 ], [ -1, 1 ], [ 1, -1 ], [ 1, 1 ]]; 
                for (const [dx, dy] of directions) {
                    const nextX = x + dx;
                    const nextY = y + dy;

                    if (nextX >= 0 && nextX < MAP_COLS && nextY >= 0 && nextY < MAP_ROWS) {
                         if (!currentMap[nextY] || currentMap[nextY][nextX] === undefined) { 
                            continue;
                        }
                        const neighborTileType = currentMap[nextY][nextX];
                        
                        if (!visitedForBFS.has(`${nextX},${nextY}`)) {
                             if (neighborTileType === TILE_EMPTY || 
                                 (neighborTileType >= TILE_KEY_RED && neighborTileType <= TILE_HEALTH_PACK) || 
                                 neighborTileType === TILE_EXIT) {
                                
                                if (visibilityMap[nextY]) visibilityMap[nextY][nextX] = true;
                                visitedForBFS.add(`${nextX},${nextY}`);
                                queue.push([nextX, nextY]);
                            } else if (neighborTileType === TILE_WALL || 
                                       (neighborTileType >= TILE_DOOR_RED && neighborTileType <= TILE_DOOR_BLUE) ||
                                       neighborTileType === TILE_SECRET_DOOR ) { // Secret doors are revealed like walls
                                if (visibilityMap[nextY]) visibilityMap[nextY][nextX] = true; 
                                visitedForBFS.add(`${nextX},${nextY}`); 
                            }
                        }
                    }
                }
            }
        }

        // Line of Sight check for BFG Tracers and Boss Seeking Shot
        function isPathClear(x1, y1, x2, y2, currentMap, step = TILE_SIZE / 4) {
            if (!currentMap || !currentMap.length || !currentMap[0] || !currentMap[0].length) return false; 

            const dxTotal = x2 - x1;
            const dyTotal = y2 - y1;
            const distance = Math.hypot(dxTotal, dyTotal);
            const steps = Math.max(1, Math.floor(distance / step)); 

            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const currentX = x1 + t * dxTotal;
                const currentY = y1 + t * dyTotal;
                const tileX = Math.floor(currentX / TILE_SIZE);
                const tileY = Math.floor(currentY / TILE_SIZE);

                if (tileX < 0 || tileX >= MAP_COLS || tileY < 0 || tileY >= MAP_ROWS) return false; 
                if (!currentMap[tileY] || currentMap[tileY][tileX] === undefined) return false; 

                const tileType = currentMap[tileY][tileX];
                if (tileType === TILE_WALL ||
                    tileType === TILE_DOOR_RED ||
                    tileType === TILE_DOOR_YELLOW ||
                    tileType === TILE_DOOR_BLUE ||
                    tileType === TILE_SECRET_DOOR) { // Secret doors block LoS until opened
                    if (i < steps) return false; 
                }
            }
            return true;
        }


        // Level Generation
        function generateMaze(cols, rows, isMainBossLevelLayout) { 
            console.log("generateMaze: Starting maze generation for level", currentLevel, "isMainBossLevelLayout:", isMainBossLevelLayout);
            let map = Array(rows).fill(null).map(() => Array(cols).fill(TILE_WALL));
            let playerStartCell = { r: Math.floor(rows/2), c: Math.floor(cols/2) }; 
            let bossSpawnCell = null; 
            let actualPlayerStartRoom = null; 
            let rooms = []; 

            function placeItemInRandomEmptyTile(room, itemTileType, currentMap) {
                if (!room) return false;
                let placed = false;
                const emptyTiles = [];
                for(let r = room.y; r < room.y + room.height; r++){
                    for(let c = room.x; c < room.x + room.width; c++){
                        if(r >=0 && r < MAP_ROWS && c >= 0 && c < MAP_COLS && currentMap[r][c] === TILE_EMPTY) emptyTiles.push({r,c});
                    }
                }
                if(emptyTiles.length > 0){
                    const randTile = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
                    currentMap[randTile.r][randTile.c] = itemTileType;
                    placed = true;
                }
                return placed;
            }


            if (isMainBossLevelLayout) { 
                console.log("generateMaze: Generating MAIN BOSS LEVEL layout.");
                const bossRoomWidth = Math.max(15, Math.floor(cols * 0.6) ); 
                const bossRoomHeight = Math.max(10, Math.floor(rows * 0.5));
                const bossRoomX = Math.floor((cols - bossRoomWidth) / 2);
                const bossRoomY = Math.floor((rows - bossRoomHeight) / 2);

                const bossRoom = { x: bossRoomX, y: bossRoomY, width: bossRoomWidth, height: bossRoomHeight, id: 0, center: {x: bossRoomX + Math.floor(bossRoomWidth/2), y: bossRoomY + Math.floor(bossRoomHeight/2)}, connected: true};
                rooms.push(bossRoom);

                for (let r = bossRoomY; r < bossRoomY + bossRoomHeight; r++) {
                    for (let c = bossRoomX; c < bossRoomX + bossRoomWidth; c++) {
                        if (r >= 0 && r < rows && c >=0 && c < cols) map[r][c] = TILE_EMPTY;
                    }
                }
                bossSpawnCell = { r: bossRoom.center.y, c: bossRoom.center.x };
                console.log("generateMaze: Main boss room created. Center:", bossSpawnCell);

                const numAntechambers = 1 + Math.floor(Math.random() * 2); 
                let playerPlaced = false;
                for (let i = 0; i < numAntechambers; i++) {
                    const anteWidth = 5 + Math.floor(Math.random() * 3);
                    const anteHeight = 5 + Math.floor(Math.random() * 3);
                    let anteX, anteY;
                    
                    if (i === 0) { 
                        anteX = Math.max(1, bossRoomX - anteWidth - 2);
                        anteY = bossRoomY + Math.floor((bossRoomHeight - anteHeight) / 2);
                    } else { 
                        anteX = Math.min(cols - anteWidth - 1, bossRoomX + bossRoomWidth + 2);
                        anteY = bossRoomY + Math.floor((bossRoomHeight - anteHeight) / 2);
                    }
                    anteX = Math.max(1, Math.min(anteX, cols - anteWidth - 1)); 
                    anteY = Math.max(1, Math.min(anteY, rows - anteHeight - 1)); 


                    const antechamber = {x: anteX, y: anteY, width: anteWidth, height: anteHeight, id: i+1, center: {x: anteX + Math.floor(anteWidth/2), y: anteY + Math.floor(anteHeight/2)}, connected: false};
                    rooms.push(antechamber);

                    for (let r = anteY; r < anteY + anteHeight; r++) {
                        for (let c = anteX; c < anteX + anteWidth; c++) {
                           if (r >= 0 && r < rows && c >=0 && c < cols) map[r][c] = TILE_EMPTY;
                        }
                    }
                    let tunnelStartX = antechamber.center.x;
                    let tunnelStartY = antechamber.center.y;
                    let tunnelEndX = bossRoom.center.x;
                    let tunnelEndY = bossRoom.center.y;

                    while(tunnelStartX !== tunnelEndX) {
                        if(map[tunnelStartY][tunnelStartX] === TILE_WALL) map[tunnelStartY][tunnelStartX] = TILE_EMPTY;
                        tunnelStartX += Math.sign(tunnelEndX - tunnelStartX);
                    }
                     if(map[tunnelStartY][tunnelStartX] === TILE_WALL) map[tunnelStartY][tunnelStartX] = TILE_EMPTY;
                    while(tunnelStartY !== tunnelEndY) {
                        if(map[tunnelStartY][tunnelStartX] === TILE_WALL) map[tunnelStartY][tunnelStartX] = TILE_EMPTY;
                        tunnelStartY += Math.sign(tunnelEndY - tunnelStartY);
                    }
                    if(map[tunnelStartY][tunnelStartX] === TILE_WALL) map[tunnelStartY][tunnelStartX] = TILE_EMPTY;


                    if (!playerPlaced) {
                        playerStartCell = { r: antechamber.center.y, c: antechamber.center.x };
                        playerPlaced = true;
                        console.log("generateMaze: Player start placed in antechamber:", playerStartCell);
                    }
                    if (i < 2) placeItemInRandomEmptyTile(antechamber, TILE_HEALTH_PACK, map); 
                }
                 if (!playerPlaced && rooms.length > 0 && rooms[0].center) { 
                     playerStartCell = { r: rooms[0].center.y, c: rooms[0].center.x };
                }

                console.log("generateMaze: Main boss level layout complete.");
                return { gameMap: map, playerStart: playerStartCell, bossSpawn: bossSpawnCell };

            } else { // Regular Level Generation (also used for Mini-Boss levels)
                console.log("generateMaze: Generating REGULAR/MINI-BOSS LEVEL layout.");
                let generationAttempts = 0;
                const MAX_GENERATION_ATTEMPTS = 25; 
                let levelIsValid = false;
                
                while (!levelIsValid && generationAttempts < MAX_GENERATION_ATTEMPTS) {
                    map = Array(rows).fill(null).map(() => Array(cols).fill(TILE_WALL));
                    rooms = []; // Reset rooms for each attempt
                    const MIN_ROOM_SIZE = 5; 
                    const MAX_ROOM_SIZE = 11; 
                    const NUM_ROOMS_ATTEMPT = 30; 
                    const MIN_ROOMS_FOR_LOGIC = 6; 
                    playerStartCell = { r: Math.floor(rows/2), c: Math.floor(cols/2) }; 

                    for (let i = 0; i < NUM_ROOMS_ATTEMPT && rooms.length < NUM_ROOMS_ATTEMPT * 0.8; i++) { 
                        const roomWidth = MIN_ROOM_SIZE + Math.floor(Math.random() * (MAX_ROOM_SIZE - MIN_ROOM_SIZE + 1));
                        const roomHeight = MIN_ROOM_SIZE + Math.floor(Math.random() * (MAX_ROOM_SIZE - MIN_ROOM_SIZE + 1));
                        const roomX = Math.floor(Math.random() * (cols - roomWidth - 2)) + 1;
                        const roomY = Math.floor(Math.random() * (rows - roomHeight - 2)) + 1;
                        const newRoom = { x: roomX, y: roomY, width: roomWidth, height: roomHeight, connected: false, id: rooms.length, center: {x: roomX + Math.floor(roomWidth/2), y: roomY + Math.floor(roomHeight/2)} };
                        
                        let overlaps = false;
                        for (const existingRoom of rooms) {
                            if (newRoom.x < existingRoom.x + existingRoom.width + 1 && 
                                newRoom.x + newRoom.width + 1 > existingRoom.x &&
                                newRoom.y < existingRoom.y + existingRoom.height + 1 &&
                                newRoom.y + newRoom.height + 1 > existingRoom.y) {
                                overlaps = true; break;
                            }
                        }
                        if (!overlaps) {
                            rooms.push(newRoom);
                            for (let r = newRoom.y; r < newRoom.y + newRoom.height; r++) {
                                for (let c = newRoom.x; c < newRoom.x + newRoom.width; c++) {
                                    map[r][c] = TILE_EMPTY;
                                }
                            }
                        }
                    }

                    if (rooms.length < MIN_ROOMS_FOR_LOGIC) {
                        generationAttempts++;
                        levelIsValid = false; 
                        continue; 
                    }

                    if (rooms.length > 0) {
                        playerStartCell = { r: rooms[0].center.y, c: rooms[0].center.x }; 
                        actualPlayerStartRoom = rooms[0]; 
                        let connectedSet = new Set();
                        connectedSet.add(rooms[0].id);
                        rooms[0].connected = true;

                        while (connectedSet.size < rooms.length) {
                            let closestDist = Infinity;
                            let roomA = null, roomB = null; 

                            for (const rA of rooms) {
                                if (!rA.connected) continue;
                                for (const rB of rooms) {
                                    if (rB.connected) continue;
                                    const dist = Math.hypot(rA.center.x - rB.center.x, rA.center.y - rB.center.y);
                                    if (dist < closestDist) {
                                        closestDist = dist;
                                        roomA = rA;
                                        roomB = rB;
                                    }
                                }
                            }

                            if (roomA && roomB) {
                                let curX = roomA.center.x;
                                let curY = roomA.center.y;
                                while (curX !== roomB.center.x) {
                                    if (map[curY][curX] === TILE_WALL) map[curY][curX] = TILE_EMPTY;
                                    curX += Math.sign(roomB.center.x - curX);
                                }
                                if (map[curY][curX] === TILE_WALL) map[curY][curX] = TILE_EMPTY; 
                                while (curY !== roomB.center.y) {
                                    if (map[curY][curX] === TILE_WALL) map[curY][curX] = TILE_EMPTY;
                                    curY += Math.sign(roomB.center.y - curY);
                                }
                                if (map[curY][curX] === TILE_WALL) map[curY][curX] = TILE_EMPTY; 

                                roomB.connected = true;
                                connectedSet.add(roomB.id);
                            } else {
                                break; 
                            }
                        }
                    }

                    let itemPlacementOrder = []; 
                    let availableRoomsForItems = [...rooms]; 

                    function pickRoomForItem(mustBeDifferentFromRooms = []) {
                        if (availableRoomsForItems.length === 0) return null;
                        let pickedRoom = null;
                        
                        const playerStartRoomIdToAvoid = actualPlayerStartRoom ? actualPlayerStartRoom.id : -1;
                        
                        const validRoomsToPickFrom = availableRoomsForItems.filter(candidateRoom => {
                            if (candidateRoom.id === playerStartRoomIdToAvoid) return false;
                            for (const diffRoom of mustBeDifferentFromRooms) {
                                if (diffRoom && candidateRoom.id === diffRoom.id) return false;
                            }
                            return true;
                        });

                        if (validRoomsToPickFrom.length === 0) {
                             const lessRestricted = availableRoomsForItems.filter(r => r.id !== playerStartRoomIdToAvoid);
                             if (lessRestricted.length > 0) {
                                 pickedRoom = lessRestricted[Math.floor(Math.random() * lessRestricted.length)];
                             } else if (availableRoomsForItems.length > 0) { 
                                pickedRoom = availableRoomsForItems[Math.floor(Math.random() * availableRoomsForItems.length)];
                             }
                        } else {
                            pickedRoom = validRoomsToPickFrom[Math.floor(Math.random() * validRoomsToPickFrom.length)];
                        }
                        
                        if (pickedRoom) { 
                            availableRoomsForItems = availableRoomsForItems.filter(r => r.id !== pickedRoom.id);
                        }
                        return pickedRoom;
                    }
                    
                    let exitRoomDetails = null; 
                    const roomsToAvoidForKeyItems = actualPlayerStartRoom ? [actualPlayerStartRoom] : [];


                    const redKeyRoom = pickRoomForItem(roomsToAvoidForKeyItems);
                    if (redKeyRoom) { placeItemInRandomEmptyTile(redKeyRoom, TILE_KEY_RED, map); roomsToAvoidForKeyItems.push(redKeyRoom); }

                    const yellowKeyRoom = pickRoomForItem(roomsToAvoidForKeyItems);
                    if (yellowKeyRoom) { placeItemInRandomEmptyTile(yellowKeyRoom, TILE_KEY_YELLOW, map); roomsToAvoidForKeyItems.push(yellowKeyRoom); }
                    
                    const blueKeyRoom = pickRoomForItem(roomsToAvoidForKeyItems);
                    if (blueKeyRoom) { placeItemInRandomEmptyTile(blueKeyRoom, TILE_KEY_BLUE, map); roomsToAvoidForKeyItems.push(blueKeyRoom); }

                    const exitRoom = pickRoomForItem(roomsToAvoidForKeyItems);
                    if (exitRoom) { 
                        placeItemInRandomEmptyTile(exitRoom, TILE_EXIT, map); 
                        exitRoomDetails = exitRoom;
                        roomsToAvoidForKeyItems.push(exitRoom);
                    }

                    const shotgunRoom = pickRoomForItem(roomsToAvoidForKeyItems); 
                    if (shotgunRoom) placeItemInRandomEmptyTile(shotgunRoom, TILE_WEAPON_SHOTGUN, map);
                    
                    if (currentLevel > 3) { 
                        const rocketLauncherRoom = pickRoomForItem(roomsToAvoidForKeyItems);
                        if (rocketLauncherRoom && (!player || !player.weapons.find(w => w.name === "Rocket Launcher" && w.owned))) { 
                           placeItemInRandomEmptyTile(rocketLauncherRoom, TILE_WEAPON_ROCKETLAUNCHER, map);
                        }
                    }
                    
                    if (currentLevel > 5) { 
                        const bfgRoom = pickRoomForItem(roomsToAvoidForKeyItems); 
                        if (bfgRoom && (!player || !player.weapons.find(w => w.name === "BFG" && w.owned))) { 
                            placeItemInRandomEmptyTile(bfgRoom, TILE_WEAPON_BFG, map);
                        }
                    }
                    
                    const machineGunRoom = pickRoomForItem(roomsToAvoidForKeyItems); 
                    if (machineGunRoom && (!player || !player.weapons.find(w => w.name === "Machine Gun" && w.owned))) { 
                        placeItemInRandomEmptyTile(machineGunRoom, TILE_WEAPON_MACHINEGUN, map);
                    }


                    function placeDoorGuardingRoom(targetRoom, doorType) {
                        if (!targetRoom || !targetRoom.center) return false;
                        const { x: roomX, y: roomY, width: roomW, height: roomH } = targetRoom;
                        const potentialDoorLocations = [];

                        for (let r = roomY - 1; r <= roomY + roomH; r++) {
                            for (let c = roomX - 1; c <= roomX + roomW; c++) {
                                if (r < 0 || r >= rows || c < 0 || c >= cols) continue; 
                                if (r >= roomY && r < roomY + roomH && c >= roomX && c < roomX + roomW) continue; 

                                if (map[r][c] === TILE_EMPTY) { 
                                    let connectsToTargetInterior = false;
                                    let wallNeighborCount = 0; 
                                    const directions = [[0,1], [0,-1], [1,0], [-1,0]]; 

                                    for(const [dr, dc] of directions) {
                                        const nr = r + dr; 
                                        const nc = c + dc;
                                        if(nr >=0 && nr < rows && nc >=0 && nc < cols) {
                                            if (nr >= roomY && nr < roomY + roomH && nc >= roomX && nc < roomX + roomW && map[nr][nc] === TILE_EMPTY) {
                                                connectsToTargetInterior = true; 
                                            } else if (map[nr][nc] === TILE_WALL) {
                                                wallNeighborCount++;
                                            }
                                        } else { 
                                            wallNeighborCount++; 
                                        }
                                    }
                                    if (connectsToTargetInterior && wallNeighborCount >= 2) { 
                                        potentialDoorLocations.push({ r, c });
                                    }
                                }
                            }
                        }
                        if (potentialDoorLocations.length > 0) {
                            const doorLoc = potentialDoorLocations[Math.floor(Math.random() * potentialDoorLocations.length)];
                            map[doorLoc.r][doorLoc.c] = doorType; 
                            return true;
                        }
                        return false; 
                    }

                    if (yellowKeyRoom) placeDoorGuardingRoom(yellowKeyRoom, TILE_DOOR_RED);
                    if (blueKeyRoom) placeDoorGuardingRoom(blueKeyRoom, TILE_DOOR_YELLOW);
                    if (exitRoomDetails) placeDoorGuardingRoom(exitRoomDetails, TILE_DOOR_BLUE);
                
                    levelIsValid = true;
                    const pStartR = playerStartCell.r;
                    const pStartC = playerStartCell.c;

                    if (redKeyRoom && !findPath(pStartC, pStartR, redKeyRoom.center.x, redKeyRoom.center.y, map, {red:false, yellow:false, blue:false})) {
                        levelIsValid = false;
                    }
                    if (levelIsValid && yellowKeyRoom && redKeyRoom && !findPath(redKeyRoom.center.x, redKeyRoom.center.y, yellowKeyRoom.center.x, yellowKeyRoom.center.y, map, {red:true, yellow:false, blue:false})) {
                        levelIsValid = false;
                    }
                    if (levelIsValid && blueKeyRoom && yellowKeyRoom && !findPath(yellowKeyRoom.center.x, yellowKeyRoom.center.y, blueKeyRoom.center.x, blueKeyRoom.center.y, map, {red:true, yellow:true, blue:false})) {
                        levelIsValid = false;
                    }
                    if (levelIsValid && exitRoomDetails && blueKeyRoom && !findPath(blueKeyRoom.center.x, blueKeyRoom.center.y, exitRoomDetails.center.x, exitRoomDetails.center.y, map, {red:true, yellow:true, blue:true})) {
                        levelIsValid = false;
                    }
                    if (!redKeyRoom || !yellowKeyRoom || !blueKeyRoom || !exitRoomDetails) { 
                        levelIsValid = false;
                    }
                    generationAttempts++;
                } 

                // --- SECRET ROOM GENERATION (REVISED) ---
                const SECRET_ROOM_CHANCE = 0.25; 
                const MIN_SECRET_ROOM_SIZE = 2;
                const MAX_SECRET_ROOM_SIZE = 3;

                for (const room of rooms) {
                    if (room.id === actualPlayerStartRoom?.id) continue; 

                    if (Math.random() > SECRET_ROOM_CHANCE) {
                        continue;
                    }

                    const potentialSides = []; // 0:N, 1:E, 2:S, 3:W
                    if (room.y > MIN_SECRET_ROOM_SIZE) potentialSides.push(0); 
                    if (room.x + room.width < cols - MIN_SECRET_ROOM_SIZE -1) potentialSides.push(1); 
                    if (room.y + room.height < rows - MIN_SECRET_ROOM_SIZE -1) potentialSides.push(2); 
                    if (room.x > MIN_SECRET_ROOM_SIZE) potentialSides.push(3); 

                    if (potentialSides.length === 0) continue;
                    potentialSides.sort(() => Math.random() - 0.5);

                    for (const side of potentialSides) {
                        const srWidth = MIN_SECRET_ROOM_SIZE + Math.floor(Math.random() * (MAX_SECRET_ROOM_SIZE - MIN_SECRET_ROOM_SIZE + 1));
                        const srHeight = MIN_SECRET_ROOM_SIZE + Math.floor(Math.random() * (MAX_SECRET_ROOM_SIZE - MIN_SECRET_ROOM_SIZE + 1));

                        let doorX = -1, doorY = -1;
                        let srCarveX = -1, srCarveY = -1; 

                        let possibleDoorLocations = [];
                        if (side === 0) { 
                            for (let c = room.x; c < room.x + room.width; c++) if (room.y - 1 > 0 && map[room.y - 1][c] === TILE_WALL) possibleDoorLocations.push({x:c, y:room.y - 1});
                        } else if (side === 1) { 
                            for (let r = room.y; r < room.y + room.height; r++) if (room.x + room.width < cols - 1 && map[r][room.x + room.width] === TILE_WALL) possibleDoorLocations.push({x:room.x + room.width, y:r});
                        } else if (side === 2) { 
                             for (let c = room.x; c < room.x + room.width; c++) if (room.y + room.height < rows - 1 && map[room.y + room.height][c] === TILE_WALL) possibleDoorLocations.push({x:c, y:room.y + room.height});
                        } else { 
                            for (let r = room.y; r < room.y + room.height; r++) if (room.x - 1 > 0 && map[r][room.x - 1] === TILE_WALL) possibleDoorLocations.push({x:room.x - 1, y:r});
                        }

                        if (possibleDoorLocations.length === 0) continue;
                        const doorCand = possibleDoorLocations[Math.floor(Math.random() * possibleDoorLocations.length)];
                        doorX = doorCand.x;
                        doorY = doorCand.y;

                        if (side === 0) { 
                            srCarveY = doorY - srHeight;
                            srCarveX = doorX - Math.floor(Math.random() * srWidth); 
                        } else if (side === 1) { 
                            srCarveX = doorX + 1;
                            srCarveY = doorY - Math.floor(Math.random() * srHeight);
                        } else if (side === 2) { 
                            srCarveY = doorY + 1;
                            srCarveX = doorX - Math.floor(Math.random() * srWidth);
                        } else { 
                            srCarveX = doorX - srWidth;
                            srCarveY = doorY - Math.floor(Math.random() * srHeight);
                        }
                        
                        srCarveX = Math.max(1, Math.min(srCarveX, cols - 1 - srWidth));
                        srCarveY = Math.max(1, Math.min(srCarveY, rows - 1 - srHeight));
                        
                        if (srCarveX + srWidth >= cols -1 || srCarveY + srHeight >= rows -1 ) continue;

                        let footprintIsAllWalls = true;
                        for (let r_sr = srCarveY; r_sr < srCarveY + srHeight; r_sr++) {
                            for (let c_sr = srCarveX; c_sr < srCarveX + srWidth; c_sr++) {
                                if (r_sr < 0 || r_sr >= rows || c_sr < 0 || c_sr >= cols || map[r_sr][c_sr] !== TILE_WALL) { // Boundary check for cavity
                                    footprintIsAllWalls = false; break;
                                }
                            }
                            if (!footprintIsAllWalls) break;
                        }
                        
                        if (doorY < 0 || doorY >= rows || doorX < 0 || doorX >= cols || map[doorY][doorX] !== TILE_WALL) footprintIsAllWalls = false;

                        if (footprintIsAllWalls) {
                            for (let r_sr = srCarveY; r_sr < srCarveY + srHeight; r_sr++) {
                                for (let c_sr = srCarveX; c_sr < srCarveX + srWidth; c_sr++) {
                                    map[r_sr][c_sr] = TILE_EMPTY;
                                }
                            }
                            map[doorY][doorX] = TILE_SECRET_DOOR;

                            const secretRoomObj = { x: srCarveX, y: srCarveY, width: srWidth, height: srHeight };
                            let itemsPlacedInSecret = 0;
                            const maxItemsInSecret = 1 + Math.floor(Math.random() * 2);

                            if (Math.random() < 0.7 && itemsPlacedInSecret < maxItemsInSecret) {
                                if(placeItemInRandomEmptyTile(secretRoomObj, TILE_HEALTH_PACK, map)) itemsPlacedInSecret++;
                            }
                            if (Math.random() < 0.5 && itemsPlacedInSecret < maxItemsInSecret) {
                                const weaponPool = [];
                                if (!player || !player.weapons.find(w => w.name === "Shotgun" && w.owned)) weaponPool.push(TILE_WEAPON_SHOTGUN);
                                if (!player || !player.weapons.find(w => w.name === "Machine Gun" && w.owned)) weaponPool.push(TILE_WEAPON_MACHINEGUN);
                                if (currentLevel > 2 && (!player || !player.weapons.find(w => w.name === "Rocket Launcher" && w.owned))) weaponPool.push(TILE_WEAPON_ROCKETLAUNCHER);
                                if (currentLevel > 4 && (!player || !player.weapons.find(w => w.name === "BFG" && w.owned))) weaponPool.push(TILE_WEAPON_BFG);
                                
                                if (weaponPool.length > 0) {
                                    if(placeItemInRandomEmptyTile(secretRoomObj, weaponPool[Math.floor(Math.random() * weaponPool.length)], map)) itemsPlacedInSecret++;
                                }
                            }
                            if (itemsPlacedInSecret === 0) { // Ensure at least one item
                                placeItemInRandomEmptyTile(secretRoomObj, TILE_HEALTH_PACK, map);
                            }
                            console.log(`Placed secret room at [${srCarveX},${srCarveY}] (size ${srWidth}x${srHeight}) for room ${room.id} via door at [${doorX},${doorY}]`);
                            break; 
                        }
                    }
                }
                // --- END OF SECRET ROOM GENERATION ---

                console.log("generateMaze: Regular level layout attempt complete.");
                return { gameMap: map, playerStart: playerStartCell, bossSpawn: null }; 
            } 
        }
        
        // HealthPack Class
        class HealthPack { constructor(x, y) { this.x = x; this.y = y; this.radius = TILE_SIZE / 3; this.healthValue = 25; this.color = 'lime'; } draw() { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = 'white'; const cW = this.radius/2.5, cL = this.radius*1.2; ctx.fillRect(this.x - cW/2, this.y - cL/2, cW, cL); ctx.fillRect(this.x - cL/2, this.y - cW/2, cL, cW); } }
        
        // AmmoPack Class
        class AmmoPack {
            constructor(x, y, weaponName, ammoAmount) {
                this.x = x;
                this.y = y;
                this.radius = TILE_SIZE / 3.5; 
                this.weaponName = weaponName;
                this.ammoAmount = ammoAmount;
                this.color = '#AAAAAA'; // Grey for generic ammo
                this.char = '?';

                // Customize appearance based on weapon type
                if (weaponName === "Shotgun") { this.color = '#FFA500'; this.char = 'S'; }
                else if (weaponName === "Machine Gun") { this.color = '#ADD8E6'; this.char = 'M'; }
                else if (weaponName === "Rocket Launcher") { this.color = '#FF6347'; this.char = 'R'; }
                else if (weaponName === "BFG") { this.color = '#00DD00'; this.char = 'B'; }
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
                ctx.fill();
                ctx.fillStyle = 'black'; // Text color on ammo pack
                ctx.font = `${this.radius * 1.5}px "Press Start 2P"`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.char, this.x, this.y + 2);
            }
        }


        // Player Class
        class Player { 
            constructor(x, y) { 
                this.x = x; this.y = y; this.radius = TILE_SIZE / 3; this.speed = 3.5; 
                this.health = 100; this.maxHealth = 100; this.angle = Math.PI / 2; 
                this.keysCollected = { red: false, yellow: false, blue: false }; 
                this.canPhase = false; 
                this.weapons = [];
                // Initialize all weapons from WEAPON_STATS
                for (const weaponKey in WEAPON_STATS) {
                    const stats = WEAPON_STATS[weaponKey];
                    this.weapons.push({
                        ...stats, 
                        damage: stats.damage(), // Evaluate damage for current level
                        ammo: (stats.name === "Pistol" ? Infinity : 0), 
                        owned: (stats.name === "Pistol") 
                    });
                }
                this.currentWeaponIndex = this.weapons.findIndex(w => w.name === "Pistol");
                this.shootCooldown = 0; 
                this.justFiredPistolOnThisClick = false; 
                this.currentAnimFrame = 0; 
                this.animTimer = 0;
                this.animSpeed = 8; 
                this.isMoving = false;
            } 
            getCurrentWeapon() { return this.weapons[this.currentWeaponIndex]; } 
            addWeapon(weaponDataFromTile) { 
                let weaponInstance = this.weapons.find(w => w.name === weaponDataFromTile.name);
                const evaluatedDamage = WEAPON_STATS[weaponDataFromTile.name].damage(); 

                if (weaponInstance) { 
                    if (!weaponInstance.owned) {
                        weaponInstance.owned = true;
                        weaponInstance.ammo = weaponDataFromTile.pickupAmmo; 
                        playWeaponPickupSound();
                    } else if (weaponInstance.ammo !== Infinity) { 
                        weaponInstance.ammo = Math.min(weaponInstance.ammo + weaponDataFromTile.pickupAmmo, weaponInstance.maxAmmo);
                        playAmmoPickupSound(); 
                    }
                    weaponInstance.damage = evaluatedDamage; 
                } else {
                    console.error(`Player.addWeapon: Weapon ${weaponDataFromTile.name} was expected to be pre-initialized but not found.`);
                }
                updateWeaponUI(); 
            } 
            addAmmo(weaponName, amount) {
                const weapon = this.weapons.find(w => w.name === weaponName);
                if (weapon && weapon.ammo !== Infinity) {
                    weapon.ammo = Math.min(weapon.ammo + amount, weapon.maxAmmo);
                    playAmmoPickupSound();
                    updateWeaponUI();
                }
            }
            switchWeapon(index) { 
                if (index >= 0 && index < this.weapons.length && this.weapons[index].owned) { 
                    this.currentWeaponIndex = index; 
                    updateWeaponUI(); 
                }
            } 
            draw() { if (playerSpriteImage && playerSpriteImage.complete && playerSpriteImage.naturalHeight !== 0) { ctx.save(); ctx.translate(this.x, this.y); let frameDirection = playerFrames.down; const normalizedAngle = (this.angle + 2 * Math.PI) % (2 * Math.PI); if (normalizedAngle >= Math.PI * 0.25 && normalizedAngle < Math.PI * 0.75) { frameDirection = playerFrames.down; } else if (normalizedAngle >= Math.PI * 0.75 && normalizedAngle < Math.PI * 1.25) { frameDirection = playerFrames.left; } else if (normalizedAngle >= Math.PI * 1.25 && normalizedAngle < Math.PI * 1.75) { frameDirection = playerFrames.up; } else { frameDirection = playerFrames.right; } const frameToDraw = this.isMoving ? this.currentAnimFrame : 0; const sX = (frameDirection.x + frameToDraw) * PLAYER_SPRITE_FRAME_WIDTH; const sY = frameDirection.y * PLAYER_SPRITE_FRAME_HEIGHT; const dWidth = PLAYER_SPRITE_FRAME_WIDTH * PLAYER_SPRITE_SCALE; const dHeight = PLAYER_SPRITE_FRAME_HEIGHT * PLAYER_SPRITE_SCALE; ctx.drawImage( playerSpriteImage, sX, sY, PLAYER_SPRITE_FRAME_WIDTH, PLAYER_SPRITE_FRAME_HEIGHT, -dWidth / 2, -dHeight + this.radius, dWidth, dHeight ); ctx.restore(); } else { ctx.save(); ctx.translate(this.x, this.y); ctx.fillStyle = this.canPhase ? 'rgba(0, 123, 255, 0.5)' : '#007bff'; ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#555'; ctx.fillRect(this.radius * 0.8, -this.radius / 5, this.radius, this.radius / 2.5); ctx.restore(); } } 
            update() { let moveX = 0; let moveY = 0; if (keys.w || keys.ArrowUp) moveY -= this.speed; if (keys.s || keys.ArrowDown) moveY += this.speed; if (keys.a || keys.ArrowLeft) moveX -= this.speed; if (keys.d || keys.ArrowRight) moveX += this.speed; this.isMoving = (moveX !== 0 || moveY !== 0); if (this.isMoving) { this.animTimer++; if (this.animTimer >= this.animSpeed) { this.currentAnimFrame = (this.currentAnimFrame + 1) % 3; this.animTimer = 0; } } else { this.currentAnimFrame = 0; this.animTimer = 0; } const worldMouseX = mouse.x + camera.x; const worldMouseY = mouse.y + camera.y; this.angle = Math.atan2(worldMouseY - this.y, worldMouseX - this.x); if (moveX !== 0 && moveY !== 0) { const factor = Math.sqrt(0.5); moveX *= factor; moveY *= factor; } const newX = this.x + moveX; const newY = this.y + moveY; const currentTileX = Math.floor(this.x / TILE_SIZE); const currentTileY = Math.floor(this.y / TILE_SIZE); let collisionX = false; let collisionY = false; const checkRadius = this.radius * 0.9; if (moveX !== 0) { const nextTileCenterX = Math.floor((this.x + moveX + Math.sign(moveX) * checkRadius) / TILE_SIZE); if (this.checkTileInteraction(nextTileCenterX, Math.floor((this.y - checkRadius) / TILE_SIZE)) || this.checkTileInteraction(nextTileCenterX, Math.floor((this.y + checkRadius) / TILE_SIZE)) || this.checkTileInteraction(nextTileCenterX, currentTileY) ) { collisionX = true; } } if (moveY !== 0) { const nextTileCenterY = Math.floor((this.y + moveY + Math.sign(moveY) * checkRadius) / TILE_SIZE); if (this.checkTileInteraction(Math.floor((this.x - checkRadius) / TILE_SIZE), nextTileCenterY) || this.checkTileInteraction(Math.floor((this.x + checkRadius) / TILE_SIZE), nextTileCenterY) || this.checkTileInteraction(currentTileX, nextTileCenterY) ) { collisionY = true; } } if (!collisionX) this.x += moveX; if (!collisionY) this.y += moveY; const weapon = this.getCurrentWeapon(); if (this.shootCooldown > 0) this.shootCooldown--; if (mouse.down && this.shootCooldown === 0) { if (weapon.singleShot) { if (!this.justFiredPistolOnThisClick) { this.shoot(); this.justFiredPistolOnThisClick = true; } } else { this.shoot(); } } if (!mouse.down) { this.justFiredPistolOnThisClick = false; } if (this.health <= 0) { gameOver = true; showGameOverScreen(); } } 
            checkTileInteraction(tileX, tileY) { 
                if (this.canPhase) return false; 
                if (tileX < 0 || tileX >= MAP_COLS || tileY < 0 || tileY >= MAP_ROWS) return true; 
                const tileType = gameMap[tileY][tileX]; 
                switch (tileType) { 
                    case TILE_WALL: return true; 
                    case TILE_DOOR_RED: if (this.keysCollected.red) { gameMap[tileY][tileX] = TILE_EMPTY; playDoorOpenSound(); updateKeyUI(); updateVisibility(Math.floor(this.x / TILE_SIZE), Math.floor(this.y / TILE_SIZE), gameMap); return false; } return true; 
                    case TILE_DOOR_YELLOW: if (this.keysCollected.yellow) { gameMap[tileY][tileX] = TILE_EMPTY; playDoorOpenSound(); updateKeyUI(); updateVisibility(Math.floor(this.x / TILE_SIZE), Math.floor(this.y / TILE_SIZE), gameMap); return false; } return true; 
                    case TILE_DOOR_BLUE: if (this.keysCollected.blue) { gameMap[tileY][tileX] = TILE_EMPTY; playDoorOpenSound(); updateKeyUI(); updateVisibility(Math.floor(this.x / TILE_SIZE), Math.floor(this.y / TILE_SIZE), gameMap); return false; } return true; 
                    case TILE_KEY_RED: this.keysCollected.red = true; gameMap[tileY][tileX] = TILE_EMPTY; playKeyPickupSound(); updateKeyUI(); score += 50; scoreDisplay.textContent = score; return false; 
                    case TILE_KEY_YELLOW: this.keysCollected.yellow = true; gameMap[tileY][tileX] = TILE_EMPTY; playKeyPickupSound(); updateKeyUI(); score += 50; scoreDisplay.textContent = score; return false; 
                    case TILE_KEY_BLUE: this.keysCollected.blue = true; gameMap[tileY][tileX] = TILE_EMPTY; playKeyPickupSound(); updateKeyUI(); score += 50; scoreDisplay.textContent = score; return false; 
                    case TILE_EXIT: 
                        if (isCurrentLevelMiniBoss && currentBoss && currentBoss.health > 0) {
                             console.log("Mini-boss alive, cannot exit.");
                             return true; 
                        }
                        levelComplete(); 
                        return false; 
                    case TILE_WEAPON_SHOTGUN: this.addWeapon(WEAPON_STATS["Shotgun"]); gameMap[tileY][tileX] = TILE_EMPTY; return false; 
                    case TILE_WEAPON_MACHINEGUN: this.addWeapon(WEAPON_STATS["Machine Gun"]); gameMap[tileY][tileX] = TILE_EMPTY; return false; 
                    case TILE_WEAPON_ROCKETLAUNCHER: this.addWeapon(WEAPON_STATS["Rocket Launcher"]); gameMap[tileY][tileX] = TILE_EMPTY; return false; 
                    case TILE_WEAPON_BFG: this.addWeapon(WEAPON_STATS["BFG"]); gameMap[tileY][tileX] = TILE_EMPTY; return false; 
                    case TILE_HEALTH_PACK: if (player) player.gainHealth(25); gameMap[tileY][tileX] = TILE_EMPTY; return false; 
                    case TILE_SECRET_DOOR: 
                        gameMap[tileY][tileX] = TILE_EMPTY;
                        playSecretDoorOpenSound();
                        updateVisibility(Math.floor(this.x / TILE_SIZE), Math.floor(this.y / TILE_SIZE), gameMap);
                        score += 25; 
                        scoreDisplay.textContent = score;
                        return false; 
                    case TILE_EMPTY: 
                    default: return false; 
                } 
            } 
            shoot() { 
                const weapon = this.getCurrentWeapon(); 
                if (!weapon.owned) { return; }
                if (weapon.ammo !== Infinity && weapon.ammo <= 0) { playEmptyGunSound(); this.shootCooldown = weapon.fireRate; if (this.currentWeaponIndex !== 0) { this.switchWeapon(0); if (mouse.down && this.getCurrentWeapon().singleShot && !this.justFiredPistolOnThisClick) { this.shoot(); this.justFiredPistolOnThisClick = true; } else if (mouse.down && !this.getCurrentWeapon().singleShot) { this.shoot(); } } return; } 
                playShootSound(weapon.name); this.shootCooldown = weapon.fireRate; if (weapon.ammo !== Infinity) { weapon.ammo--; } updateWeaponUI(); 
                const worldMouseX = mouse.x + camera.x; const worldMouseY = mouse.y + camera.y; const bulletAngle = Math.atan2(worldMouseY - this.y, worldMouseX - this.x); 
                for (let i = 0; i < weapon.numPellets; i++) { let currentBulletAngle = bulletAngle; if (weapon.spread > 0) { currentBulletAngle += (Math.random() - 0.5) * weapon.spread; } const bX = this.x + Math.cos(currentBulletAngle)*(this.radius+5); const bY = this.y + Math.sin(currentBulletAngle)*(this.radius+5); bullets.push(new Bullet(bX, bY, currentBulletAngle, weapon.bulletSpeed, 'player', weapon.damage, weapon.color, weapon.isRocket, weapon.aoeRadius, weapon.explosionDuration, weapon.isBFG, weapon.tracerDamage)); } } 
            takeDamage(amount) { if (this.canPhase) return; this.health -= amount; playPlayerHitSound(); if (this.health < 0) this.health = 0; healthDisplay.textContent = this.health; } 
            gainHealth(amount) { this.health += amount; if (this.health > this.maxHealth) this.health = this.maxHealth; healthDisplay.textContent = this.health; playHealthPickupSound(); } 
            collectAllKeys() { this.keysCollected.red = true; this.keysCollected.yellow = true; this.keysCollected.blue = true; updateKeyUI(); if (player) { updateVisibility(Math.floor(player.x / TILE_SIZE), Math.floor(player.y / TILE_SIZE), gameMap); } } 
            collectAllGuns() { 
                for (const weaponKey in WEAPON_STATS) {
                    const stats = WEAPON_STATS[weaponKey];
                    let weaponInstance = this.weapons.find(w => w.name === stats.name);
                    const evaluatedDamage = stats.damage(); 
                    if (weaponInstance) {
                        weaponInstance.owned = true;
                        weaponInstance.ammo = weaponInstance.maxAmmo;
                        weaponInstance.damage = evaluatedDamage; 
                    }
                }
                playWeaponPickupSound(); updateWeaponUI(); console.log("CHEAT: All guns collected and max ammo given!"); 
            } 
        }

        // Bullet Class
        class Bullet { constructor(x,y,angle,speed,owner, damage, color = '#ffeb3b', isRocket = false, aoeRadius = 0, explosionDuration = 0, isBFG = false, tracerDamage = 0, isSeeking = false) { this.x=x; this.y=y; this.angle = angle; this.initialSpeed = speed; this.dx=Math.cos(angle)*speed; this.dy=Math.sin(angle)*speed; this.owner=owner; this.damage = damage; this.color = (owner === 'enemy' || owner === 'boss') ? '#ff6600' : color; this.isRocket = isRocket; this.aoeRadius = aoeRadius; this.explosionDuration = explosionDuration; this.isBFGMainProjectile = isBFG; this.tracerDamage = tracerDamage; this.radius= (isRocket) ? 6 : (this.isBFGMainProjectile ? 12 : 4); this.life= isRocket ? 180 : (this.isBFGMainProjectile ? 200 : 120); this.isSeeking = isSeeking; this.seekTarget = (isSeeking && (owner === 'boss' || owner === 'enemy') && player) ? player : null; this.turnRate = 0.03; } draw() { ctx.fillStyle = this.color; if (this.isRocket || this.isBFGMainProjectile) { ctx.save(); ctx.translate(this.x, this.y); if (this.isRocket || this.isSeeking) ctx.rotate(Math.atan2(this.dy, this.dx)); if (this.isBFGMainProjectile) { ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = 'rgba(200, 255, 200, 0.3)'; ctx.beginPath(); ctx.arc(0, 0, this.radius * 1.5, 0, Math.PI * 2); ctx.fill(); } else { ctx.beginPath(); ctx.moveTo(-this.radius, -this.radius / 2); ctx.lineTo(this.radius, 0); ctx.lineTo(-this.radius, this.radius / 2); ctx.closePath(); ctx.fill(); } ctx.restore(); } else { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); } } update() { if (this.isSeeking && this.seekTarget && this.seekTarget.health > 0) { const targetAngle = Math.atan2(this.seekTarget.y - this.y, this.seekTarget.x - this.x); let currentAngle = Math.atan2(this.dy, this.dx); let angleDiff = targetAngle - currentAngle; while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI; while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI; if (Math.abs(angleDiff) > this.turnRate) { currentAngle += Math.sign(angleDiff) * this.turnRate; } else { currentAngle = targetAngle; } this.dx = Math.cos(currentAngle) * this.initialSpeed; this.dy = Math.sin(currentAngle) * this.initialSpeed; } this.x+=this.dx; this.y+=this.dy; this.life--; const tileX=Math.floor(this.x/TILE_SIZE); const tileY=Math.floor(this.y/TILE_SIZE); let hitImpassableTile = false; if (tileX < 0 || tileX >= MAP_COLS || tileY < 0 || tileY >= MAP_ROWS || (gameMap[tileY] && ( gameMap[tileY][tileX] === TILE_WALL || gameMap[tileY][tileX] === TILE_DOOR_RED || gameMap[tileY][tileX] === TILE_DOOR_YELLOW || gameMap[tileY][tileX] === TILE_DOOR_BLUE || gameMap[tileY][tileX] === TILE_SECRET_DOOR ))) { hitImpassableTile = true; } if (this.isBFGMainProjectile) { if (hitImpassableTile || this.life <= 0) { this.life = 0; playBFGImpactSound(); if (player) { fireBFGTracers(player, enemies, null, this.tracerDamage); } return; } } else if (this.isRocket) { let rocketHitEnemy = false; if (this.owner === 'player') { const allTargets = currentBoss ? [currentBoss, ...enemies] : enemies; for (const target of allTargets) { if (target && target.health > 0 && Math.hypot(this.x - target.x, this.y - target.y) < this.radius + target.radius) { rocketHitEnemy = true; break; } } } if (hitImpassableTile || rocketHitEnemy || this.life <= 0) { this.life = 0; explosions.push(new Explosion(this.x, this.y, this.aoeRadius, this.explosionDuration)); playRocketExplosionSound(); return; } } else { if (hitImpassableTile || this.life <= 0) { this.life = 0; return; } } } }
        
        // BFG Tracer Firing Logic
        function fireBFGTracers(playerOrigin, allTargets, directHitEnemy, tracerDamageValue) { if (!playerOrigin || !gameMap || !visibilityMap) return; const BFG_CONE_ANGLE = Math.PI / 1.5; const MAX_TRACER_TARGETS = 10; let tracerHitCount = 0; const potentialTargets = []; allTargets.forEach(enemy => { if (!enemy || enemy.health <= 0 || enemy === directHitEnemy) return; const enemyTileX = Math.floor(enemy.x / TILE_SIZE); const enemyTileY = Math.floor(enemy.y / TILE_SIZE); if (enemyTileY >= 0 && enemyTileY < MAP_ROWS && enemyTileX >=0 && enemyTileX < MAP_COLS && visibilityMap[enemyTileY][enemyTileX]) { const angleToEnemy = Math.atan2(enemy.y - playerOrigin.y, enemy.x - playerOrigin.x); const playerViewAngle = playerOrigin.angle; const normalizeAngle = (angle) => (angle % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI); const normalizedAngleToEnemy = normalizeAngle(angleToEnemy); const normalizedPlayerAngle = normalizeAngle(playerViewAngle); let angleDiff = Math.abs(normalizedPlayerAngle - normalizedAngleToEnemy); if (angleDiff > Math.PI) { angleDiff = 2 * Math.PI - angleDiff; } if (angleDiff <= BFG_CONE_ANGLE / 2) { if (isPathClear(playerOrigin.x, playerOrigin.y, enemy.x, enemy.y, gameMap)) { potentialTargets.push(enemy); } } } }); potentialTargets.sort((a, b) => { return Math.hypot(a.x - playerOrigin.x, a.y - playerOrigin.y) - Math.hypot(b.x - playerOrigin.x, b.y - playerOrigin.y); }); for (let i = 0; i < Math.min(potentialTargets.length, MAX_TRACER_TARGETS); i++) { const enemy = potentialTargets[i]; enemy.takeDamage(tracerDamageValue); temporaryVisualEffects.push({ type: 'bfg_tracer', startX: playerOrigin.x, startY: playerOrigin.y, endX: enemy.x, endY: enemy.y, life: 15, color: `rgba(0, 255, 0, ${0.5 + Math.random() * 0.3})` }); tracerHitCount++; } }

        // Explosion Class
        class Explosion { constructor(x, y, radius, duration, color = 'orange') { this.x = x; this.y = y; this.maxRadius = radius; this.currentRadius = 0; this.duration = duration; this.life = duration; this.color = color; this.damageDealt = false; } update() { this.life--; this.currentRadius = this.maxRadius * (1 - (this.life / this.duration) * (this.life / this.duration) ); if (!this.damageDealt && this.life < this.duration * 0.8) { const targetsToDamage = currentBoss && currentBoss.health > 0 ? [currentBoss, ...enemies] : [...enemies]; targetsToDamage.forEach(target => { if (target && target.health > 0 && Math.hypot(target.x - this.x, target.y - this.y) < this.currentRadius) { if (target instanceof Boss || target instanceof MiniBoss) target.takeDamage(100); else target.takeDamage(75); } }); if (player && Math.hypot(player.x - this.x, player.y - this.y) < this.currentRadius) { player.takeDamage(35); } this.damageDealt = true; } } draw() { if (this.life <= 0) return; const opacity = Math.max(0, this.life / this.duration); ctx.fillStyle = `rgba(255, ${Math.floor(165 * opacity) + 60}, 0, ${opacity * 0.6})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.currentRadius, 0, Math.PI * 2); ctx.fill(); if (this.currentRadius > TILE_SIZE * 0.2) { ctx.fillStyle = `rgba(255, 255, ${Math.floor(150 * opacity) + 100}, ${opacity * 0.8})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.currentRadius * 0.5, 0, Math.PI * 2); ctx.fill(); } } }
        
        // Enemy Class
        class Enemy { constructor(x, y, type = 'grunt') { this.x = x; this.y = y; this.enemyType = type; this.hitTimer = 0; this.state = 'wandering'; this.wanderTargetX = this.x; this.wanderTargetY = this.y; this.wanderTimer = 0; this.maxWanderTime = 120 + Math.floor(Math.random() * 60); this.detectionRadius = TILE_SIZE * 6; switch (type) { case 'rusher': this.radius = TILE_SIZE / 2.8; this.speed = (selectedDifficulty === 'easy' ? 1.0 : 1.5) + Math.random() * 0.5 + (currentLevel * 0.1); this.chaseSpeed = (selectedDifficulty === 'easy' ? 1.5 : 2.0) + Math.random() * 0.6 + (currentLevel * 0.15); this.health = 30 + currentLevel * 8; this.damage = 15 + currentLevel * 3; this.color = 'magenta'; this.canShoot = false; this.scoreValue = 120; break; case 'shooter': this.radius = TILE_SIZE / 2.5; this.speed = (0.7 + Math.random() * 0.3) + (currentLevel * 0.05); this.chaseSpeed = (0.9 + Math.random() * 0.4) + (currentLevel * 0.08); this.health = 40 + currentLevel * 10; this.damage = 8 + currentLevel * 2; this.color = `hsl(${220 + Math.random()*40}, 70%, 60%)`; this.canShoot = true; this.shootCooldown = 0; this.maxShootCooldown = 80 + Math.random() * 40; this.bulletSpeed = 6; this.bulletDamage = 7 + currentLevel * 1.5; this.detectionRadius = TILE_SIZE * 7; this.scoreValue = 150; break; case 'tank': this.radius = TILE_SIZE / 2; this.speed = (0.4 + Math.random() * 0.2) + (currentLevel * 0.03); this.chaseSpeed = (0.6 + Math.random() * 0.3) + (currentLevel * 0.05); this.health = 150 + currentLevel * 25; this.damage = 20 + currentLevel * 4; this.color = '#444444'; this.canShoot = false; this.detectionRadius = TILE_SIZE * 4.5; this.scoreValue = 250; break; case 'teleporter': this.radius = TILE_SIZE / 2.6; this.speed = 1.2 + Math.random() * 0.3 + (currentLevel * 0.06); this.chaseSpeed = 1.5 + Math.random() * 0.4 + (currentLevel * 0.08); this.health = 60 + currentLevel * 12; this.damage = 12 + currentLevel * 2.5; this.color = 'cyan'; this.canShoot = true; this.shootCooldown = 0; this.maxShootCooldown = 90 + Math.random() * 30; this.bulletSpeed = 7; this.bulletDamage = 8 + currentLevel * 1.8; this.teleportCooldown = 0; this.maxTeleportCooldown = 180 + Math.floor(Math.random() * 120); this.scoreValue = 180; break; case 'splitter': this.radius = TILE_SIZE / 2.2; this.speed = 0.6 + Math.random() * 0.2 + (currentLevel * 0.04); this.chaseSpeed = 0.8 + Math.random() * 0.3 + (currentLevel * 0.06); this.health = 100 + currentLevel * 20; this.damage = 18 + currentLevel * 3.5; this.color = 'darkorange'; this.canShoot = false; this.scoreValue = 200; break; case 'mini_splitter': this.radius = TILE_SIZE / 3.5; this.speed = 1.5 + Math.random() * 0.5 + (currentLevel * 0.1); this.chaseSpeed = 1.8 + Math.random() * 0.5 + (currentLevel * 0.12); this.health = 25 + currentLevel * 5; this.damage = 5 + currentLevel * 1; this.color = 'sandybrown'; this.canShoot = false; this.scoreValue = 50; break; case 'grunt': default: this.radius = TILE_SIZE / 2.5; this.speed = (0.8 + Math.random() * 0.4) + (currentLevel * 0.05); this.chaseSpeed = (1 + Math.random() * 0.5) + (currentLevel * 0.1); this.health = 50 + currentLevel * 10; this.damage = 10 + currentLevel * 2; this.color = `hsl(${Math.random() * 60}, 70%, 50%)`; this.canShoot = Math.random() < 0.15; this.shootCooldown = 0; this.maxShootCooldown = 100 + Math.random() * 50; this.bulletSpeed = 5; this.bulletDamage = 5 + currentLevel; this.scoreValue = 100; break; } this.maxHealth = this.health; } draw() { if (player && visibilityMap) { const enemyTileX = Math.floor(this.x / TILE_SIZE); const enemyTileY = Math.floor(this.y / TILE_SIZE); if (enemyTileY < 0 || enemyTileY >= MAP_ROWS || enemyTileX < 0 || enemyTileX >= MAP_COLS || !visibilityMap[enemyTileY][enemyTileX]) { return; } } ctx.fillStyle = this.hitTimer > 0 ? 'white' : this.color; ctx.beginPath(); if (this.enemyType === 'tank') { ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); } else if (this.enemyType === 'rusher' || this.enemyType === 'mini_splitter') { ctx.save(); ctx.translate(this.x, this.y); let angleToTarget = (this.state === 'wandering') ? Math.atan2(this.wanderTargetY - this.y, this.wanderTargetX - this.x) : Math.atan2(player.y - this.y, player.x - this.x); ctx.rotate(angleToTarget + Math.PI / 2); ctx.beginPath(); ctx.moveTo(0, -this.radius); ctx.lineTo(this.radius * 0.8, this.radius * 0.8); ctx.lineTo(-this.radius * 0.8, this.radius * 0.8); ctx.closePath(); ctx.fill(); ctx.restore(); } else { ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); } let targetX = player.x, targetY = player.y; if (this.state === 'wandering') { targetX = this.wanderTargetX; targetY = this.wanderTargetY; } const angleToTarget = Math.atan2(targetY - this.y, targetX - this.x); ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(this.x + Math.cos(angleToTarget) * this.radius * 0.5, this.y + Math.sin(angleToTarget) * this.radius * 0.5, this.radius * 0.2, 0, Math.PI * 2); ctx.fill(); if (this.health < this.maxHealth) { ctx.fillStyle = 'red'; ctx.fillRect(this.x - this.radius, this.y - this.radius - 10, this.radius * 2, 5); ctx.fillStyle = 'green'; ctx.fillRect(this.x - this.radius, this.y - this.radius - 10, (this.radius * 2) * (this.health / this.maxHealth), 5); } } update(){ if(this.hitTimer>0) this.hitTimer--; if(!player) return; const dTP = Math.hypot(this.x - player.x, this.y - player.y); if (this.enemyType === 'teleporter') { this.teleportCooldown--; if (this.teleportCooldown <= 0 && dTP < this.detectionRadius * 2) { this.teleport(); this.teleportCooldown = this.maxTeleportCooldown; if (this.canShoot && this.shootCooldown === 0) { this.shoot(); this.shootCooldown = this.maxShootCooldown; } } } if (this.canShoot && dTP < this.detectionRadius * (this.enemyType === 'shooter' || this.enemyType === 'teleporter' ? 1.5 : 1.2) && dTP > TILE_SIZE * 1.5) { this.state = 'shooting'; } else if (dTP < this.detectionRadius) { this.state = 'chasing'; } else { if (this.state === 'chasing' || this.state === 'shooting') this.setNewWanderTarget(); this.state = 'wandering'; } if (this.shootCooldown > 0) this.shootCooldown--; let tX, tY, cS; if (this.state === 'shooting') { tX=player.x; tY=player.y; cS=this.speed*0.5; if(this.shootCooldown===0 && this.canShoot){this.shoot();this.shootCooldown=this.maxShootCooldown;} } else if (this.state === 'chasing') { tX=player.x; tY=player.y; cS=this.chaseSpeed; } else { this.wanderTimer--; if (this.wanderTimer <= 0 || Math.hypot(this.x-this.wanderTargetX,this.y-this.wanderTargetY)<TILE_SIZE/2) this.setNewWanderTarget(); tX=this.wanderTargetX;tY=this.wanderTargetY;cS=this.speed; } const aTT=Math.atan2(tY-this.y,tX-this.x),mX=Math.cos(aTT)*cS,mY=Math.sin(aTT)*cS,nX=this.x+mX,nY=this.y+mY; if (!this.checkWallCollision(nX,this.y))this.x=nX; if(!this.checkWallCollision(this.x,nY))this.y=nY; if (dTP < this.radius+player.radius) { player.takeDamage(this.damage); this.x-=Math.cos(aTT)*TILE_SIZE*0.5; this.y-=Math.sin(aTT)*TILE_SIZE*0.5; if(this.state==='wandering')this.state='chasing';} } teleport() { playTeleportSound(); let newX, newY, validSpot = false; let attempts = 0; const teleportRadius = TILE_SIZE * 5; while (!validSpot && attempts < 20) { const angle = Math.random() * Math.PI * 2; const distance = TILE_SIZE * 2 + Math.random() * teleportRadius; newX = player.x + Math.cos(angle) * distance; newY = player.y + Math.sin(angle) * distance; newX = Math.max(this.radius, Math.min(newX, MAP_COLS * TILE_SIZE - this.radius)); newY = Math.max(this.radius, Math.min(newY, MAP_ROWS * TILE_SIZE - this.radius)); const tileX = Math.floor(newX / TILE_SIZE); const tileY = Math.floor(newY / TILE_SIZE); if (tileX >= 0 && tileX < MAP_COLS && tileY >= 0 && tileY < MAP_ROWS && gameMap[tileY][tileX] === TILE_EMPTY) { let tooCloseToOtherEnemy = false; for(const otherEnemy of enemies){ if(otherEnemy !== this && Math.hypot(newX - otherEnemy.x, newY - otherEnemy.y) < (this.radius + otherEnemy.radius) * 1.5){ tooCloseToOtherEnemy = true; break; } } if(!tooCloseToOtherEnemy) validSpot = true; } attempts++; } if (validSpot) { this.x = newX; this.y = newY; } } shoot() { if (!player || !this.canShoot) return; playEnemyShootSound(); const aTP = Math.atan2(player.y-this.y,player.x-this.x); const inaccuracy = (Math.random()-0.5) * (this.enemyType === 'shooter' || this.enemyType === 'teleporter' ? 0.15 : 0.25); const bA=aTP+inaccuracy; const bX=this.x+Math.cos(bA)*(this.radius+5),bY=this.y+Math.sin(bA)*(this.radius+5); bullets.push(new Bullet(bX,bY,bA,this.bulletSpeed,'enemy',this.bulletDamage)); } setNewWanderTarget() { let nTF=false,att=0;const MAX_A=10; while(!nTF&&att<MAX_A){ const wA=Math.random()*Math.PI*2,wD=TILE_SIZE*(Math.random()*3+2); let tTX=this.x+Math.cos(wA)*wD,tTY=this.y+Math.sin(wA)*wD; tTX=Math.max(TILE_SIZE*1.5,Math.min(tTX,(MAP_COLS*TILE_SIZE)-TILE_SIZE*1.5)); tTY=Math.max(TILE_SIZE*1.5,Math.min(tTY,(MAP_ROWS*TILE_SIZE)-TILE_SIZE*1.5)); const tX=Math.floor(tTX/TILE_SIZE),tY=Math.floor(tTY/TILE_SIZE); if(tX>0&&tX<MAP_COLS-1&&tY>0&&tY<MAP_ROWS-1&&gameMap[tY][tX]===TILE_EMPTY){this.wanderTargetX=tTX;this.wanderTargetY=tTY;nTF=true;} att++; } if(!nTF){this.wanderTargetX=Math.floor(this.x/TILE_SIZE)*TILE_SIZE+TILE_SIZE/2;this.wanderTargetY=Math.floor(this.y/TILE_SIZE)*TILE_SIZE+TILE_SIZE/2;} this.wanderTimer=this.maxWanderTime; } checkWallCollision(cX,cY){ const co=[{x:Math.floor((cX-this.radius)/TILE_SIZE),y:Math.floor((cY-this.radius)/TILE_SIZE)},{x:Math.floor((cX+this.radius)/TILE_SIZE),y:Math.floor((cY-this.radius)/TILE_SIZE)},{x:Math.floor((cX-this.radius)/TILE_SIZE),y:Math.floor((cY+this.radius)/TILE_SIZE)},{x:Math.floor((cX+this.radius)/TILE_SIZE),y:Math.floor((cY+this.radius)/TILE_SIZE)}]; for(const t of co) { if(t.x<0||t.x>=MAP_COLS||t.y<0||t.y>=MAP_ROWS|| (gameMap[t.y] && (gameMap[t.y][t.x] === TILE_WALL || gameMap[t.y][t.x] === TILE_DOOR_RED || gameMap[t.y][t.x] === TILE_DOOR_YELLOW || gameMap[t.y][t.x] === TILE_DOOR_BLUE || gameMap[t.y][t.x] === TILE_SECRET_DOOR))) return true; } return false; } 
            takeDamage(amount){ 
                this.health-=amount; this.hitTimer=5; playHitSound(); this.state = 'chasing'; 
                if(this.health<=0){ 
                    score+= this.scoreValue; 
                    scoreDisplay.textContent=score; 
                    enemiesRemaining--; 
                    playEnemyDestroySound(); 
                    if(Math.random()<0.25){ 
                        const ammoTypes = ["Shotgun", "Machine Gun", "Rocket Launcher", "BFG"]; 
                        const selectedAmmoType = ammoTypes[Math.floor(Math.random()*ammoTypes.length)]; 
                        const weaponStats = WEAPON_STATS[selectedAmmoType];
                        if (weaponStats && weaponStats.maxAmmo !== Infinity) {
                            let ammoDropAmount = Math.max(1, Math.floor(weaponStats.maxAmmo * 0.05)); 
                            ammoPacks.push(new AmmoPack(this.x, this.y, selectedAmmoType, ammoDropAmount)); 
                        }
                    } else if(Math.random()<0.15) { 
                        healthPacks.push(new HealthPack(this.x,this.y)); 
                    } 
                    if (this.enemyType === 'splitter') { 
                        spawnMiniSplitters(this.x, this.y);
                    }
                    return true; 
                } else { 
                    return false; 
                }
            }
        }
        
        // MiniBoss Class (for level 3 and random encounters)
        class MiniBoss extends Enemy {
            constructor(x, y) {
                super(x, y, 'grunt'); // Base properties
                this.enemyType = 'mini_boss_rl_dropper'; // Specific type for MiniBoss
                this.radius = TILE_SIZE * 0.8; 
                this.speed = 0.7;
                this.chaseSpeed = 1.0;
                this.health = 300 * (selectedDifficulty === 'easy' ? 0.8 : (selectedDifficulty === 'hard' ? 1.2 : 1));
                this.maxHealth = this.health;
                this.damage = 20; 
                this.color = '#AA00AA'; // Distinct color
                this.canShoot = true;
                this.shootCooldown = 0;
                this.maxShootCooldown = 90; 
                this.bulletSpeed = 7;
                this.bulletDamage = 15;
                this.scoreValue = 400;
                this.droppedWeapon = false; 
            }

            takeDamage(amount) {
                const killed = super.takeDamage(amount); 
                if (killed && !this.droppedWeapon && player) {
                    console.log("MiniBoss defeated, dropping Rocket Launcher!");
                    const rlStats = WEAPON_STATS["Rocket Launcher"];
                    let weaponInstance = player.weapons.find(w => w.name === "Rocket Launcher");
                    if (weaponInstance && !weaponInstance.owned) {
                         player.addWeapon({ ...rlStats, name: "Rocket Launcher", owned: true, ammo: rlStats.pickupAmmo });
                    } else if (weaponInstance && weaponInstance.owned) {
                        player.addAmmo("Rocket Launcher", rlStats.pickupAmmo);
                    } else { 
                         player.addWeapon({ ...rlStats, name: "Rocket Launcher", owned: true, ammo: rlStats.pickupAmmo });
                    }
                    this.droppedWeapon = true;
                }
                return killed;
            }
        }


        // Boss Class
        class Boss { constructor(x, y, level) { this.x = x; this.y = y; this.bossTier = Math.max(1, Math.floor(level / 5)); this.radius = TILE_SIZE * (0.8 + this.bossTier * 0.4); this.speed = 0.5 + this.bossTier * 0.1; this.maxHealth = 250 * Math.pow(1.8, this.bossTier -1) * (selectedDifficulty === 'easy' ? 0.7 : (selectedDifficulty === 'hard' ? 1.3 : 1)); this.health = this.maxHealth; this.damage = 25 + this.bossTier * 10; this.color = `hsl(${this.bossTier * 40}, 80%, 40%)`; this.hitTimer = 0; this.scoreValue = 500 * this.bossTier; this.state = 'moving'; this.moveTargetX = this.x; this.moveTargetY = this.y; this.moveTimer = 0; this.maxMoveTime = 150 - this.bossTier * 10; this.shootCooldown = 0; this.maxShootCooldown = Math.max(30, 100 - this.bossTier * 10); this.numProjectiles = 1 + Math.floor((this.bossTier-1) * 0.8); this.projectileSpread = 0.15 + this.bossTier * 0.05; this.bulletSpeed = 5 + this.bossTier * 0.5; this.bulletDamage = 15 + this.bossTier * 5; this.seekingShotCooldown = 0; this.maxSeekingShotCooldown = Math.max(120, 300 - this.bossTier * 30); this.canUseSeekingShot = this.bossTier >= 2; } draw() { ctx.fillStyle = this.hitTimer > 0 ? 'white' : this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); const angleToPlayer = player ? Math.atan2(player.y - this.y, player.x - this.x) : 0; ctx.fillStyle = 'black'; for (let i = -1; i <= 1; i += 2) { const eyeOffsetX = Math.cos(angleToPlayer + i * 0.5) * this.radius * 0.5; const eyeOffsetY = Math.sin(angleToPlayer + i * 0.5) * this.radius * 0.5; ctx.beginPath(); ctx.arc(this.x + eyeOffsetX, this.y + eyeOffsetY, this.radius * 0.15, 0, Math.PI * 2); ctx.fill(); } if (this.health < this.maxHealth) { const barWidth = VIEWPORT_WIDTH * 0.6; const barHeight = 20; const barX = camera.x + (VIEWPORT_WIDTH - barWidth) / 2; const barY = camera.y + VIEWPORT_HEIGHT - barHeight - 20; ctx.fillStyle = 'darkred'; ctx.fillRect(barX, barY, barWidth, barHeight); ctx.fillStyle = 'red'; ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight); ctx.strokeStyle = 'white'; ctx.strokeRect(barX, barY, barWidth, barHeight); ctx.fillStyle = 'white'; ctx.font = '12px "Press Start 2P"'; ctx.textAlign = 'center'; ctx.fillText(`BOSS HEALTH: ${Math.ceil(this.health)} / ${Math.ceil(this.maxHealth)}`, camera.x + VIEWPORT_WIDTH / 2, barY + barHeight / 2 + 4); } } update() { if (this.hitTimer > 0) this.hitTimer--; if (!player) return; this.moveTimer--; if (this.moveTimer <= 0) { this.setNewMoveTarget(); } const angleToMoveTarget = Math.atan2(this.moveTargetY - this.y, this.moveTargetX - this.x); const moveX = Math.cos(angleToMoveTarget) * this.speed; const moveY = Math.sin(angleToMoveTarget) * this.speed; if (!this.checkWallCollision(this.x + moveX, this.y)) this.x += moveX; if (!this.checkWallCollision(this.x, this.y + moveY)) this.y += moveY; if (Math.hypot(this.x - player.x, this.y - player.y) < this.radius + player.radius) { player.takeDamage(this.damage); } this.shootCooldown--; if (this.shootCooldown <= 0) { this.shoot(); this.shootCooldown = this.maxShootCooldown; } if (this.canUseSeekingShot) { this.seekingShotCooldown--; if (this.seekingShotCooldown <= 0) { this.fireSeekingShot(); this.seekingShotCooldown = this.maxSeekingShotCooldown; } } } 
            fireSeekingShot() { 
                if (!player) return; 
                playBossSeekingShootSound(); 
                const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x); 
                bullets.push(new Bullet( this.x, this.y, angleToPlayer, this.bulletSpeed * 0.7, 'boss', this.bulletDamage * 1.2, '#FF8800', false, 0, 0, false, 0, true )); 
            } 
            shoot() { 
                if (!player) return; 
                playBossRegularShootSound(); 
                const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x); 
                for (let i = 0; i < this.numProjectiles; i++) { 
                    let currentBulletAngle = angleToPlayer; 
                    if (this.numProjectiles > 1) { 
                        currentBulletAngle += (i - (this.numProjectiles - 1) / 2) * this.projectileSpread / (this.numProjectiles -1 + 0.001) ; 
                    } 
                    const bulletX = this.x + Math.cos(currentBulletAngle) * (this.radius + 5); 
                    const bulletY = this.y + Math.sin(currentBulletAngle) * (this.radius + 5); 
                    bullets.push(new Bullet(bulletX, bulletY, currentBulletAngle, this.bulletSpeed, 'boss', this.bulletDamage, '#FF33CC')); 
                } 
            } 
            setNewMoveTarget() { const attempts = 5; for (let i = 0; i < attempts; i++) { const angle = Math.random() * Math.PI * 2; const distance = TILE_SIZE * (Math.random() * 5 + 3); let targetX = this.x + Math.cos(angle) * distance; let targetY = this.y + Math.sin(angle) * distance; targetX = Math.max(this.radius, Math.min(targetX, MAP_COLS * TILE_SIZE - this.radius)); targetY = Math.max(this.radius, Math.min(targetY, MAP_ROWS * TILE_SIZE - this.radius)); const tileX = Math.floor(targetX / TILE_SIZE); const tileY = Math.floor(targetY / TILE_SIZE); if (tileX > 0 && tileX < MAP_COLS -1 && tileY > 0 && tileY < MAP_ROWS -1 && gameMap[tileY][tileX] === TILE_EMPTY) { if (isPathClear(this.x, this.y, targetX, targetY, gameMap, TILE_SIZE)) { this.moveTargetX = targetX; this.moveTargetY = targetY; this.moveTimer = this.maxMoveTime; return; } } } this.moveTargetX = player.x; this.moveTargetY = player.y; this.moveTimer = this.maxMoveTime / 2; } checkWallCollision(checkX, checkY) { const corners = [ { x: Math.floor((checkX - this.radius) / TILE_SIZE), y: Math.floor((checkY - this.radius) / TILE_SIZE) }, { x: Math.floor((checkX + this.radius) / TILE_SIZE), y: Math.floor((checkY - this.radius) / TILE_SIZE) }, { x: Math.floor((checkX - this.radius) / TILE_SIZE), y: Math.floor((checkY + this.radius) / TILE_SIZE) }, { x: Math.floor((checkX + this.radius) / TILE_SIZE), y: Math.floor((checkY + this.radius) / TILE_SIZE) }, ]; for (const tile of corners) { if (tile.x < 0 || tile.x >= MAP_COLS || tile.y < 0 || tile.y >= MAP_ROWS || (gameMap[tile.y] && (gameMap[tile.y][tile.x] === TILE_WALL || gameMap[tile.y][tile.x] === TILE_DOOR_RED || gameMap[tile.y][tile.x] === TILE_DOOR_YELLOW || gameMap[tile.y][tile.x] === TILE_DOOR_BLUE || gameMap[tile.y][tile.x] === TILE_SECRET_DOOR))) { return true; } } return false; } 
            takeDamage(amount) { 
                this.health -= amount; 
                this.hitTimer = 10; 
                playBossHitSound(); 
                if (this.health <= 0) { 
                    this.health = 0; 
                    score += this.scoreValue; 
                    scoreDisplay.textContent = score; 
                    playBossDeathSound(); 
                    enemiesRemaining--; 
                    return true; 
                } 
                return false; 
            } 
        }
        
        // spawnMiniSplitters
        function spawnMiniSplitters(x, y) { playSplitSound(); for (let i = 0; i < 2; i++) { let sX, sY, validSpawn = false; let attempts = 0; while(!validSpawn && attempts < 10) { sX = x + (Math.random() - 0.5) * TILE_SIZE; sY = y + (Math.random() - 0.5) * TILE_SIZE; const tileX = Math.floor(sX / TILE_SIZE); const tileY = Math.floor(sY / TILE_SIZE); if (tileX >= 0 && tileX < MAP_COLS && tileY >= 0 && tileY < MAP_ROWS && gameMap[tileY][tileX] === TILE_EMPTY) { validSpawn = true; } attempts++; } if (!validSpawn) { sX = x; sY = y; } enemies.push(new Enemy(sX,sY, 'mini_splitter')); enemiesRemaining++; } }

        // Game Initialization and State Management
        function startGame() { 
            console.log("startGame: Called. Resetting game state.");
            score = 0; currentLevel = 1; gameOver = false;
            nextMiniBossSpawnLevel = 0; 
            
            let playerSpawnX = (MAP_COLS * TILE_SIZE) / 2; 
            let playerSpawnY = (MAP_ROWS * TILE_SIZE) / 2;
            
            console.log("startGame: Creating new player instance.");
            player = new Player(playerSpawnX, playerSpawnY);
             if (isNaN(player.x) || isNaN(player.y)) {
                console.error("CRITICAL ERROR in startGame: Player position is NaN immediately after creation. Defaulting to absolute center.");
                player.x = VIEWPORT_WIDTH / 2; 
                player.y = VIEWPORT_HEIGHT / 2;
            }
            console.log(`startGame: Player instance created at x:${player.x}, y:${player.y}`);

            initLevel(); 
            console.log("startGame: Completed.");
        }

        function initLevel() { 
            console.log(`initLevel (Level ${currentLevel}): Start.`);
            isLevelCompleting = false; 
            gameRunning = true; 
            currentBoss = null; 
            
            isBossLevel = (currentLevel % 5 === 0);
            isCurrentLevelMiniBoss = false;

            if (!isBossLevel) { 
                if (currentLevel === 3) {
                    isCurrentLevelMiniBoss = true;
                    console.log("Level 3: Mini-Boss will spawn.");
                    nextMiniBossSpawnLevel = currentLevel + MINI_BOSS_SPAWN_INTERVAL_MIN + Math.floor(Math.random() * (MINI_BOSS_SPAWN_INTERVAL_MAX - MINI_BOSS_SPAWN_INTERVAL_MIN + 1));
                } else if (currentLevel > 3) {
                    if (nextMiniBossSpawnLevel === 0 || currentLevel >= nextMiniBossSpawnLevel ) { 
                         isCurrentLevelMiniBoss = true;
                         console.log(`Level ${currentLevel}: Random Mini-Boss will spawn.`);
                         nextMiniBossSpawnLevel = currentLevel + MINI_BOSS_SPAWN_INTERVAL_MIN + Math.floor(Math.random() * (MINI_BOSS_SPAWN_INTERVAL_MAX - MINI_BOSS_SPAWN_INTERVAL_MIN + 1));
                         console.log("Next potential Mini-Boss level is now:", nextMiniBossSpawnLevel);
                    }
                }
            }
            
            gameMap = Array(MAP_ROWS).fill(null).map(() => Array(MAP_COLS).fill(TILE_EMPTY));
            visibilityMap = Array(MAP_ROWS).fill(null).map(() => Array(MAP_COLS).fill(true)); 
            
            const mapData = generateMaze(MAP_COLS, MAP_ROWS, isBossLevel); 
            gameMap = mapData.gameMap;
            
            if (player) {
                player.x = mapData.playerStart.c * TILE_SIZE + TILE_SIZE/2;
                player.y = mapData.playerStart.r * TILE_SIZE + TILE_SIZE/2;
                if (!isBossLevel) { 
                    player.keysCollected = { red: false, yellow: false, blue: false };
                }
            } else {
                 console.error("initLevel: Player object is null!");
                 showStartScreen(); 
                 return;
            }

            updateKeyUI();
            updateWeaponUI(); 
            if (player && gameMap && gameMap.length > 0 && gameMap[0] && gameMap[0].length > 0) { 
                updateVisibility(Math.floor(player.x / TILE_SIZE), Math.floor(player.y / TILE_SIZE), gameMap); 
            }
            
            bullets = []; enemies = []; healthPacks = []; ammoPacks = []; explosions = []; temporaryVisualEffects = []; 
            
            if(player) camera.update(player); 
            scoreDisplay.textContent = score; 
            waveDisplay.textContent = currentLevel; 
            
            resetLevelParameters(); 

            if (isBossLevel) {
                console.log(`initLevel: Spawning Main Boss for level ${currentLevel}`);
                let bossSpawnX = mapData.bossSpawn ? mapData.bossSpawn.c * TILE_SIZE + TILE_SIZE / 2 : MAP_COLS / 2 * TILE_SIZE; 
                let bossSpawnY = mapData.bossSpawn ? mapData.bossSpawn.r * TILE_SIZE + TILE_SIZE / 2 : MAP_ROWS / 2 * TILE_SIZE;
                currentBoss = new Boss(bossSpawnX, bossSpawnY, currentLevel);
                enemiesRemaining = 1; 
            } else { 
                spawnInitialEnemies(); 
                console.log(`initLevel: Initial regular enemies spawned. Count: ${enemiesRemaining}`);

                if (isCurrentLevelMiniBoss) {
                    console.log(`initLevel: Spawning MiniBoss for level ${currentLevel}`);
                    let exitTile = null;
                    for (let r = 0; r < MAP_ROWS; r++) {
                        for (let c = 0; c < MAP_COLS; c++) {
                            if (gameMap[r][c] === TILE_EXIT) {
                                exitTile = { r, c }; break;
                            }
                        }
                        if (exitTile) break;
                    }

                    if (exitTile) {
                        let miniBossSpawnX, miniBossSpawnY;
                        let foundSpawn = false;
                        const directions = [[0,0],[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1],[-2,0],[2,0],[0,-2],[0,2],[-2,-1],[-2,1],[2,-1],[2,1],[-1,-2],[1,-2],[-1,2],[1,2]]; 
                        directions.sort(() => Math.random() - 0.5); 

                        for(const [dr,dc] of directions) {
                            const checkR = exitTile.r + dr;
                            const checkC = exitTile.c + dc;
                            if (checkR >= 0 && checkR < MAP_ROWS && checkC >= 0 && checkC < MAP_COLS && gameMap[checkR][checkC] === TILE_EMPTY) {
                                const tempX = checkC * TILE_SIZE + TILE_SIZE / 2;
                                const tempY = checkR * TILE_SIZE + TILE_SIZE / 2;
                                if (player && Math.hypot(tempX - player.x, tempY - player.y) > TILE_SIZE * 4) { 
                                     miniBossSpawnX = tempX;
                                     miniBossSpawnY = tempY;
                                     foundSpawn = true;
                                     break;
                                }
                            }
                        }
                         if (!foundSpawn) { 
                            if(gameMap[exitTile.r][exitTile.c] === TILE_EMPTY){
                                miniBossSpawnX = exitTile.c * TILE_SIZE + TILE_SIZE / 2;
                                miniBossSpawnY = exitTile.r * TILE_SIZE + TILE_SIZE / 2;
                            } else {
                                console.warn("Mini-boss fallback: Exit tile not empty. Searching for any empty tile.");
                                let fallbackEmpty = null;
                                for (let r_fb = MAP_ROWS -1; r_fb >=0 ; r_fb--) { 
                                    for (let c_fb = MAP_COLS-1; c_fb >=0; c_fb--) {
                                        if (gameMap[r_fb][c_fb] === TILE_EMPTY && (player && Math.hypot((c_fb+0.5)*TILE_SIZE - player.x, (r_fb+0.5)*TILE_SIZE - player.y) > TILE_SIZE * 5) ) {
                                            fallbackEmpty = {r: r_fb, c: c_fb}; break;
                                        }
                                    }
                                    if(fallbackEmpty) break;
                                }
                                if(fallbackEmpty){
                                    miniBossSpawnX = fallbackEmpty.c * TILE_SIZE + TILE_SIZE / 2;
                                    miniBossSpawnY = fallbackEmpty.r * TILE_SIZE + TILE_SIZE / 2;
                                } else {
                                     miniBossSpawnX = (MAP_COLS / 2) * TILE_SIZE; 
                                     miniBossSpawnY = (MAP_ROWS / 2) * TILE_SIZE;
                                     console.error("Mini-boss absolute fallback: No suitable empty tile found, placing at center.");
                                }
                            }
                        }
                        currentBoss = new MiniBoss(miniBossSpawnX, miniBossSpawnY);
                        enemiesRemaining++; 
                        console.log(`initLevel: MiniBoss spawned. Total enemies on level: ${enemiesRemaining}`);
                    } else {
                         console.error("initLevel: Could not find TILE_EXIT to spawn MiniBoss! Mini-boss not spawned this time.");
                         isCurrentLevelMiniBoss = false; 
                    }
                }
            }
            
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
            }
            messageOverlay.style.display = 'none'; 
            difficultySelectionDiv.style.display = 'flex'; 
            
            if (ctx) { 
                draw(); 
            }
            gameLoopId = requestAnimationFrame(gameLoop);
        }
        
        function findRoomsInMap(currentMap) {
            if (!currentMap || !currentMap.length || !currentMap[0] || !currentMap[0].length) { 
                console.warn("findRoomsInMap: currentMap is invalid.");
                return [];
            }
            const visited = Array(MAP_ROWS).fill(null).map(() => Array(MAP_COLS).fill(false));
            const foundRooms = [];
            function getRoomSize(r, c) {
                if (r < 0 || r >= MAP_ROWS || c < 0 || c >= MAP_COLS || visited[r][c] || !currentMap[r] || currentMap[r][c] !== TILE_EMPTY) { return null; }
                const queue = [[r,c]]; visited[r][c] = true; const roomTiles = [];
                let minR = r, maxR = r, minC = c, maxC = c;
                while(queue.length > 0) {
                    const [currR, currC] = queue.shift(); roomTiles.push({r: currR, c: currC});
                    minR = Math.min(minR, currR); maxR = Math.max(maxR, currR); minC = Math.min(minC, currC); maxC = Math.max(maxC, currC);
                    const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
                    for(const [dr,dc] of dirs) {
                        const nr = currR + dr; const nc = currC + dc;
                        if (nr >= 0 && nr < MAP_ROWS && nc >= 0 && nc < MAP_COLS && !visited[nr][nc] && currentMap[nr] && currentMap[nr][nc] === TILE_EMPTY) {
                            visited[nr][nc] = true; queue.push([nr, nc]);
                        }
                    }
                }
                if (roomTiles.length > 10) { return { x: minC, y: minR, width: maxC - minC + 1, height: maxR - minR + 1, center: { x: Math.floor((minC+maxC)/2) , y: Math.floor((minR+maxR)/2) } }; }
                return null;
            }
            for (let r_idx = 0; r_idx < MAP_ROWS; r_idx++) { for (let c_idx = 0; c_idx < MAP_COLS; c_idx++) {
                    if (!visited[r_idx][c_idx] && currentMap[r_idx] && currentMap[r_idx][c_idx] === TILE_EMPTY) {
                        const room = getRoomSize(r_idx,c_idx); if (room) foundRooms.push(room);
                    }
            } }
            return foundRooms;
        }

        function resetLevelParameters() { 
            if (isBossLevel) { 
                enemiesToSpawnPerLevel = 0; 
            } else { 
                switch(selectedDifficulty) { 
                    case 'easy': enemiesToSpawnPerLevel = Math.floor((6 + (currentLevel - 1) * 2) * 1.5); break; 
                    case 'hard': enemiesToSpawnPerLevel = Math.floor((12 + (currentLevel - 1) * 4) * 1.5); break; 
                    case 'medium': default: enemiesToSpawnPerLevel = Math.floor((10 + (currentLevel - 1) * 3) * 1.5); break; 
                } 
            } 
            enemiesSpawnedThisLevel = 0; 
            enemiesRemaining = 0; 
        }
        function spawnInitialEnemies() { 
            if (isBossLevel) return; 
            let validSpawnLocations = []; 
            if (player && gameMap) { 
                for (let r = 0; r < MAP_ROWS; r++) { 
                    for (let c = 0; c < MAP_COLS; c++) { 
                        if (gameMap[r][c] === TILE_EMPTY) { 
                            const spawnX = c * TILE_SIZE + TILE_SIZE / 2; 
                            const spawnY = r * TILE_SIZE + TILE_SIZE / 2; 
                            if (Math.hypot(spawnX - player.x, spawnY - player.y) > VIEWPORT_WIDTH / 3) { 
                                validSpawnLocations.push({ x: spawnX, y: spawnY }); 
                            } 
                        } 
                    } 
                } 
            } 
            for(let i=0; i < enemiesToSpawnPerLevel; i++) { 
                spawnEnemy(validSpawnLocations); 
            } 
        }
        function spawnEnemy(validSpawnLocations) { if (!player) return; let sX, sY, vS = false; if (validSpawnLocations && validSpawnLocations.length > 0) { const spawnIndex = Math.floor(Math.random() * validSpawnLocations.length); const spawnPoint = validSpawnLocations.splice(spawnIndex, 1)[0]; sX = spawnPoint.x; sY = spawnPoint.y; vS = true; } else { let att = 0; const MAX_A = 20; while(!vS && att < MAX_A){ const randR = Math.floor(Math.random() * MAP_ROWS); const randC = Math.floor(Math.random() * MAP_COLS); if (gameMap[randR][randC] === TILE_EMPTY) { sX = randC * TILE_SIZE + TILE_SIZE / 2; sY = randR * TILE_SIZE + TILE_SIZE / 2; if(Math.hypot(sX-player.x,sY-player.y)>VIEWPORT_WIDTH/3) vS=true; } att++; } } if(vS){ let enemyType = 'grunt'; const rand = Math.random(); if (currentLevel > 1 && rand < 0.15) enemyType = 'rusher'; else if (currentLevel > 2 && rand < 0.30) enemyType = 'shooter'; else if (currentLevel > 3 && rand < 0.45 && selectedDifficulty !== 'easy') enemyType = 'tank'; else if (currentLevel > 2 && rand < 0.60) enemyType = 'teleporter'; else if (currentLevel > 3 && rand < 0.75 && selectedDifficulty !== 'easy') enemyType = 'splitter'; enemies.push(new Enemy(sX,sY, enemyType)); enemiesSpawnedThisLevel++; enemiesRemaining++; } }
        
        function levelComplete() { 
            if (isLevelCompleting) return; 
            isLevelCompleting = true; 
            gameRunning = false; 
            if(gameLoopId) cancelAnimationFrame(gameLoopId); 
            messageTitle.textContent = (isBossLevel || isCurrentLevelMiniBoss) ? "BOSS DEFEATED!" : "Level Cleared!"; 
            messageText.innerHTML = `Level ${currentLevel} complete! Score: ${score} <br> Click 'Next Level' to continue.`; 
            messageOverlay.style.display = 'flex'; 
            restartButton.textContent = "Next Level"; 
            difficultySelectionDiv.style.display = 'none'; 
            instructionsButton.style.display = 'none'; 
        }
        
        let frameCount = 0; 
        function gameLoop(){ 
            frameCount++;
            if(!gameRunning || gameOver) {
                return;
            }
            try {
                update(); 
                draw(); 
                gameLoopId=requestAnimationFrame(gameLoop);
            } catch (e) {
                console.error("FATAL ERROR in gameLoop:", e, e.stack);
                gameRunning = false; 
                messageTitle.textContent = "Critical Error!";
                messageText.innerHTML = `A critical error occurred: ${e.message || JSON.stringify(e)}.<br>Check console for details. Restart required. Stack: ${e.stack || 'N/A'}`;
                messageOverlay.style.display = 'flex';
                restartButton.textContent = "Restart Game"; 
            }
        }
        function update(){
            try {
                if(!player) {
                    console.error("update: Player is null, cannot update.");
                    gameRunning = false; 
                    return;
                }
                const prevPlayerTileX = Math.floor(player.x / TILE_SIZE); 
                const prevPlayerTileY = Math.floor(player.y / TILE_SIZE); 
                player.update(); 
                camera.update(player); 
                const newPlayerTileX = Math.floor(player.x / TILE_SIZE); 
                const newPlayerTileY = Math.floor(player.y / TILE_SIZE); 
                if (newPlayerTileX !== prevPlayerTileX || newPlayerTileY !== prevPlayerTileY) { 
                    if (player && gameMap && gameMap.length > 0 && gameMap[0] && gameMap[0].length > 0) updateVisibility(newPlayerTileX, newPlayerTileY, gameMap); 
                } 
                bullets = bullets.filter(b => b.life > 0); bullets.forEach(b => b.update()); 
                explosions = explosions.filter(exp => exp.life > 0); explosions.forEach(exp => exp.update()); 
                temporaryVisualEffects = temporaryVisualEffects.filter(eff => eff.life > 0); temporaryVisualEffects.forEach(eff => eff.life--); 
                healthPacks.forEach((p, i) => { if(player && Math.hypot(player.x-p.x,player.y-p.y)<player.radius+p.radius){player.gainHealth(p.healthValue);healthPacks.splice(i,1);}}); 
                ammoPacks.forEach((pack, i) => {
                    if (player && Math.hypot(player.x - pack.x, player.y - pack.y) < player.radius + pack.radius) {
                        player.addAmmo(pack.weaponName, pack.ammoAmount); 
                        ammoPacks.splice(i, 1);
                    }
                });
                
                // Update currentBoss (main or mini-boss) if it exists
                if (currentBoss) {
                    currentBoss.update();
                    if (currentBoss.health <= 0) { // Boss/Mini-boss defeated
                        if (!isLevelCompleting) { 
                            levelComplete(); // This will set isLevelCompleting to true
                        }
                        currentBoss = null; // Clear the boss
                        // enemiesRemaining was already decremented by Boss/MiniBoss takeDamage
                    } else {
                        // Bullet collision with currentBoss
                        bullets = bullets.filter(b => {
                            if (b.owner === 'player' && currentBoss && Math.hypot(b.x - currentBoss.x, b.y - currentBoss.y) < b.radius + currentBoss.radius) {
                                if (b.isBFGMainProjectile) {
                                    currentBoss.takeDamage(b.damage); b.life = 0; playBFGImpactSound();
                                    if (player) fireBFGTracers(player, enemies, currentBoss, b.tracerDamage); 
                                } else {
                                    currentBoss.takeDamage(b.damage); b.life = 0;
                                }
                                return false;
                            }
                            return true;
                        });
                        // Boss/Mini-boss bullets hitting player
                        bullets.forEach((b, bi) => {
                            if (b.owner === 'boss' && player && Math.hypot(b.x - player.x, b.y - player.y) < b.radius + player.radius) {
                                player.takeDamage(b.damage); bullets.splice(bi, 1);
                            }
                        });
                    }
                }

                // Update and process regular enemies
                let activeEnemies = [...enemies]; 
                enemies = []; 
                activeEnemies.forEach(e => { 
                    if (!e) { console.warn("Update: Found null/undefined enemy in currentEnemies array, skipping."); return; }
                    e.update(); 
                    let enemySurvived = true; 
                    bullets = bullets.filter(b => { 
                        if (b.owner === 'player' && Math.hypot(b.x - e.x, b.y - e.y) < b.radius + e.radius) { 
                            if (b.isBFGMainProjectile) { 
                                if (e.takeDamage(b.damage)) enemySurvived = false; 
                                b.life = 0; playBFGImpactSound(); 
                                if (player) fireBFGTracers(player, activeEnemies.filter(en => en !== e), e, b.tracerDamage); 
                                return false; 
                            } else if (!b.isRocket) { 
                                if (e.takeDamage(b.damage)) enemySurvived = false; 
                                b.life = 0; return false; 
                            } 
                        } return true; 
                    }); 
                    bullets.forEach((b, bi) => { 
                        if (b.owner === 'enemy' && player && Math.hypot(b.x - player.x, b.y - player.y) < b.radius + player.radius) { 
                            player.takeDamage(b.damage); bullets.splice(bi, 1); 
                        } 
                    }); 

                    if (enemySurvived && e.health > 0) { 
                        enemies.push(e); 
                    } 
                }); 

                // Level completion check for regular levels (non-boss, non-mini-boss)
                if (!isBossLevel && !isCurrentLevelMiniBoss && enemiesRemaining <= 0 && enemiesSpawnedThisLevel >= enemiesToSpawnPerLevel) {
                    if (!isLevelCompleting) { 
                         let exitTileExists = false;
                         for (let r_ex = 0; r_ex < MAP_ROWS; r_ex++) {
                             for (let c_ex = 0; c_ex < MAP_COLS; c_ex++) {
                                 if (gameMap[r_ex][c_ex] === TILE_EXIT) {
                                     exitTileExists = true; break;
                                 }
                             }
                             if(exitTileExists) break;
                         }
                         if(exitTileExists) levelComplete();
                         else console.log("All regular enemies cleared, but no exit tile found on map.");
                    }
                }
            } catch (e) {
                console.error("Error in update function:", e, e.stack);
                gameRunning = false; 
                 messageTitle.textContent = "Update Error!";
                messageText.innerHTML = `An error occurred in update: ${e.message || JSON.stringify(e)}.<br>Check console. Stack: ${e.stack || 'N/A'}`;
                messageOverlay.style.display = 'flex';
            }
        }

        function draw(){
            try {
                ctx.fillStyle='#333'; ctx.fillRect(0,0,VIEWPORT_WIDTH,VIEWPORT_HEIGHT); 
                
                if (isNaN(camera.x) || isNaN(camera.y)) {
                    console.error("DRAW: Camera coordinates are NaN before translate. x:", camera.x, "y:", camera.y, "Not translating.");
                } else {
                    ctx.save(); 
                    ctx.translate(-camera.x, -camera.y);
                }

                const sC=Math.floor(camera.x/TILE_SIZE),eC=Math.min(sC+Math.ceil(camera.width/TILE_SIZE)+1,MAP_COLS);
                const sR=Math.floor(camera.y/TILE_SIZE),eR=Math.min(sR+Math.ceil(camera.height/TILE_SIZE)+1,MAP_ROWS);

                if (!gameMap || !visibilityMap) {
                    console.error("DRAW: gameMap or visibilityMap is not initialized!");
                    if(ctx.getTransform && !(isNaN(camera.x) || isNaN(camera.y))) ctx.restore(); 
                    return;
                }
                
                for(let r=sR;r<eR;r++){ for(let c=sC;c<eC;c++){ 
                    if(!gameMap[r] || gameMap[r][c] === undefined || !visibilityMap[r] || visibilityMap[r][c] === undefined) { 
                        ctx.fillStyle = '#101010'; 
                        ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        continue; 
                    } 
                    const tileIsVisible = visibilityMap[r][c]; const tileType = gameMap[r][c]; let tileColor = null; 
                    if (tileIsVisible) { 
                        if (tileType === TILE_EMPTY) {} 
                        else if (tileType >= TILE_KEY_RED && tileType <= TILE_HEALTH_PACK && tileType !== TILE_EXIT) { 
                            switch(tileType) { case TILE_KEY_RED: tileColor = 'red'; break; case TILE_KEY_YELLOW: tileColor = 'yellow'; break; case TILE_KEY_BLUE: tileColor = 'blue'; break; case TILE_WEAPON_SHOTGUN: tileColor = '#FFA500'; break; case TILE_WEAPON_MACHINEGUN: tileColor = '#ADD8E6'; break; case TILE_WEAPON_ROCKETLAUNCHER: tileColor = '#FF4500'; break; case TILE_WEAPON_BFG: tileColor = '#00DD00'; break; case TILE_HEALTH_PACK: tileColor = 'lime'; break;} 
                            if (tileColor) { ctx.fillStyle = tileColor; ctx.fillRect(c*TILE_SIZE, r*TILE_SIZE, TILE_SIZE, TILE_SIZE); let itemText = null; let itemTextColor = 'white'; if (tileType >= TILE_KEY_RED && tileType <= TILE_KEY_BLUE) itemText = "K"; else if (tileType === TILE_WEAPON_SHOTGUN) {itemText = "SG"; itemTextColor = 'black';} else if (tileType === TILE_WEAPON_MACHINEGUN) {itemText = "MG"; itemTextColor = 'black';} else if (tileType === TILE_WEAPON_ROCKETLAUNCHER) {itemText = "RL"; itemTextColor = 'black';} else if (tileType === TILE_WEAPON_BFG) {itemText = "BFG"; itemTextColor = 'black';} else if (tileType === TILE_HEALTH_PACK) {itemText = "H"; itemTextColor = 'black';} if(itemText) { ctx.fillStyle = itemTextColor; ctx.font = `${TILE_SIZE* (itemText.length > 2 ? 0.4 : 0.6)}px "Press Start 2P"`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(itemText, c*TILE_SIZE + TILE_SIZE/2, r*TILE_SIZE + TILE_SIZE/2 + 2); } } 
                        } else if (tileType === TILE_EXIT) {
                            tileColor = 'purple';
                            ctx.fillStyle = tileColor;
                            ctx.fillRect(c*TILE_SIZE, r*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            let itemText = "E";
                            let itemTextColor = 'white';

                            if (isCurrentLevelMiniBoss && currentBoss && currentBoss.health > 0) {
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.7)'; 
                                ctx.font = `${TILE_SIZE * 0.8}px "Press Start 2P"`; 
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText("X", c * TILE_SIZE + TILE_SIZE / 2, r * TILE_SIZE + TILE_SIZE / 2 + 2);
                            } else {
                                ctx.fillStyle = itemTextColor;
                                ctx.font = `${TILE_SIZE * 0.6}px "Press Start 2P"`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(itemText, c * TILE_SIZE + TILE_SIZE / 2, r * TILE_SIZE + TILE_SIZE / 2 + 2);
                            }
                        }
                    } else { ctx.fillStyle = '#202020'; ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE); } 
                } }

                if (visibilityMap && visibilityMap.length > 0) { 
                    healthPacks.forEach(p => { 
                        const packTileY = Math.floor(p.y/TILE_SIZE);
                        const packTileX = Math.floor(p.x/TILE_SIZE);
                        if(visibilityMap[packTileY] && visibilityMap[packTileY][packTileX]) { 
                            p.draw(); 
                        } 
                    }); 
                    ammoPacks.forEach(pack => {
                        const packTileY = Math.floor(pack.y / TILE_SIZE);
                        const packTileX = Math.floor(pack.x / TILE_SIZE);
                        if (visibilityMap[packTileY] && visibilityMap[packTileY][packTileX]) {
                            pack.draw();
                        }
                    });
                }
                
                if ((isBossLevel || isCurrentLevelMiniBoss) && currentBoss) { currentBoss.draw(); } 
                enemies.forEach(e => e.draw()); // Always draw regular enemies

                if (player) player.draw(); 
                bullets.forEach(b => b.draw()); 
                explosions.forEach(exp => exp.draw()); 
                temporaryVisualEffects.forEach(effect => { if (effect.type === 'bfg_tracer' && effect.life > 0) { ctx.strokeStyle = effect.color; ctx.lineWidth = 2 + (effect.life / 5); ctx.beginPath(); ctx.moveTo(effect.startX, effect.startY); ctx.lineTo(effect.endX, effect.endY); ctx.stroke(); } }); 

                for(let r=sR;r<eR;r++){ for(let c=sC;c<eC;c++){ 
                    if(!gameMap || !gameMap[r] || gameMap[r][c] === undefined || !visibilityMap || !visibilityMap[r] || visibilityMap[r][c] === undefined) continue; 
                    const tileIsVisible = visibilityMap[r][c]; const tileType = gameMap[r][c]; let tileColor = null; 
                    if (tileIsVisible) { 
                        currentWallStyle = wallStyles[(currentLevel -1) % wallStyles.length]; 
                        if (tileType === TILE_WALL) { tileColor = currentWallStyle.fillColor; } 
                        else if (tileType >= TILE_DOOR_RED && tileType <= TILE_DOOR_BLUE) { 
                            switch(tileType) { case TILE_DOOR_RED: tileColor = 'darkred'; break; case TILE_DOOR_YELLOW: tileColor = 'goldenrod'; break; case TILE_DOOR_BLUE: tileColor = 'darkblue'; break; } 
                        } else if (tileType === TILE_SECRET_DOOR) {
                            tileColor = currentWallStyle.fillColor; // Draw as normal wall first
                        }
                        if(tileColor) { 
                            ctx.fillStyle = tileColor; 
                            ctx.fillRect(c*TILE_SIZE, r*TILE_SIZE, TILE_SIZE, TILE_SIZE); 
                            if (tileType === TILE_WALL || tileType === TILE_SECRET_DOOR) { 
                                ctx.strokeStyle = currentWallStyle.borderColor; 
                                ctx.strokeRect(c*TILE_SIZE, r*TILE_SIZE, TILE_SIZE, TILE_SIZE); 
                                if (currentWallStyle.pattern) { 
                                    currentWallStyle.pattern(c*TILE_SIZE, r*TILE_SIZE, TILE_SIZE, ctx); 
                                }
                                if (tileType === TILE_SECRET_DOOR) { // Add subtle indicator
                                    ctx.fillStyle = 'rgba(0,0,0,0.15)'; // Slightly darker inset
                                    ctx.fillRect(c * TILE_SIZE + TILE_SIZE * 0.15, r * TILE_SIZE + TILE_SIZE * 0.15, TILE_SIZE * 0.7, TILE_SIZE * 0.7);
                                }
                            } else if (tileType >= TILE_DOOR_RED && tileType <= TILE_DOOR_BLUE) { 
                                ctx.strokeStyle = '#444'; ctx.strokeRect(c*TILE_SIZE, r*TILE_SIZE, TILE_SIZE, TILE_SIZE); 
                            } 
                        } 
                    } 
                } } 
                
                if (!(isNaN(camera.x) || isNaN(camera.y))) { 
                    ctx.restore();
                }
            } catch (e) {
                console.error("Error in draw function:", e, e.stack);
                gameRunning = false; 
                messageTitle.textContent = "Draw Error!";
                messageText.innerHTML = `An error occurred in draw: ${e.message || JSON.stringify(e)}.<br>Check console. Stack: ${e.stack || 'N/A'}`;
                messageOverlay.style.display = 'flex';
            }
        }
        
        // Wall pattern drawing functions
        function drawMetalPattern(x, y, size, context) { context.fillStyle = 'rgba(200, 200, 200, 0.5)'; const rivetSize = size / 10; const offset = size / 8; context.beginPath(); context.arc(x + offset, y + offset, rivetSize, 0, Math.PI * 2); context.fill(); context.beginPath(); context.arc(x + size - offset, y + offset, rivetSize, 0, Math.PI * 2); context.fill(); context.beginPath(); context.arc(x + offset, y + size - offset, rivetSize, 0, Math.PI * 2); context.fill(); context.beginPath(); context.arc(x + size - offset, y + size - offset, rivetSize, 0, Math.PI * 2); context.fill(); }
        function drawStonePattern(x, y, size, context) { context.strokeStyle = 'rgba(0, 0, 0, 0.2)'; context.lineWidth = 1; for (let i = 0; i < 2; i++) { context.beginPath(); context.moveTo(x + Math.random() * size, y + Math.random() * size); context.lineTo(x + Math.random() * size, y + Math.random() * size); context.stroke(); } }

        // UI Update functions
        function updateKeyUI() { if(player && player.keysCollected) { redKeyIcon.classList.toggle('collected', player.keysCollected.red); yellowKeyIcon.classList.toggle('collected', player.keysCollected.yellow); blueKeyIcon.classList.toggle('collected', player.keysCollected.blue); } }
        function updateWeaponUI() { 
            if (player && weaponInventoryIcons) { 
                const currentWeapon = player.getCurrentWeapon(); 
                const invIcons = weaponInventoryIcons.querySelectorAll('.weapon-icon-display');
                invIcons.forEach(icon => {
                    const weaponName = icon.dataset.weaponName; 
                    const weaponInInventory = player.weapons.find(w => w.name === weaponName);
                    const ammoTextSpan = icon.querySelector('.ammo-text-display');

                    if (weaponInInventory) { 
                        icon.classList.toggle('owned', weaponInInventory.owned); 
                        if (ammoTextSpan) {
                            if (weaponInInventory.ammo === Infinity) {
                                ammoTextSpan.textContent = "Inf";
                            } else if (weaponInInventory.ammo >= 0 || weaponInInventory.owned) { // Show 0 if owned but no ammo
                                ammoTextSpan.textContent = `${weaponInInventory.ammo}`; 
                            } else {
                                ammoTextSpan.textContent = "--";
                            }
                        }
                        if (currentWeapon && currentWeapon.name === weaponName && weaponInInventory.owned) { 
                            icon.classList.add('selected-weapon-icon');
                        } else {
                            icon.classList.remove('selected-weapon-icon');
                        }
                    } else { 
                        icon.classList.remove('owned'); 
                        icon.classList.remove('selected-weapon-icon');
                        if (ammoTextSpan) ammoTextSpan.textContent = "--";
                    }
                });
            }
        }


        // Message Overlay functions
        function showGameOverScreen() { gameOver = true; gameRunning = false; messageTitle.textContent = "Game Over!"; messageText.textContent = `You survived ${currentLevel} levels. Final Score: ${score}`; restartButton.textContent = "Restart Game"; difficultySelectionDiv.style.display = 'flex'; instructionsButton.style.display = 'block'; /* Show instructions button */ messageOverlay.style.display = 'flex'; if (gameLoopId) cancelAnimationFrame(gameLoopId); } 
        
        function showStartScreen() { 
            gameOver = false; 
            gameRunning = false; 
            messageTitle.textContent = "Top-Down Doom-Like Game"; // Changed title
            messageText.innerHTML = ""; // Emptied message text as per request
            restartButton.textContent = "Start Game"; 
            difficultySelectionDiv.style.display = 'flex'; 
            instructionsButton.style.display = 'block'; // Ensure instructions button is visible
            messageOverlay.style.display = 'flex'; 
            // controlsInfo.textContent = "Controls: Arrow Keys/WASD: Move, 1-5: Weapon, Mouse: Aim, Click: Shoot. Cheats: I,K,G,L"; // This is now in the modal
        }

        // Instructions Modal Functions
        function showInstructions() {
            instructionsTextContent.innerHTML = `
                <strong>Objective:</strong> Find keys, open doors, and reach the Exit!<br>
                A Mini-Boss guards the exit on Level 3, and randomly on later levels (not main boss levels). <br>
                Main Bosses appear every 5 levels!<br>
                Look for subtly different wall tiles to find secret rooms!<br><br>
                <strong>Movement:</strong> Arrow Keys or WASD<br>
                <strong>Aim:</strong> Mouse<br>
                <strong>Shoot:</strong> Click<br>
                <strong>Switch Weapon:</strong> Keys 1, 2, 3, 4, 5<br>
                (Pistol, Shotgun, Machine Gun, Rocket Launcher, BFG respectively)<br><br>
                <strong>Pickups:</strong><br>
                <span style="color:lime;">Green Cross:</span> Health Pack<br>
                <span style="color:red;">Red/</span><span style="color:yellow;">Yellow/</span><span style="color:blue;">Blue Squares:</span> Keys<br>
                <span style="color:purple;">Purple Square:</span> Level Exit (may be locked!)<br>
                <span style="color:#FFA500;">SG</span>/<span style="color:#ADD8E6;">MG</span>/<span style="color:#FF4500;">RL</span>/<span style="color:#00DD00;">BFG</span>: Weapon Pickups<br>
                <span style="color:#AAAAAA;">Grey Boxes (S,M,R,B):</span> Ammo Pickups<br><br>
                <strong>Cheats (for testing):</strong><br>
                I - Toggle Invincibility/Phasing<br>
                K - Collect All Keys<br>
                G - Collect All Guns & Max Ammo<br>
                L - Complete Level (skip to next)
            `;
            instructionsOverlay.style.display = 'flex';
        }

        function hideInstructions() {
            instructionsOverlay.style.display = 'none';
        }


        // Event Listeners
        difficultyButtons.forEach(button => { button.addEventListener('click', () => { difficultyButtons.forEach(btn => btn.classList.remove('selected')); button.classList.add('selected'); selectedDifficulty = button.dataset.difficulty; }); });
        window.addEventListener('keydown', (e) => { const keyName = e.key.toLowerCase(); if (keys.hasOwnProperty(e.key)) keys[e.key] = true; else if (keys.hasOwnProperty(keyName)) keys[keyName] = true; if (gameRunning && player) { if (keyName === 'i' && !keys.i_cheat_processed) { keys.i_cheat_processed = true; player.canPhase = !player.canPhase; } else if (keyName === 'k' && !keys.k_cheat_processed) { keys.k_cheat_processed = true; player.collectAllKeys(); } else if (keyName === 'g' && !keys.g_cheat_processed) { keys.g_cheat_processed = true; player.collectAllGuns(); } else if (keyName === 'l' && !keys.l_cheat_processed) { keys.l_cheat_processed = true; levelComplete(); } } if (gameRunning && player) { if (keyName === '1' && !keys.weapon_1_processed) { player.switchWeapon(0); keys.weapon_1_processed = true; } else if (keyName === '2' && !keys.weapon_2_processed) { const idx = player.weapons.findIndex(w=>w.name==="Shotgun"); if(idx!==-1 && player.weapons[idx].owned) player.switchWeapon(idx); keys.weapon_2_processed = true; } else if (keyName === '3' && !keys.weapon_3_processed) { const idx = player.weapons.findIndex(w=>w.name==="Machine Gun"); if(idx!==-1 && player.weapons[idx].owned)player.switchWeapon(idx); keys.weapon_3_processed = true; } else if (keyName === '4' && !keys.weapon_4_processed) { const idx = player.weapons.findIndex(w=>w.name==="Rocket Launcher"); if(idx!==-1 && player.weapons[idx].owned)player.switchWeapon(idx); keys.weapon_4_processed = true; } else if (keyName === '5' && !keys.weapon_5_processed) { const idx = player.weapons.findIndex(w=>w.name==="BFG"); if(idx!==-1 && player.weapons[idx].owned)player.switchWeapon(idx); keys.weapon_5_processed = true; } } });
        window.addEventListener('keyup', (e) => { const keyName = e.key.toLowerCase(); if (keys.hasOwnProperty(e.key)) keys[e.key] = false; else if (keys.hasOwnProperty(keyName)) keys[keyName] = false; if (keyName === 'i') keys.i_cheat_processed = false; else if (keyName === 'k') keys.k_cheat_processed = false; else if (keyName === 'g') keys.g_cheat_processed = false; else if (keyName === 'l') keys.l_cheat_processed = false; if (keyName === '1') keys.weapon_1_processed = false; if (keyName === '2') keys.weapon_2_processed = false; if (keyName === '3') keys.weapon_3_processed = false; if (keyName === '4') keys.weapon_4_processed = false; if (keyName === '5') keys.weapon_5_processed = false; });
        canvas.addEventListener('mousemove', (e)=>{ const r=canvas.getBoundingClientRect();mouse.x=e.clientX-r.left;mouse.y=e.clientY-r.top;});
        canvas.addEventListener('mousedown', (e)=>{if(e.button===0){ensureAudioAndSynths();mouse.down=true;}}); 
        canvas.addEventListener('mouseup', (e)=>{if(e.button===0)mouse.down=false;});
        canvas.addEventListener('contextmenu', (e)=>e.preventDefault()); 
        
        restartButton.addEventListener('click', () => { 
            console.log("Restart/Next Level button clicked. Text:", `"${restartButton.textContent}"`);
            
            ensureAudioAndSynths(); 
            console.log("DEBUG: ensureAudioAndSynths called (no await). Hiding message overlay.");
            messageOverlay.style.display = 'none';
            console.log("DEBUG: messageOverlay hidden. Checking button text.");

            const buttonText = restartButton.textContent.trim();

            if (buttonText === "Start Game") {
                console.log("DEBUG: Condition 'Start Game' is TRUE. Calling startGame().");
                try {
                    startGame();
                } catch (e) {
                    console.error("CRITICAL ERROR during startGame() call:", e, e.stack);
                    messageTitle.textContent = "Start Game Error!";
                    messageText.innerHTML = `Error starting game: ${e.message || JSON.stringify(e)}.<br>Check console. Stack: ${e.stack || 'N/A'}`;
                    messageOverlay.style.display = 'flex';
                }
            } else if (gameOver || buttonText === "Restart Game") {
                console.log("DEBUG: Condition 'gameOver' or 'Restart Game' is TRUE. Calling startGame().");
                 try {
                    startGame();
                } catch (e) {
                    console.error("CRITICAL ERROR during startGame() (restart) call:", e, e.stack);
                    messageTitle.textContent = "Restart Game Error!";
                    messageText.innerHTML = `Error restarting game: ${e.message || JSON.stringify(e)}.<br>Check console. Stack: ${e.stack || 'N/A'}`;
                    messageOverlay.style.display = 'flex';
                }
            } else if (buttonText === "Next Level") {
                console.log("DEBUG: Condition 'Next Level' is TRUE. Incrementing level and calling initLevel().");
                currentLevel++;
                try {
                    initLevel();
                } catch (e) {
                    console.error("CRITICAL ERROR during initLevel() call:", e, e.stack);
                    messageTitle.textContent = "Next Level Error!";
                    messageText.innerHTML = `Error loading next level: ${e.message || JSON.stringify(e)}.<br>Check console. Stack: ${e.stack || 'N/A'}`;
                    messageOverlay.style.display = 'flex';
                }
            } else {
                console.error("DEBUG: Button text NOT RECOGNIZED:", `"${buttonText}"`, "gameOver:", gameOver);
            }
            console.log("DEBUG: restartButton click handler finished.");
        });
        
        // Instructions modal event listeners
        instructionsButton.addEventListener('click', showInstructions);
        closeInstructionsButton.addEventListener('click', hideInstructions);

        playerSpriteImage.onload = () => { 
            console.log("Player sprite loaded successfully.");
            showStartScreen(); 
        };
        playerSpriteImage.onerror = () => { 
            console.error("Player sprite failed to load. Using fallback drawing.");
            showStartScreen(); 
        }
        if (playerSpriteImage.complete && playerSpriteImage.naturalHeight !== 0) {
            console.log("Player sprite already complete, calling showStartScreen.");
            showStartScreen();
        } else if (playerSpriteImage.complete && playerSpriteImage.naturalHeight === 0) {
            console.error("Player sprite reported complete but has no dimensions (likely failed to load).");
            showStartScreen(); 
        }


        console.log("SCRIPT END: Event listeners attached, game ready for user interaction.");
    </script>
</body>
</html>
